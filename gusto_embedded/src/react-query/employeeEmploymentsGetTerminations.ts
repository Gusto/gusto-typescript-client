/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { GustoEmbeddedCore } from "../core.js";
import { employeeEmploymentsGetTerminations } from "../funcs/employeeEmploymentsGetTerminations.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useGustoEmbeddedContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type EmployeeEmploymentsGetTerminationsQueryData = Array<
  components.Termination
>;

/**
 * Get terminations for an employee
 *
 * @remarks
 * Terminations are created whenever an employee is scheduled to leave the company. The only things required are an effective date (their last day of work) and whether they should receive their wages in a one-off termination payroll or with the rest of the company.
 *
 * Note that some states require employees to receive their final wages within 24 hours (unless they consent otherwise,) in which case running a one-off payroll may be the only option.
 *
 * scope: `employments:read`
 */
export function useEmployeeEmploymentsGetTerminations(
  request: operations.GetV1EmployeesEmployeeIdTerminationsRequest,
  options?: QueryHookOptions<EmployeeEmploymentsGetTerminationsQueryData>,
): UseQueryResult<EmployeeEmploymentsGetTerminationsQueryData, Error> {
  const client = useGustoEmbeddedContext();
  return useQuery({
    ...buildEmployeeEmploymentsGetTerminationsQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * Get terminations for an employee
 *
 * @remarks
 * Terminations are created whenever an employee is scheduled to leave the company. The only things required are an effective date (their last day of work) and whether they should receive their wages in a one-off termination payroll or with the rest of the company.
 *
 * Note that some states require employees to receive their final wages within 24 hours (unless they consent otherwise,) in which case running a one-off payroll may be the only option.
 *
 * scope: `employments:read`
 */
export function useEmployeeEmploymentsGetTerminationsSuspense(
  request: operations.GetV1EmployeesEmployeeIdTerminationsRequest,
  options?: SuspenseQueryHookOptions<
    EmployeeEmploymentsGetTerminationsQueryData
  >,
): UseSuspenseQueryResult<EmployeeEmploymentsGetTerminationsQueryData, Error> {
  const client = useGustoEmbeddedContext();
  return useSuspenseQuery({
    ...buildEmployeeEmploymentsGetTerminationsQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchEmployeeEmploymentsGetTerminations(
  queryClient: QueryClient,
  client$: GustoEmbeddedCore,
  request: operations.GetV1EmployeesEmployeeIdTerminationsRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildEmployeeEmploymentsGetTerminationsQuery(
      client$,
      request,
    ),
  });
}

export function setEmployeeEmploymentsGetTerminationsData(
  client: QueryClient,
  queryKeyBase: [
    employeeId: string,
    parameters: { xGustoAPIVersion?: components.VersionHeader | undefined },
  ],
  data: EmployeeEmploymentsGetTerminationsQueryData,
): EmployeeEmploymentsGetTerminationsQueryData | undefined {
  const key = queryKeyEmployeeEmploymentsGetTerminations(...queryKeyBase);

  return client.setQueryData<EmployeeEmploymentsGetTerminationsQueryData>(
    key,
    data,
  );
}

export function invalidateEmployeeEmploymentsGetTerminations(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      employeeId: string,
      parameters: { xGustoAPIVersion?: components.VersionHeader | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: [
      "@gusto/embedded-api",
      "employeeEmployments",
      "getTerminations",
      ...queryKeyBase,
    ],
  });
}

export function invalidateAllEmployeeEmploymentsGetTerminations(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@gusto/embedded-api", "employeeEmployments", "getTerminations"],
  });
}

export function buildEmployeeEmploymentsGetTerminationsQuery(
  client$: GustoEmbeddedCore,
  request: operations.GetV1EmployeesEmployeeIdTerminationsRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<EmployeeEmploymentsGetTerminationsQueryData>;
} {
  return {
    queryKey: queryKeyEmployeeEmploymentsGetTerminations(request.employeeId, {
      xGustoAPIVersion: request.xGustoAPIVersion,
    }),
    queryFn: async function employeeEmploymentsGetTerminationsQueryFn(
      ctx,
    ): Promise<EmployeeEmploymentsGetTerminationsQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(employeeEmploymentsGetTerminations(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyEmployeeEmploymentsGetTerminations(
  employeeId: string,
  parameters: { xGustoAPIVersion?: components.VersionHeader | undefined },
): QueryKey {
  return [
    "@gusto/embedded-api",
    "employeeEmployments",
    "getTerminations",
    employeeId,
    parameters,
  ];
}

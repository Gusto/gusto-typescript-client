/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
  InvalidateQueryFilters,
  QueryClient,
  QueryFunctionContext,
  QueryKey,
  useQuery,
  UseQueryResult,
  useSuspenseQuery,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { GustoEmbeddedCore } from "../core.js";
import { employeeEmploymentsGetTermination } from "../funcs/employeeEmploymentsGetTermination.js";
import { combineSignals } from "../lib/primitives.js";
import { RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { useGustoEmbeddedContext } from "./_context.js";
import {
  QueryHookOptions,
  SuspenseQueryHookOptions,
  TupleToPrefixes,
} from "./_types.js";

export type EmployeeEmploymentsGetTerminationQueryData = Array<
  components.Termination
>;

/**
 * Get terminations for an employee
 *
 * @remarks
 * Terminations are created whenever an employee is scheduled to leave the company. The only things required are an effective date (their last day of work) and whether they should receive their wages in a one-off termination payroll or with the rest of the company.
 *
 * Note that some states require employees to receive their final wages within 24 hours (unless they consent otherwise,) in which case running a one-off payroll may be the only option.
 *
 * scope: `employments:read`
 */
export function useEmployeeEmploymentsGetTermination(
  request: operations.GetV1EmployeesEmployeeIdTerminationsRequest,
  options?: QueryHookOptions<EmployeeEmploymentsGetTerminationQueryData>,
): UseQueryResult<EmployeeEmploymentsGetTerminationQueryData, Error> {
  const client = useGustoEmbeddedContext();
  return useQuery({
    ...buildEmployeeEmploymentsGetTerminationQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

/**
 * Get terminations for an employee
 *
 * @remarks
 * Terminations are created whenever an employee is scheduled to leave the company. The only things required are an effective date (their last day of work) and whether they should receive their wages in a one-off termination payroll or with the rest of the company.
 *
 * Note that some states require employees to receive their final wages within 24 hours (unless they consent otherwise,) in which case running a one-off payroll may be the only option.
 *
 * scope: `employments:read`
 */
export function useEmployeeEmploymentsGetTerminationSuspense(
  request: operations.GetV1EmployeesEmployeeIdTerminationsRequest,
  options?: SuspenseQueryHookOptions<
    EmployeeEmploymentsGetTerminationQueryData
  >,
): UseSuspenseQueryResult<EmployeeEmploymentsGetTerminationQueryData, Error> {
  const client = useGustoEmbeddedContext();
  return useSuspenseQuery({
    ...buildEmployeeEmploymentsGetTerminationQuery(
      client,
      request,
      options,
    ),
    ...options,
  });
}

export function prefetchEmployeeEmploymentsGetTermination(
  queryClient: QueryClient,
  client$: GustoEmbeddedCore,
  request: operations.GetV1EmployeesEmployeeIdTerminationsRequest,
): Promise<void> {
  return queryClient.prefetchQuery({
    ...buildEmployeeEmploymentsGetTerminationQuery(
      client$,
      request,
    ),
  });
}

export function setEmployeeEmploymentsGetTerminationData(
  client: QueryClient,
  queryKeyBase: [
    employeeId: string,
    parameters: { xGustoAPIVersion?: components.VersionHeader | undefined },
  ],
  data: EmployeeEmploymentsGetTerminationQueryData,
): EmployeeEmploymentsGetTerminationQueryData | undefined {
  const key = queryKeyEmployeeEmploymentsGetTermination(...queryKeyBase);

  return client.setQueryData<EmployeeEmploymentsGetTerminationQueryData>(
    key,
    data,
  );
}

export function invalidateEmployeeEmploymentsGetTermination(
  client: QueryClient,
  queryKeyBase: TupleToPrefixes<
    [
      employeeId: string,
      parameters: { xGustoAPIVersion?: components.VersionHeader | undefined },
    ]
  >,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: [
      "@gusto/embedded-api",
      "employeeEmployments",
      "getTermination",
      ...queryKeyBase,
    ],
  });
}

export function invalidateAllEmployeeEmploymentsGetTermination(
  client: QueryClient,
  filters?: Omit<InvalidateQueryFilters, "queryKey" | "predicate" | "exact">,
): Promise<void> {
  return client.invalidateQueries({
    ...filters,
    queryKey: ["@gusto/embedded-api", "employeeEmployments", "getTermination"],
  });
}

export function buildEmployeeEmploymentsGetTerminationQuery(
  client$: GustoEmbeddedCore,
  request: operations.GetV1EmployeesEmployeeIdTerminationsRequest,
  options?: RequestOptions,
): {
  queryKey: QueryKey;
  queryFn: (
    context: QueryFunctionContext,
  ) => Promise<EmployeeEmploymentsGetTerminationQueryData>;
} {
  return {
    queryKey: queryKeyEmployeeEmploymentsGetTermination(request.employeeId, {
      xGustoAPIVersion: request.xGustoAPIVersion,
    }),
    queryFn: async function employeeEmploymentsGetTerminationQueryFn(
      ctx,
    ): Promise<EmployeeEmploymentsGetTerminationQueryData> {
      const sig = combineSignals(ctx.signal, options?.fetchOptions?.signal);
      const mergedOptions = {
        ...options,
        fetchOptions: { ...options?.fetchOptions, signal: sig },
      };

      return unwrapAsync(employeeEmploymentsGetTermination(
        client$,
        request,
        mergedOptions,
      ));
    },
  };
}

export function queryKeyEmployeeEmploymentsGetTermination(
  employeeId: string,
  parameters: { xGustoAPIVersion?: components.VersionHeader | undefined },
): QueryKey {
  return [
    "@gusto/embedded-api",
    "employeeEmployments",
    "getTermination",
    employeeId,
    parameters,
  ];
}

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import {
  HTTPMetadata,
  HTTPMetadata$inboundSchema,
} from "../components/httpmetadata.js";
import {
  InformationRequest,
  InformationRequest$inboundSchema,
} from "../components/informationrequest.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Type of response - matches the question's response_type from GET
 */
export const ResponseType = {
  Text: "text",
  Document: "document",
} as const;
/**
 * Type of response - matches the question's response_type from GET
 */
export type ResponseType = ClosedEnum<typeof ResponseType>;

export type RequiredQuestions = {
  /**
   * UUID of the question being answered
   */
  questionUuid: string;
  /**
   * Type of response - matches the question's response_type from GET
   */
  responseType: ResponseType;
  /**
   * Text response (required when response_type is text)
   */
  textResponse?: string | undefined;
  /**
   * Data URL with base64-encoded file (e.g., "data:image/png;base64,..."). Required when response_type is document.
   */
  fileResponse?: string | undefined;
  /**
   * Original filename with extension (e.g., "document.pdf"). Used for document uploads.
   */
  fileName?: string | undefined;
};

export type SubmitInformationRequestRequestBody = {
  requiredQuestions?: Array<RequiredQuestions> | undefined;
};

export type SubmitInformationRequestRequest = {
  /**
   * The UUID of the information request
   */
  informationRequestUuid: string;
  requestBody: SubmitInformationRequestRequestBody;
};

export type SubmitInformationRequestResponse = {
  httpMeta: HTTPMetadata;
  /**
   * Information request successfully submitted
   */
  informationRequest?: InformationRequest | undefined;
};

/** @internal */
export const ResponseType$outboundSchema: z.ZodNativeEnum<typeof ResponseType> =
  z.nativeEnum(ResponseType);

/** @internal */
export type RequiredQuestions$Outbound = {
  question_uuid: string;
  response_type: string;
  text_response?: string | undefined;
  file_response?: string | undefined;
  file_name?: string | undefined;
};

/** @internal */
export const RequiredQuestions$outboundSchema: z.ZodType<
  RequiredQuestions$Outbound,
  z.ZodTypeDef,
  RequiredQuestions
> = z.object({
  questionUuid: z.string(),
  responseType: ResponseType$outboundSchema,
  textResponse: z.string().optional(),
  fileResponse: z.string().optional(),
  fileName: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    questionUuid: "question_uuid",
    responseType: "response_type",
    textResponse: "text_response",
    fileResponse: "file_response",
    fileName: "file_name",
  });
});

export function requiredQuestionsToJSON(
  requiredQuestions: RequiredQuestions,
): string {
  return JSON.stringify(
    RequiredQuestions$outboundSchema.parse(requiredQuestions),
  );
}

/** @internal */
export type SubmitInformationRequestRequestBody$Outbound = {
  required_questions?: Array<RequiredQuestions$Outbound> | undefined;
};

/** @internal */
export const SubmitInformationRequestRequestBody$outboundSchema: z.ZodType<
  SubmitInformationRequestRequestBody$Outbound,
  z.ZodTypeDef,
  SubmitInformationRequestRequestBody
> = z.object({
  requiredQuestions: z.array(z.lazy(() => RequiredQuestions$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    requiredQuestions: "required_questions",
  });
});

export function submitInformationRequestRequestBodyToJSON(
  submitInformationRequestRequestBody: SubmitInformationRequestRequestBody,
): string {
  return JSON.stringify(
    SubmitInformationRequestRequestBody$outboundSchema.parse(
      submitInformationRequestRequestBody,
    ),
  );
}

/** @internal */
export type SubmitInformationRequestRequest$Outbound = {
  information_request_uuid: string;
  RequestBody: SubmitInformationRequestRequestBody$Outbound;
};

/** @internal */
export const SubmitInformationRequestRequest$outboundSchema: z.ZodType<
  SubmitInformationRequestRequest$Outbound,
  z.ZodTypeDef,
  SubmitInformationRequestRequest
> = z.object({
  informationRequestUuid: z.string(),
  requestBody: z.lazy(() => SubmitInformationRequestRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    informationRequestUuid: "information_request_uuid",
    requestBody: "RequestBody",
  });
});

export function submitInformationRequestRequestToJSON(
  submitInformationRequestRequest: SubmitInformationRequestRequest,
): string {
  return JSON.stringify(
    SubmitInformationRequestRequest$outboundSchema.parse(
      submitInformationRequestRequest,
    ),
  );
}

/** @internal */
export const SubmitInformationRequestResponse$inboundSchema: z.ZodType<
  SubmitInformationRequestResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  HttpMeta: HTTPMetadata$inboundSchema,
  "Information-Request": InformationRequest$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "HttpMeta": "httpMeta",
    "Information-Request": "informationRequest",
  });
});

export function submitInformationRequestResponseFromJSON(
  jsonString: string,
): SafeParseResult<SubmitInformationRequestResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubmitInformationRequestResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubmitInformationRequestResponse' from JSON`,
  );
}

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import {
  Compensation,
  Compensation$inboundSchema,
} from "../components/compensation.js";
import {
  FlsaStatusType,
  FlsaStatusType$outboundSchema,
} from "../components/flsastatustype.js";
import {
  HTTPMetadata,
  HTTPMetadata$inboundSchema,
} from "../components/httpmetadata.js";
import {
  VersionHeader,
  VersionHeader$outboundSchema,
} from "../components/versionheader.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The unit accompanying the compensation rate. If the employee is an owner, rate should be 'Paycheck'.
 */
export const PaymentUnit = {
  Hour: "Hour",
  Week: "Week",
  Month: "Month",
  Year: "Year",
  Paycheck: "Paycheck",
} as const;
/**
 * The unit accompanying the compensation rate. If the employee is an owner, rate should be 'Paycheck'.
 */
export type PaymentUnit = ClosedEnum<typeof PaymentUnit>;

/**
 * The minimum wage record you want to apply to the compensation
 */
export type MinimumWages = {
  /**
   * The UUID of the minimum wage record. Required if adjust_for_minimum_wage set to true
   */
  uuid?: string | undefined;
};

export type PostV1CompensationsCompensationIdRequestBody = {
  /**
   * The dollar amount paid per payment unit.
   */
  rate?: string | undefined;
  /**
   * The unit accompanying the compensation rate. If the employee is an owner, rate should be 'Paycheck'.
   */
  paymentUnit: PaymentUnit;
  /**
   * The date when the compensation takes effect.
   */
  effectiveDate?: string | undefined;
  /**
   * The FLSA status for this compensation. Salaried ('Exempt') employees are paid a fixed salary every pay period. Salaried with overtime ('Salaried Nonexempt') employees are paid a fixed salary every pay period, and receive overtime pay when applicable. Hourly ('Nonexempt') employees are paid for the hours they work, and receive overtime pay when applicable. Commissioned employees ('Commission Only Exempt') earn wages based only on commission. Commissioned with overtime ('Commission Only Nonexempt') earn wages based on commission, and receive overtime pay when applicable. Owners ('Owner') are employees that own at least twenty percent of the company.
   */
  flsaStatus: FlsaStatusType;
  /**
   * Determines whether the compensation should be adjusted for minimum wage. Only applies to Nonexempt employees.
   */
  adjustForMinimumWage?: boolean | undefined;
  minimumWages?: Array<MinimumWages> | undefined;
};

export type PostV1CompensationsCompensationIdRequest = {
  /**
   * The UUID of the job
   */
  jobId: string;
  /**
   * Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
   */
  xGustoAPIVersion?: VersionHeader | undefined;
  requestBody: PostV1CompensationsCompensationIdRequestBody;
};

export type PostV1CompensationsCompensationIdResponse = {
  httpMeta: HTTPMetadata;
  /**
   * Example response
   */
  compensation?: Compensation | undefined;
};

/** @internal */
export const PaymentUnit$outboundSchema: z.ZodNativeEnum<typeof PaymentUnit> = z
  .nativeEnum(PaymentUnit);

/** @internal */
export type MinimumWages$Outbound = {
  uuid?: string | undefined;
};

/** @internal */
export const MinimumWages$outboundSchema: z.ZodType<
  MinimumWages$Outbound,
  z.ZodTypeDef,
  MinimumWages
> = z.object({
  uuid: z.string().optional(),
});

export function minimumWagesToJSON(minimumWages: MinimumWages): string {
  return JSON.stringify(MinimumWages$outboundSchema.parse(minimumWages));
}

/** @internal */
export type PostV1CompensationsCompensationIdRequestBody$Outbound = {
  rate?: string | undefined;
  payment_unit: string;
  effective_date?: string | undefined;
  flsa_status: string;
  adjust_for_minimum_wage?: boolean | undefined;
  minimum_wages?: Array<MinimumWages$Outbound> | undefined;
};

/** @internal */
export const PostV1CompensationsCompensationIdRequestBody$outboundSchema:
  z.ZodType<
    PostV1CompensationsCompensationIdRequestBody$Outbound,
    z.ZodTypeDef,
    PostV1CompensationsCompensationIdRequestBody
  > = z.object({
    rate: z.string().optional(),
    paymentUnit: PaymentUnit$outboundSchema,
    effectiveDate: z.string().optional(),
    flsaStatus: FlsaStatusType$outboundSchema,
    adjustForMinimumWage: z.boolean().optional(),
    minimumWages: z.array(z.lazy(() => MinimumWages$outboundSchema)).optional(),
  }).transform((v) => {
    return remap$(v, {
      paymentUnit: "payment_unit",
      effectiveDate: "effective_date",
      flsaStatus: "flsa_status",
      adjustForMinimumWage: "adjust_for_minimum_wage",
      minimumWages: "minimum_wages",
    });
  });

export function postV1CompensationsCompensationIdRequestBodyToJSON(
  postV1CompensationsCompensationIdRequestBody:
    PostV1CompensationsCompensationIdRequestBody,
): string {
  return JSON.stringify(
    PostV1CompensationsCompensationIdRequestBody$outboundSchema.parse(
      postV1CompensationsCompensationIdRequestBody,
    ),
  );
}

/** @internal */
export type PostV1CompensationsCompensationIdRequest$Outbound = {
  job_id: string;
  "X-Gusto-API-Version": string;
  RequestBody: PostV1CompensationsCompensationIdRequestBody$Outbound;
};

/** @internal */
export const PostV1CompensationsCompensationIdRequest$outboundSchema: z.ZodType<
  PostV1CompensationsCompensationIdRequest$Outbound,
  z.ZodTypeDef,
  PostV1CompensationsCompensationIdRequest
> = z.object({
  jobId: z.string(),
  xGustoAPIVersion: VersionHeader$outboundSchema.default("2025-06-15"),
  requestBody: z.lazy(() =>
    PostV1CompensationsCompensationIdRequestBody$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    jobId: "job_id",
    xGustoAPIVersion: "X-Gusto-API-Version",
    requestBody: "RequestBody",
  });
});

export function postV1CompensationsCompensationIdRequestToJSON(
  postV1CompensationsCompensationIdRequest:
    PostV1CompensationsCompensationIdRequest,
): string {
  return JSON.stringify(
    PostV1CompensationsCompensationIdRequest$outboundSchema.parse(
      postV1CompensationsCompensationIdRequest,
    ),
  );
}

/** @internal */
export const PostV1CompensationsCompensationIdResponse$inboundSchema: z.ZodType<
  PostV1CompensationsCompensationIdResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  HttpMeta: HTTPMetadata$inboundSchema,
  Compensation: Compensation$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "HttpMeta": "httpMeta",
    "Compensation": "compensation",
  });
});

export function postV1CompensationsCompensationIdResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  PostV1CompensationsCompensationIdResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostV1CompensationsCompensationIdResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostV1CompensationsCompensationIdResponse' from JSON`,
  );
}

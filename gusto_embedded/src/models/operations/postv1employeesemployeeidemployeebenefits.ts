/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import {
  EmployeeBenefit,
  EmployeeBenefit$inboundSchema,
  EmployeeBenefit$Outbound,
  EmployeeBenefit$outboundSchema,
} from "../components/employeebenefit.js";
import {
  VersionHeader,
  VersionHeader$inboundSchema,
  VersionHeader$outboundSchema,
} from "../components/versionheader.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The company contribution scheme.
 *
 * @remarks
 *
 * `amount`: The company contributes a fixed amount per payroll. If elective is true, the contribution is matching, dollar-for-dollar.
 *
 * `percentage`: The company contributes a percentage of the payroll amount per payroll period. If elective is true, the contribution is matching, dollar-for-dollar.
 *
 * `tiered`: The size of the company contribution corresponds to the size of the employee deduction relative to a tiered matching scheme.
 */
export const PostV1EmployeesEmployeeIdEmployeeBenefitsType = {
  Tiered: "tiered",
  Percentage: "percentage",
  Amount: "amount",
} as const;
/**
 * The company contribution scheme.
 *
 * @remarks
 *
 * `amount`: The company contributes a fixed amount per payroll. If elective is true, the contribution is matching, dollar-for-dollar.
 *
 * `percentage`: The company contributes a percentage of the payroll amount per payroll period. If elective is true, the contribution is matching, dollar-for-dollar.
 *
 * `tiered`: The size of the company contribution corresponds to the size of the employee deduction relative to a tiered matching scheme.
 */
export type PostV1EmployeesEmployeeIdEmployeeBenefitsType = ClosedEnum<
  typeof PostV1EmployeesEmployeeIdEmployeeBenefitsType
>;

/**
 * A single tier of a tiered matching scheme.
 */
export type Two = {
  /**
   * The percentage of employee deduction within this tier the company contribution will match.
   */
  rate?: string | undefined;
  /**
   * The percentage threshold at which this tier ends (inclusive).
   *
   * @remarks
   *
   * For example, a value of "5" means the company contribution will match employee deductions from the previous tier's threshold up to and including 5% of payroll.
   *
   * If this is the first tier, a value of "5" means the company contribution will match employee deductions from 0% up to and including 5% of payroll.
   */
  threshold?: string | undefined;
};

/**
 * For the `amount` and `percentage` contribution types, the value of the corresponding amount or percentage.
 *
 * @remarks
 *
 * For the `tiered` contribution type, an array of tiers.
 */
export type Value = string | Array<Two>;

/**
 * An object representing the company contribution type and value.
 */
export type Contribution = {
  /**
   * The company contribution scheme.
   *
   * @remarks
   *
   * `amount`: The company contributes a fixed amount per payroll. If elective is true, the contribution is matching, dollar-for-dollar.
   *
   * `percentage`: The company contributes a percentage of the payroll amount per payroll period. If elective is true, the contribution is matching, dollar-for-dollar.
   *
   * `tiered`: The size of the company contribution corresponds to the size of the employee deduction relative to a tiered matching scheme.
   */
  type?: PostV1EmployeesEmployeeIdEmployeeBenefitsType | undefined;
  /**
   * For the `amount` and `percentage` contribution types, the value of the corresponding amount or percentage.
   *
   * @remarks
   *
   * For the `tiered` contribution type, an array of tiers.
   */
  value?: string | Array<Two> | undefined;
};

/**
 * Some benefits require additional information to determine
 *
 * @remarks
 * their limit.
 *
 * `Family` or `Individual`: Applicable to HSA benefit.
 *
 * `Joint Filing or Single` or `Married and Filing Separately`: Applicable to Dependent Care FSA benefit.
 */
export const LimitOption = {
  Family: "Family",
  Individual: "Individual",
  JointFilingOrSingle: "Joint Filing or Single",
  MarriedAndFilingSeparately: "Married and Filing Separately",
} as const;
/**
 * Some benefits require additional information to determine
 *
 * @remarks
 * their limit.
 *
 * `Family` or `Individual`: Applicable to HSA benefit.
 *
 * `Joint Filing or Single` or `Married and Filing Separately`: Applicable to Dependent Care FSA benefit.
 */
export type LimitOption = ClosedEnum<typeof LimitOption>;

/**
 * Whether the employee deduction reduces taxable income or not. Only valid for Group Term Life benefits. Note: when the value is not "unset", coverage amount and coverage salary multiplier are ignored.
 */
export const DeductionReducesTaxableIncome = {
  Unset: "unset",
  ReducesTaxableIncome: "reduces_taxable_income",
  DoesNotReduceTaxableIncome: "does_not_reduce_taxable_income",
} as const;
/**
 * Whether the employee deduction reduces taxable income or not. Only valid for Group Term Life benefits. Note: when the value is not "unset", coverage amount and coverage salary multiplier are ignored.
 */
export type DeductionReducesTaxableIncome = ClosedEnum<
  typeof DeductionReducesTaxableIncome
>;

export type PostV1EmployeesEmployeeIdEmployeeBenefitsRequestBody = {
  /**
   * The UUID of the company benefit.
   */
  companyBenefitUuid: string;
  /**
   * Whether the employee benefit is active.
   */
  active?: boolean | undefined;
  /**
   * The amount to be deducted, per pay period, from the employee's pay.
   */
  employeeDeduction?: string | undefined;
  /**
   * Whether the employee deduction amount should be treated as a percentage to be deducted from each payroll.
   */
  deductAsPercentage?: boolean | undefined;
  /**
   * The maximum employee deduction amount per year. A null value signifies no limit.
   */
  employeeDeductionAnnualMaximum?: string | null | undefined;
  /**
   * An object representing the company contribution type and value.
   */
  contribution?: Contribution | undefined;
  /**
   * Whether the company contribution is elective (aka "matching"). For `tiered`, `elective_amount`, and `elective_percentage` contribution types this is ignored and assumed to be `true`.
   */
  elective?: boolean | undefined;
  /**
   * The maximum company contribution amount per year. A null value signifies no limit.
   */
  companyContributionAnnualMaximum?: string | null | undefined;
  /**
   * Some benefits require additional information to determine
   *
   * @remarks
   * their limit.
   *
   * `Family` or `Individual`: Applicable to HSA benefit.
   *
   * `Joint Filing or Single` or `Married and Filing Separately`: Applicable to Dependent Care FSA benefit.
   */
  limitOption?: LimitOption | null | undefined;
  /**
   * Whether the employee should use a benefit’s "catch up" rate. Only Roth 401k and 401k benefits use this value for employees over 50.
   */
  catchUp?: boolean | undefined;
  /**
   * The amount that the employee is insured for. Note: company contribution cannot be present if coverage amount is set.
   */
  coverageAmount?: string | null | undefined;
  /**
   * The coverage amount as a multiple of the employee’s salary. Only applicable for Group Term Life benefits. Note: cannot be set if coverage amount is also set.
   */
  coverageSalaryMultiplier?: string | undefined;
  /**
   * Whether the employee deduction reduces taxable income or not. Only valid for Group Term Life benefits. Note: when the value is not "unset", coverage amount and coverage salary multiplier are ignored.
   */
  deductionReducesTaxableIncome?:
    | DeductionReducesTaxableIncome
    | null
    | undefined;
  /**
   * The amount to be paid, per pay period, by the company.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  companyContribution?: string | undefined;
  /**
   * Whether the company contribution amount should be treated as a percentage to be deducted from each payroll.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  contributeAsPercentage?: boolean | undefined;
};

export type PostV1EmployeesEmployeeIdEmployeeBenefitsRequest = {
  /**
   * The UUID of the employee
   */
  employeeId: string;
  /**
   * Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
   */
  xGustoAPIVersion?: VersionHeader | undefined;
  requestBody: PostV1EmployeesEmployeeIdEmployeeBenefitsRequestBody;
};

export type PostV1EmployeesEmployeeIdEmployeeBenefitsResponse = {
  /**
   * HTTP response content type for this operation
   */
  contentType: string;
  /**
   * HTTP response status code for this operation
   */
  statusCode: number;
  /**
   * Raw HTTP response; suitable for custom response parsing
   */
  rawResponse: Response;
  /**
   * Example response
   */
  employeeBenefit?: EmployeeBenefit | undefined;
};

/** @internal */
export const PostV1EmployeesEmployeeIdEmployeeBenefitsType$inboundSchema:
  z.ZodNativeEnum<typeof PostV1EmployeesEmployeeIdEmployeeBenefitsType> = z
    .nativeEnum(PostV1EmployeesEmployeeIdEmployeeBenefitsType);

/** @internal */
export const PostV1EmployeesEmployeeIdEmployeeBenefitsType$outboundSchema:
  z.ZodNativeEnum<typeof PostV1EmployeesEmployeeIdEmployeeBenefitsType> =
    PostV1EmployeesEmployeeIdEmployeeBenefitsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostV1EmployeesEmployeeIdEmployeeBenefitsType$ {
  /** @deprecated use `PostV1EmployeesEmployeeIdEmployeeBenefitsType$inboundSchema` instead. */
  export const inboundSchema =
    PostV1EmployeesEmployeeIdEmployeeBenefitsType$inboundSchema;
  /** @deprecated use `PostV1EmployeesEmployeeIdEmployeeBenefitsType$outboundSchema` instead. */
  export const outboundSchema =
    PostV1EmployeesEmployeeIdEmployeeBenefitsType$outboundSchema;
}

/** @internal */
export const Two$inboundSchema: z.ZodType<Two, z.ZodTypeDef, unknown> = z
  .object({
    rate: z.string().optional(),
    threshold: z.string().optional(),
  });

/** @internal */
export type Two$Outbound = {
  rate?: string | undefined;
  threshold?: string | undefined;
};

/** @internal */
export const Two$outboundSchema: z.ZodType<Two$Outbound, z.ZodTypeDef, Two> = z
  .object({
    rate: z.string().optional(),
    threshold: z.string().optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Two$ {
  /** @deprecated use `Two$inboundSchema` instead. */
  export const inboundSchema = Two$inboundSchema;
  /** @deprecated use `Two$outboundSchema` instead. */
  export const outboundSchema = Two$outboundSchema;
  /** @deprecated use `Two$Outbound` instead. */
  export type Outbound = Two$Outbound;
}

export function twoToJSON(two: Two): string {
  return JSON.stringify(Two$outboundSchema.parse(two));
}

export function twoFromJSON(
  jsonString: string,
): SafeParseResult<Two, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two' from JSON`,
  );
}

/** @internal */
export const Value$inboundSchema: z.ZodType<Value, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.array(z.lazy(() => Two$inboundSchema))]);

/** @internal */
export type Value$Outbound = string | Array<Two$Outbound>;

/** @internal */
export const Value$outboundSchema: z.ZodType<
  Value$Outbound,
  z.ZodTypeDef,
  Value
> = z.union([z.string(), z.array(z.lazy(() => Two$outboundSchema))]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Value$ {
  /** @deprecated use `Value$inboundSchema` instead. */
  export const inboundSchema = Value$inboundSchema;
  /** @deprecated use `Value$outboundSchema` instead. */
  export const outboundSchema = Value$outboundSchema;
  /** @deprecated use `Value$Outbound` instead. */
  export type Outbound = Value$Outbound;
}

export function valueToJSON(value: Value): string {
  return JSON.stringify(Value$outboundSchema.parse(value));
}

export function valueFromJSON(
  jsonString: string,
): SafeParseResult<Value, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Value$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Value' from JSON`,
  );
}

/** @internal */
export const Contribution$inboundSchema: z.ZodType<
  Contribution,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: PostV1EmployeesEmployeeIdEmployeeBenefitsType$inboundSchema.optional(),
  value: z.union([z.string(), z.array(z.lazy(() => Two$inboundSchema))])
    .optional(),
});

/** @internal */
export type Contribution$Outbound = {
  type?: string | undefined;
  value?: string | Array<Two$Outbound> | undefined;
};

/** @internal */
export const Contribution$outboundSchema: z.ZodType<
  Contribution$Outbound,
  z.ZodTypeDef,
  Contribution
> = z.object({
  type: PostV1EmployeesEmployeeIdEmployeeBenefitsType$outboundSchema.optional(),
  value: z.union([z.string(), z.array(z.lazy(() => Two$outboundSchema))])
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Contribution$ {
  /** @deprecated use `Contribution$inboundSchema` instead. */
  export const inboundSchema = Contribution$inboundSchema;
  /** @deprecated use `Contribution$outboundSchema` instead. */
  export const outboundSchema = Contribution$outboundSchema;
  /** @deprecated use `Contribution$Outbound` instead. */
  export type Outbound = Contribution$Outbound;
}

export function contributionToJSON(contribution: Contribution): string {
  return JSON.stringify(Contribution$outboundSchema.parse(contribution));
}

export function contributionFromJSON(
  jsonString: string,
): SafeParseResult<Contribution, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Contribution$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Contribution' from JSON`,
  );
}

/** @internal */
export const LimitOption$inboundSchema: z.ZodNativeEnum<typeof LimitOption> = z
  .nativeEnum(LimitOption);

/** @internal */
export const LimitOption$outboundSchema: z.ZodNativeEnum<typeof LimitOption> =
  LimitOption$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LimitOption$ {
  /** @deprecated use `LimitOption$inboundSchema` instead. */
  export const inboundSchema = LimitOption$inboundSchema;
  /** @deprecated use `LimitOption$outboundSchema` instead. */
  export const outboundSchema = LimitOption$outboundSchema;
}

/** @internal */
export const DeductionReducesTaxableIncome$inboundSchema: z.ZodNativeEnum<
  typeof DeductionReducesTaxableIncome
> = z.nativeEnum(DeductionReducesTaxableIncome);

/** @internal */
export const DeductionReducesTaxableIncome$outboundSchema: z.ZodNativeEnum<
  typeof DeductionReducesTaxableIncome
> = DeductionReducesTaxableIncome$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeductionReducesTaxableIncome$ {
  /** @deprecated use `DeductionReducesTaxableIncome$inboundSchema` instead. */
  export const inboundSchema = DeductionReducesTaxableIncome$inboundSchema;
  /** @deprecated use `DeductionReducesTaxableIncome$outboundSchema` instead. */
  export const outboundSchema = DeductionReducesTaxableIncome$outboundSchema;
}

/** @internal */
export const PostV1EmployeesEmployeeIdEmployeeBenefitsRequestBody$inboundSchema:
  z.ZodType<
    PostV1EmployeesEmployeeIdEmployeeBenefitsRequestBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    company_benefit_uuid: z.string(),
    active: z.boolean().default(true),
    employee_deduction: z.string().default("0.00"),
    deduct_as_percentage: z.boolean().default(false),
    employee_deduction_annual_maximum: z.nullable(z.string()).optional(),
    contribution: z.lazy(() => Contribution$inboundSchema).optional(),
    elective: z.boolean().default(false),
    company_contribution_annual_maximum: z.nullable(z.string()).optional(),
    limit_option: z.nullable(LimitOption$inboundSchema).optional(),
    catch_up: z.boolean().default(false),
    coverage_amount: z.nullable(z.string()).optional(),
    coverage_salary_multiplier: z.string().default("0.00"),
    deduction_reduces_taxable_income: z.nullable(
      DeductionReducesTaxableIncome$inboundSchema,
    ).optional(),
    company_contribution: z.string().default("0.00"),
    contribute_as_percentage: z.boolean().default(false),
  }).transform((v) => {
    return remap$(v, {
      "company_benefit_uuid": "companyBenefitUuid",
      "employee_deduction": "employeeDeduction",
      "deduct_as_percentage": "deductAsPercentage",
      "employee_deduction_annual_maximum": "employeeDeductionAnnualMaximum",
      "company_contribution_annual_maximum": "companyContributionAnnualMaximum",
      "limit_option": "limitOption",
      "catch_up": "catchUp",
      "coverage_amount": "coverageAmount",
      "coverage_salary_multiplier": "coverageSalaryMultiplier",
      "deduction_reduces_taxable_income": "deductionReducesTaxableIncome",
      "company_contribution": "companyContribution",
      "contribute_as_percentage": "contributeAsPercentage",
    });
  });

/** @internal */
export type PostV1EmployeesEmployeeIdEmployeeBenefitsRequestBody$Outbound = {
  company_benefit_uuid: string;
  active: boolean;
  employee_deduction: string;
  deduct_as_percentage: boolean;
  employee_deduction_annual_maximum?: string | null | undefined;
  contribution?: Contribution$Outbound | undefined;
  elective: boolean;
  company_contribution_annual_maximum?: string | null | undefined;
  limit_option?: string | null | undefined;
  catch_up: boolean;
  coverage_amount?: string | null | undefined;
  coverage_salary_multiplier: string;
  deduction_reduces_taxable_income?: string | null | undefined;
  company_contribution: string;
  contribute_as_percentage: boolean;
};

/** @internal */
export const PostV1EmployeesEmployeeIdEmployeeBenefitsRequestBody$outboundSchema:
  z.ZodType<
    PostV1EmployeesEmployeeIdEmployeeBenefitsRequestBody$Outbound,
    z.ZodTypeDef,
    PostV1EmployeesEmployeeIdEmployeeBenefitsRequestBody
  > = z.object({
    companyBenefitUuid: z.string(),
    active: z.boolean().default(true),
    employeeDeduction: z.string().default("0.00"),
    deductAsPercentage: z.boolean().default(false),
    employeeDeductionAnnualMaximum: z.nullable(z.string()).optional(),
    contribution: z.lazy(() => Contribution$outboundSchema).optional(),
    elective: z.boolean().default(false),
    companyContributionAnnualMaximum: z.nullable(z.string()).optional(),
    limitOption: z.nullable(LimitOption$outboundSchema).optional(),
    catchUp: z.boolean().default(false),
    coverageAmount: z.nullable(z.string()).optional(),
    coverageSalaryMultiplier: z.string().default("0.00"),
    deductionReducesTaxableIncome: z.nullable(
      DeductionReducesTaxableIncome$outboundSchema,
    ).optional(),
    companyContribution: z.string().default("0.00"),
    contributeAsPercentage: z.boolean().default(false),
  }).transform((v) => {
    return remap$(v, {
      companyBenefitUuid: "company_benefit_uuid",
      employeeDeduction: "employee_deduction",
      deductAsPercentage: "deduct_as_percentage",
      employeeDeductionAnnualMaximum: "employee_deduction_annual_maximum",
      companyContributionAnnualMaximum: "company_contribution_annual_maximum",
      limitOption: "limit_option",
      catchUp: "catch_up",
      coverageAmount: "coverage_amount",
      coverageSalaryMultiplier: "coverage_salary_multiplier",
      deductionReducesTaxableIncome: "deduction_reduces_taxable_income",
      companyContribution: "company_contribution",
      contributeAsPercentage: "contribute_as_percentage",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostV1EmployeesEmployeeIdEmployeeBenefitsRequestBody$ {
  /** @deprecated use `PostV1EmployeesEmployeeIdEmployeeBenefitsRequestBody$inboundSchema` instead. */
  export const inboundSchema =
    PostV1EmployeesEmployeeIdEmployeeBenefitsRequestBody$inboundSchema;
  /** @deprecated use `PostV1EmployeesEmployeeIdEmployeeBenefitsRequestBody$outboundSchema` instead. */
  export const outboundSchema =
    PostV1EmployeesEmployeeIdEmployeeBenefitsRequestBody$outboundSchema;
  /** @deprecated use `PostV1EmployeesEmployeeIdEmployeeBenefitsRequestBody$Outbound` instead. */
  export type Outbound =
    PostV1EmployeesEmployeeIdEmployeeBenefitsRequestBody$Outbound;
}

export function postV1EmployeesEmployeeIdEmployeeBenefitsRequestBodyToJSON(
  postV1EmployeesEmployeeIdEmployeeBenefitsRequestBody:
    PostV1EmployeesEmployeeIdEmployeeBenefitsRequestBody,
): string {
  return JSON.stringify(
    PostV1EmployeesEmployeeIdEmployeeBenefitsRequestBody$outboundSchema.parse(
      postV1EmployeesEmployeeIdEmployeeBenefitsRequestBody,
    ),
  );
}

export function postV1EmployeesEmployeeIdEmployeeBenefitsRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  PostV1EmployeesEmployeeIdEmployeeBenefitsRequestBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostV1EmployeesEmployeeIdEmployeeBenefitsRequestBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostV1EmployeesEmployeeIdEmployeeBenefitsRequestBody' from JSON`,
  );
}

/** @internal */
export const PostV1EmployeesEmployeeIdEmployeeBenefitsRequest$inboundSchema:
  z.ZodType<
    PostV1EmployeesEmployeeIdEmployeeBenefitsRequest,
    z.ZodTypeDef,
    unknown
  > = z.object({
    employee_id: z.string(),
    "X-Gusto-API-Version": VersionHeader$inboundSchema.default("2024-04-01"),
    RequestBody: z.lazy(() =>
      PostV1EmployeesEmployeeIdEmployeeBenefitsRequestBody$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "employee_id": "employeeId",
      "X-Gusto-API-Version": "xGustoAPIVersion",
      "RequestBody": "requestBody",
    });
  });

/** @internal */
export type PostV1EmployeesEmployeeIdEmployeeBenefitsRequest$Outbound = {
  employee_id: string;
  "X-Gusto-API-Version": string;
  RequestBody: PostV1EmployeesEmployeeIdEmployeeBenefitsRequestBody$Outbound;
};

/** @internal */
export const PostV1EmployeesEmployeeIdEmployeeBenefitsRequest$outboundSchema:
  z.ZodType<
    PostV1EmployeesEmployeeIdEmployeeBenefitsRequest$Outbound,
    z.ZodTypeDef,
    PostV1EmployeesEmployeeIdEmployeeBenefitsRequest
  > = z.object({
    employeeId: z.string(),
    xGustoAPIVersion: VersionHeader$outboundSchema.default("2024-04-01"),
    requestBody: z.lazy(() =>
      PostV1EmployeesEmployeeIdEmployeeBenefitsRequestBody$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      employeeId: "employee_id",
      xGustoAPIVersion: "X-Gusto-API-Version",
      requestBody: "RequestBody",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostV1EmployeesEmployeeIdEmployeeBenefitsRequest$ {
  /** @deprecated use `PostV1EmployeesEmployeeIdEmployeeBenefitsRequest$inboundSchema` instead. */
  export const inboundSchema =
    PostV1EmployeesEmployeeIdEmployeeBenefitsRequest$inboundSchema;
  /** @deprecated use `PostV1EmployeesEmployeeIdEmployeeBenefitsRequest$outboundSchema` instead. */
  export const outboundSchema =
    PostV1EmployeesEmployeeIdEmployeeBenefitsRequest$outboundSchema;
  /** @deprecated use `PostV1EmployeesEmployeeIdEmployeeBenefitsRequest$Outbound` instead. */
  export type Outbound =
    PostV1EmployeesEmployeeIdEmployeeBenefitsRequest$Outbound;
}

export function postV1EmployeesEmployeeIdEmployeeBenefitsRequestToJSON(
  postV1EmployeesEmployeeIdEmployeeBenefitsRequest:
    PostV1EmployeesEmployeeIdEmployeeBenefitsRequest,
): string {
  return JSON.stringify(
    PostV1EmployeesEmployeeIdEmployeeBenefitsRequest$outboundSchema.parse(
      postV1EmployeesEmployeeIdEmployeeBenefitsRequest,
    ),
  );
}

export function postV1EmployeesEmployeeIdEmployeeBenefitsRequestFromJSON(
  jsonString: string,
): SafeParseResult<
  PostV1EmployeesEmployeeIdEmployeeBenefitsRequest,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostV1EmployeesEmployeeIdEmployeeBenefitsRequest$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostV1EmployeesEmployeeIdEmployeeBenefitsRequest' from JSON`,
  );
}

/** @internal */
export const PostV1EmployeesEmployeeIdEmployeeBenefitsResponse$inboundSchema:
  z.ZodType<
    PostV1EmployeesEmployeeIdEmployeeBenefitsResponse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    ContentType: z.string(),
    StatusCode: z.number().int(),
    RawResponse: z.instanceof(Response),
    "Employee-Benefit": EmployeeBenefit$inboundSchema.optional(),
  }).transform((v) => {
    return remap$(v, {
      "ContentType": "contentType",
      "StatusCode": "statusCode",
      "RawResponse": "rawResponse",
      "Employee-Benefit": "employeeBenefit",
    });
  });

/** @internal */
export type PostV1EmployeesEmployeeIdEmployeeBenefitsResponse$Outbound = {
  ContentType: string;
  StatusCode: number;
  RawResponse: never;
  "Employee-Benefit"?: EmployeeBenefit$Outbound | undefined;
};

/** @internal */
export const PostV1EmployeesEmployeeIdEmployeeBenefitsResponse$outboundSchema:
  z.ZodType<
    PostV1EmployeesEmployeeIdEmployeeBenefitsResponse$Outbound,
    z.ZodTypeDef,
    PostV1EmployeesEmployeeIdEmployeeBenefitsResponse
  > = z.object({
    contentType: z.string(),
    statusCode: z.number().int(),
    rawResponse: z.instanceof(Response).transform(() => {
      throw new Error("Response cannot be serialized");
    }),
    employeeBenefit: EmployeeBenefit$outboundSchema.optional(),
  }).transform((v) => {
    return remap$(v, {
      contentType: "ContentType",
      statusCode: "StatusCode",
      rawResponse: "RawResponse",
      employeeBenefit: "Employee-Benefit",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostV1EmployeesEmployeeIdEmployeeBenefitsResponse$ {
  /** @deprecated use `PostV1EmployeesEmployeeIdEmployeeBenefitsResponse$inboundSchema` instead. */
  export const inboundSchema =
    PostV1EmployeesEmployeeIdEmployeeBenefitsResponse$inboundSchema;
  /** @deprecated use `PostV1EmployeesEmployeeIdEmployeeBenefitsResponse$outboundSchema` instead. */
  export const outboundSchema =
    PostV1EmployeesEmployeeIdEmployeeBenefitsResponse$outboundSchema;
  /** @deprecated use `PostV1EmployeesEmployeeIdEmployeeBenefitsResponse$Outbound` instead. */
  export type Outbound =
    PostV1EmployeesEmployeeIdEmployeeBenefitsResponse$Outbound;
}

export function postV1EmployeesEmployeeIdEmployeeBenefitsResponseToJSON(
  postV1EmployeesEmployeeIdEmployeeBenefitsResponse:
    PostV1EmployeesEmployeeIdEmployeeBenefitsResponse,
): string {
  return JSON.stringify(
    PostV1EmployeesEmployeeIdEmployeeBenefitsResponse$outboundSchema.parse(
      postV1EmployeesEmployeeIdEmployeeBenefitsResponse,
    ),
  );
}

export function postV1EmployeesEmployeeIdEmployeeBenefitsResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  PostV1EmployeesEmployeeIdEmployeeBenefitsResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostV1EmployeesEmployeeIdEmployeeBenefitsResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostV1EmployeesEmployeeIdEmployeeBenefitsResponse' from JSON`,
  );
}

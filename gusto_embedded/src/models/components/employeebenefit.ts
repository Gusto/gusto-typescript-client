/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * A single tier of a tiered matching scheme.
 */
export type Tiers = {
  /**
   * The percentage of employee deduction within this tier the company contribution will match.
   */
  rate?: string | undefined;
  /**
   * Specifies the upper limit (inclusive) percentage of the employee contribution that this tier applies to.
   *
   * @remarks
   *
   * Use threshold to define each tier's end point, with tiers applied cumulatively from 0% upwards.
   *
   * For example:
   *
   * If the first tier has a threshold of "3", and `rate` of "100", the company will match 100% of employee contributions from 0% up to and including 3% of payroll.
   *
   * If the next tier has a threshold of "5" and a rate of "50", the company will match 50% of contributions from above 3% up to and including 5% of payroll.
   */
  threshold?: string | undefined;
  /**
   * The step up difference between this tier's threshold and the previous tier's threshold. In the first tier, this is equivalent to threshold.
   */
  thresholdDelta?: string | undefined;
};

export type Two = {
  tiers?: Array<Tiers> | undefined;
};

/**
 * For the `amount` and `percentage` contribution types, the value of the corresponding amount or percentage.
 *
 * @remarks
 *
 * For the `tiered` contribution type, an array of tiers.
 */
export type EmployeeBenefitValue = string | Two;

/**
 * An object representing the type and value of the company contribution.
 */
export type Contribution = {
  /**
   * The company contribution scheme.
   *
   * @remarks
   *
   * "amount": The company contributes a fixed amount per payroll. If elective is true, the contribution is matching, dollar-for-dollar.
   *
   * "percentage": The company contributes a percentage of the payroll amount per payroll period. If elective is true, the contribution is matching, dollar-for-dollar.
   *
   * "tiered": The company contribution varies according to the size of the employee deduction.
   */
  type?: string | undefined;
  /**
   * For the `amount` and `percentage` contribution types, the value of the corresponding amount or percentage.
   *
   * @remarks
   *
   * For the `tiered` contribution type, an array of tiers.
   */
  value?: string | Two | undefined;
};

/**
 * Whether the employee deduction reduces taxable income or not. Only valid for Group Term Life benefits. Note: when the value is not "unset", coverage amount and coverage salary multiplier are ignored.
 */
export const DeductionReducesTaxableIncome = {
  Unset: "unset",
  ReducesTaxableIncome: "reduces_taxable_income",
  DoesNotReduceTaxableIncome: "does_not_reduce_taxable_income",
} as const;
/**
 * Whether the employee deduction reduces taxable income or not. Only valid for Group Term Life benefits. Note: when the value is not "unset", coverage amount and coverage salary multiplier are ignored.
 */
export type DeductionReducesTaxableIncome = ClosedEnum<
  typeof DeductionReducesTaxableIncome
>;

/**
 * The representation of an employee benefit.
 */
export type EmployeeBenefit = {
  /**
   * The current version of the object. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
   */
  version?: string | undefined;
  /**
   * Whether the employee benefit is active.
   */
  active?: boolean | undefined;
  /**
   * The amount to be deducted, per pay period, from the employee's pay.
   */
  employeeDeduction?: string | undefined;
  /**
   * Whether the employee deduction amount should be treated as a percentage to be deducted from each payroll.
   */
  deductAsPercentage?: boolean | undefined;
  /**
   * The maximum employee deduction amount per year. A null value signifies no limit.
   */
  employeeDeductionAnnualMaximum?: string | null | undefined;
  /**
   * An object representing the type and value of the company contribution.
   */
  contribution?: Contribution | undefined;
  /**
   * Whether the company contribution is elective (aka matching). For "tiered" contribution types, this is always true.
   */
  elective?: boolean | undefined;
  /**
   * The maximum company contribution amount per year. A null value signifies no limit.
   */
  companyContributionAnnualMaximum?: string | null | undefined;
  /**
   * Some benefits require additional information to determine their limit.
   *
   * @remarks
   *
   * `Family` and `Individual` are applicable to HSA benefit.
   *
   * `Joint Filing or Single` and `Married and Filing Separately` are applicable to Dependent Care FSA benefit.
   */
  limitOption?: string | null | undefined;
  /**
   * Whether the employee should use a benefit's "catch up" rate. Only Roth 401k and 401k benefits use this value for employees over 50.
   */
  catchUp?: boolean | null | undefined;
  /**
   * Identifier for a 401(k) loan assigned by the 401(k) provider
   */
  retirementLoanIdentifier?: string | undefined;
  /**
   * The amount that the employee is insured for. Note: company contribution cannot be present if coverage amount is set.
   */
  coverageAmount?: string | null | undefined;
  /**
   * Whether the employee deduction reduces taxable income or not. Only valid for Group Term Life benefits. Note: when the value is not "unset", coverage amount and coverage salary multiplier are ignored.
   */
  deductionReducesTaxableIncome?:
    | DeductionReducesTaxableIncome
    | null
    | undefined;
  /**
   * The coverage amount as a multiple of the employee's salary. Only applicable for Group Term Life benefits. Note: cannot be set if coverage amount is also set.
   */
  coverageSalaryMultiplier?: string | null | undefined;
  /**
   * The amount to be paid, per pay period, by the company. This field will not appear for tiered contribution types.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  companyContribution?: string | undefined;
  /**
   * Whether the company_contribution value should be treated as a percentage to be added to each payroll. This field will not appear for tiered contribution types.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  contributeAsPercentage?: boolean | undefined;
  /**
   * The UUID of the employee to which the benefit belongs.
   */
  employeeUuid?: string | undefined;
  /**
   * The UUID of the company benefit.
   */
  companyBenefitUuid?: string | undefined;
  /**
   * The UUID of the employee benefit.
   */
  uuid: string;
};

/** @internal */
export const Tiers$inboundSchema: z.ZodType<Tiers, z.ZodTypeDef, unknown> = z
  .object({
    rate: z.string().optional(),
    threshold: z.string().optional(),
    threshold_delta: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "threshold_delta": "thresholdDelta",
    });
  });

/** @internal */
export type Tiers$Outbound = {
  rate?: string | undefined;
  threshold?: string | undefined;
  threshold_delta?: string | undefined;
};

/** @internal */
export const Tiers$outboundSchema: z.ZodType<
  Tiers$Outbound,
  z.ZodTypeDef,
  Tiers
> = z.object({
  rate: z.string().optional(),
  threshold: z.string().optional(),
  thresholdDelta: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    thresholdDelta: "threshold_delta",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Tiers$ {
  /** @deprecated use `Tiers$inboundSchema` instead. */
  export const inboundSchema = Tiers$inboundSchema;
  /** @deprecated use `Tiers$outboundSchema` instead. */
  export const outboundSchema = Tiers$outboundSchema;
  /** @deprecated use `Tiers$Outbound` instead. */
  export type Outbound = Tiers$Outbound;
}

export function tiersToJSON(tiers: Tiers): string {
  return JSON.stringify(Tiers$outboundSchema.parse(tiers));
}

export function tiersFromJSON(
  jsonString: string,
): SafeParseResult<Tiers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Tiers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Tiers' from JSON`,
  );
}

/** @internal */
export const Two$inboundSchema: z.ZodType<Two, z.ZodTypeDef, unknown> = z
  .object({
    tiers: z.array(z.lazy(() => Tiers$inboundSchema)).optional(),
  });

/** @internal */
export type Two$Outbound = {
  tiers?: Array<Tiers$Outbound> | undefined;
};

/** @internal */
export const Two$outboundSchema: z.ZodType<Two$Outbound, z.ZodTypeDef, Two> = z
  .object({
    tiers: z.array(z.lazy(() => Tiers$outboundSchema)).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Two$ {
  /** @deprecated use `Two$inboundSchema` instead. */
  export const inboundSchema = Two$inboundSchema;
  /** @deprecated use `Two$outboundSchema` instead. */
  export const outboundSchema = Two$outboundSchema;
  /** @deprecated use `Two$Outbound` instead. */
  export type Outbound = Two$Outbound;
}

export function twoToJSON(two: Two): string {
  return JSON.stringify(Two$outboundSchema.parse(two));
}

export function twoFromJSON(
  jsonString: string,
): SafeParseResult<Two, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two' from JSON`,
  );
}

/** @internal */
export const EmployeeBenefitValue$inboundSchema: z.ZodType<
  EmployeeBenefitValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.lazy(() => Two$inboundSchema)]);

/** @internal */
export type EmployeeBenefitValue$Outbound = string | Two$Outbound;

/** @internal */
export const EmployeeBenefitValue$outboundSchema: z.ZodType<
  EmployeeBenefitValue$Outbound,
  z.ZodTypeDef,
  EmployeeBenefitValue
> = z.union([z.string(), z.lazy(() => Two$outboundSchema)]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EmployeeBenefitValue$ {
  /** @deprecated use `EmployeeBenefitValue$inboundSchema` instead. */
  export const inboundSchema = EmployeeBenefitValue$inboundSchema;
  /** @deprecated use `EmployeeBenefitValue$outboundSchema` instead. */
  export const outboundSchema = EmployeeBenefitValue$outboundSchema;
  /** @deprecated use `EmployeeBenefitValue$Outbound` instead. */
  export type Outbound = EmployeeBenefitValue$Outbound;
}

export function employeeBenefitValueToJSON(
  employeeBenefitValue: EmployeeBenefitValue,
): string {
  return JSON.stringify(
    EmployeeBenefitValue$outboundSchema.parse(employeeBenefitValue),
  );
}

export function employeeBenefitValueFromJSON(
  jsonString: string,
): SafeParseResult<EmployeeBenefitValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmployeeBenefitValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmployeeBenefitValue' from JSON`,
  );
}

/** @internal */
export const Contribution$inboundSchema: z.ZodType<
  Contribution,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.string().optional(),
  value: z.union([z.string(), z.lazy(() => Two$inboundSchema)]).optional(),
});

/** @internal */
export type Contribution$Outbound = {
  type?: string | undefined;
  value?: string | Two$Outbound | undefined;
};

/** @internal */
export const Contribution$outboundSchema: z.ZodType<
  Contribution$Outbound,
  z.ZodTypeDef,
  Contribution
> = z.object({
  type: z.string().optional(),
  value: z.union([z.string(), z.lazy(() => Two$outboundSchema)]).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Contribution$ {
  /** @deprecated use `Contribution$inboundSchema` instead. */
  export const inboundSchema = Contribution$inboundSchema;
  /** @deprecated use `Contribution$outboundSchema` instead. */
  export const outboundSchema = Contribution$outboundSchema;
  /** @deprecated use `Contribution$Outbound` instead. */
  export type Outbound = Contribution$Outbound;
}

export function contributionToJSON(contribution: Contribution): string {
  return JSON.stringify(Contribution$outboundSchema.parse(contribution));
}

export function contributionFromJSON(
  jsonString: string,
): SafeParseResult<Contribution, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Contribution$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Contribution' from JSON`,
  );
}

/** @internal */
export const DeductionReducesTaxableIncome$inboundSchema: z.ZodNativeEnum<
  typeof DeductionReducesTaxableIncome
> = z.nativeEnum(DeductionReducesTaxableIncome);

/** @internal */
export const DeductionReducesTaxableIncome$outboundSchema: z.ZodNativeEnum<
  typeof DeductionReducesTaxableIncome
> = DeductionReducesTaxableIncome$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeductionReducesTaxableIncome$ {
  /** @deprecated use `DeductionReducesTaxableIncome$inboundSchema` instead. */
  export const inboundSchema = DeductionReducesTaxableIncome$inboundSchema;
  /** @deprecated use `DeductionReducesTaxableIncome$outboundSchema` instead. */
  export const outboundSchema = DeductionReducesTaxableIncome$outboundSchema;
}

/** @internal */
export const EmployeeBenefit$inboundSchema: z.ZodType<
  EmployeeBenefit,
  z.ZodTypeDef,
  unknown
> = z.object({
  version: z.string().optional(),
  active: z.boolean().default(true),
  employee_deduction: z.string().default("0.00"),
  deduct_as_percentage: z.boolean().default(false),
  employee_deduction_annual_maximum: z.nullable(z.string()).optional(),
  contribution: z.lazy(() => Contribution$inboundSchema).optional(),
  elective: z.boolean().default(false),
  company_contribution_annual_maximum: z.nullable(z.string()).optional(),
  limit_option: z.nullable(z.string()).optional(),
  catch_up: z.nullable(z.boolean().default(false)),
  retirement_loan_identifier: z.string().optional(),
  coverage_amount: z.nullable(z.string()).optional(),
  deduction_reduces_taxable_income: z.nullable(
    DeductionReducesTaxableIncome$inboundSchema.default("unset"),
  ),
  coverage_salary_multiplier: z.nullable(z.string().default("0.00")),
  company_contribution: z.string().default("0.00"),
  contribute_as_percentage: z.boolean().default(false),
  employee_uuid: z.string().optional(),
  company_benefit_uuid: z.string().optional(),
  uuid: z.string(),
}).transform((v) => {
  return remap$(v, {
    "employee_deduction": "employeeDeduction",
    "deduct_as_percentage": "deductAsPercentage",
    "employee_deduction_annual_maximum": "employeeDeductionAnnualMaximum",
    "company_contribution_annual_maximum": "companyContributionAnnualMaximum",
    "limit_option": "limitOption",
    "catch_up": "catchUp",
    "retirement_loan_identifier": "retirementLoanIdentifier",
    "coverage_amount": "coverageAmount",
    "deduction_reduces_taxable_income": "deductionReducesTaxableIncome",
    "coverage_salary_multiplier": "coverageSalaryMultiplier",
    "company_contribution": "companyContribution",
    "contribute_as_percentage": "contributeAsPercentage",
    "employee_uuid": "employeeUuid",
    "company_benefit_uuid": "companyBenefitUuid",
  });
});

/** @internal */
export type EmployeeBenefit$Outbound = {
  version?: string | undefined;
  active: boolean;
  employee_deduction: string;
  deduct_as_percentage: boolean;
  employee_deduction_annual_maximum?: string | null | undefined;
  contribution?: Contribution$Outbound | undefined;
  elective: boolean;
  company_contribution_annual_maximum?: string | null | undefined;
  limit_option?: string | null | undefined;
  catch_up: boolean | null;
  retirement_loan_identifier?: string | undefined;
  coverage_amount?: string | null | undefined;
  deduction_reduces_taxable_income: string | null;
  coverage_salary_multiplier: string | null;
  company_contribution: string;
  contribute_as_percentage: boolean;
  employee_uuid?: string | undefined;
  company_benefit_uuid?: string | undefined;
  uuid: string;
};

/** @internal */
export const EmployeeBenefit$outboundSchema: z.ZodType<
  EmployeeBenefit$Outbound,
  z.ZodTypeDef,
  EmployeeBenefit
> = z.object({
  version: z.string().optional(),
  active: z.boolean().default(true),
  employeeDeduction: z.string().default("0.00"),
  deductAsPercentage: z.boolean().default(false),
  employeeDeductionAnnualMaximum: z.nullable(z.string()).optional(),
  contribution: z.lazy(() => Contribution$outboundSchema).optional(),
  elective: z.boolean().default(false),
  companyContributionAnnualMaximum: z.nullable(z.string()).optional(),
  limitOption: z.nullable(z.string()).optional(),
  catchUp: z.nullable(z.boolean().default(false)),
  retirementLoanIdentifier: z.string().optional(),
  coverageAmount: z.nullable(z.string()).optional(),
  deductionReducesTaxableIncome: z.nullable(
    DeductionReducesTaxableIncome$outboundSchema.default("unset"),
  ),
  coverageSalaryMultiplier: z.nullable(z.string().default("0.00")),
  companyContribution: z.string().default("0.00"),
  contributeAsPercentage: z.boolean().default(false),
  employeeUuid: z.string().optional(),
  companyBenefitUuid: z.string().optional(),
  uuid: z.string(),
}).transform((v) => {
  return remap$(v, {
    employeeDeduction: "employee_deduction",
    deductAsPercentage: "deduct_as_percentage",
    employeeDeductionAnnualMaximum: "employee_deduction_annual_maximum",
    companyContributionAnnualMaximum: "company_contribution_annual_maximum",
    limitOption: "limit_option",
    catchUp: "catch_up",
    retirementLoanIdentifier: "retirement_loan_identifier",
    coverageAmount: "coverage_amount",
    deductionReducesTaxableIncome: "deduction_reduces_taxable_income",
    coverageSalaryMultiplier: "coverage_salary_multiplier",
    companyContribution: "company_contribution",
    contributeAsPercentage: "contribute_as_percentage",
    employeeUuid: "employee_uuid",
    companyBenefitUuid: "company_benefit_uuid",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EmployeeBenefit$ {
  /** @deprecated use `EmployeeBenefit$inboundSchema` instead. */
  export const inboundSchema = EmployeeBenefit$inboundSchema;
  /** @deprecated use `EmployeeBenefit$outboundSchema` instead. */
  export const outboundSchema = EmployeeBenefit$outboundSchema;
  /** @deprecated use `EmployeeBenefit$Outbound` instead. */
  export type Outbound = EmployeeBenefit$Outbound;
}

export function employeeBenefitToJSON(
  employeeBenefit: EmployeeBenefit,
): string {
  return JSON.stringify(EmployeeBenefit$outboundSchema.parse(employeeBenefit));
}

export function employeeBenefitFromJSON(
  jsonString: string,
): SafeParseResult<EmployeeBenefit, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmployeeBenefit$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmployeeBenefit' from JSON`,
  );
}

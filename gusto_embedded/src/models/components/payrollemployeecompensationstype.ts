/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The employee's compensation payment method. Is *only* `Historical` when retrieving external payrolls initially run outside of Gusto, then put into Gusto.
 */
export const PayrollEmployeeCompensationsTypePaymentMethod = {
  DirectDeposit: "Direct Deposit",
  Check: "Check",
  Historical: "Historical",
} as const;
/**
 * The employee's compensation payment method. Is *only* `Historical` when retrieving external payrolls initially run outside of Gusto, then put into Gusto.
 */
export type PayrollEmployeeCompensationsTypePaymentMethod = ClosedEnum<
  typeof PayrollEmployeeCompensationsTypePaymentMethod
>;

export type FixedCompensations = {
  /**
   * The name of the compensation. This also serves as the unique, immutable identifier for this compensation.
   */
  name?: string | undefined;
  /**
   * The amount of the compensation for the pay period.
   */
  amount?: string | undefined;
  /**
   * The UUID of the job for the compensation.
   */
  jobUuid?: string | undefined;
};

export type HourlyCompensations = {
  /**
   * The name of the compensation. This also serves as the unique, immutable identifier for this compensation.
   */
  name?: string | undefined;
  /**
   * The number of hours to be compensated for this pay period.
   */
  hours?: string | undefined;
  /**
   * The amount of the compensation. This field is only available after the payroll is calculated and cannot be used for updating hourly compensations.
   */
  amount?: string | undefined;
  /**
   * The UUID of the job for the compensation.
   */
  jobUuid?: string | undefined;
  /**
   * The amount multiplied by the base rate to calculate total compensation per hour worked.
   */
  compensationMultiplier?: number | undefined;
  /**
   * The FLSA Status of the employee's primary job compensation
   */
  flsaStatus?: string | undefined;
};

export type PayrollEmployeeCompensationsTypePaidTimeOff = {
  /**
   * The name of the PTO. This also serves as the unique, immutable identifier for the PTO.
   */
  name?: string | undefined;
  /**
   * The hours of this PTO taken during the pay period.
   */
  hours?: string | undefined;
  /**
   * The outstanding hours paid upon termination. This field is only applicable for termination payrolls.
   */
  finalPayoutUnusedHoursInput?: string | undefined;
};

/**
 * The amount type of the deduction for the pay period.
 */
export const AmountType = {
  Fixed: "fixed",
  Percent: "percent",
} as const;
/**
 * The amount type of the deduction for the pay period.
 */
export type AmountType = ClosedEnum<typeof AmountType>;

/**
 * An array of deductions for the employee.
 */
export type Deductions = {
  /**
   * The name of the deduction.
   */
  name?: string | undefined;
  /**
   * The amount of the deduction for the pay period.
   */
  amount?: number | undefined;
  /**
   * The amount type of the deduction for the pay period.
   */
  amountType?: AmountType | undefined;
  /**
   * The UUID of the deduction. This parameter is optional and can be provided in order to update an existing deduction.
   */
  uuid?: string | undefined;
};

export type Reimbursements = {
  /**
   * The dollar amount of the reimbursement for the pay period.
   */
  amount: string;
  /**
   * The description of the reimbursement. Null for unnamed reimbursements.
   */
  description: string | null;
  /**
   * The UUID of the reimbursement. Null for unnamed reimbursements. This field is only available for unprocessed payrolls.
   */
  uuid?: string | null | undefined;
  /**
   * Whether the reimbursement is recurring. This field is only available for unprocessed payrolls.
   */
  recurring?: boolean | undefined;
};

export type PayrollEmployeeCompensationsType = {
  /**
   * The UUID of the employee.
   */
  employeeUuid?: string | undefined;
  /**
   * This employee will be excluded (skipped) from payroll calculation and will not be paid for the payroll. Cancelling a payroll would reset all employees' excluded back to false.
   */
  excluded?: boolean | undefined;
  /**
   * The current version of this employee compensation. This field is only available for prepared payrolls. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
   */
  version?: string | undefined;
  /**
   * The first name of the employee. Requires `employees:read` scope.
   */
  firstName?: string | null | undefined;
  /**
   * The preferred first name of the employee. Requires `employees:read` scope.
   */
  preferredFirstName?: string | null | undefined;
  /**
   * The last name of the employee. Requires `employees:read` scope.
   */
  lastName?: string | null | undefined;
  /**
   * The employee's gross pay, equal to regular wages + cash tips + payroll tips + any other additional earnings, excluding imputed income. This value is only available for processed payrolls.
   */
  grossPay?: number | null | undefined;
  /**
   * The employee's net pay, equal to gross_pay - employee taxes - employee deductions or garnishments - cash tips. This value is only available for processed payrolls.
   */
  netPay?: number | null | undefined;
  /**
   * The employee's check amount, equal to net_pay + reimbursements. This value is only available for processed payrolls.
   */
  checkAmount?: number | null | undefined;
  /**
   * The employee's compensation payment method. Is *only* `Historical` when retrieving external payrolls initially run outside of Gusto, then put into Gusto.
   */
  paymentMethod?:
    | PayrollEmployeeCompensationsTypePaymentMethod
    | null
    | undefined;
  /**
   * Custom text that will be printed as a personal note to the employee on a paystub.
   */
  memo?: string | null | undefined;
  /**
   * An array of fixed compensations for the employee. Fixed compensations include tips, bonuses, and one time reimbursements. If this payroll has been processed, only fixed compensations with a value greater than 0.00 are returned. For an unprocessed payroll, all active fixed compensations are returned.
   */
  fixedCompensations?: Array<FixedCompensations> | undefined;
  /**
   * An array of hourly compensations for the employee. Hourly compensations include regular, overtime, and double overtime hours. If this payroll has been processed, only hourly compensations with a value greater than 0.00 are returned. For an unprocessed payroll, all active hourly compensations are returned.
   */
  hourlyCompensations?: Array<HourlyCompensations> | undefined;
  /**
   * An array of all paid time off the employee is eligible for this pay period.
   */
  paidTimeOff?: Array<PayrollEmployeeCompensationsTypePaidTimeOff> | undefined;
  deductions?: Array<Deductions> | undefined;
  /**
   * An array of reimbursements for the employee.
   */
  reimbursements?: Array<Reimbursements> | undefined;
};

/** @internal */
export const PayrollEmployeeCompensationsTypePaymentMethod$inboundSchema:
  z.ZodNativeEnum<typeof PayrollEmployeeCompensationsTypePaymentMethod> = z
    .nativeEnum(PayrollEmployeeCompensationsTypePaymentMethod);

/** @internal */
export const FixedCompensations$inboundSchema: z.ZodType<
  FixedCompensations,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  amount: z.string().optional(),
  job_uuid: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "job_uuid": "jobUuid",
  });
});

export function fixedCompensationsFromJSON(
  jsonString: string,
): SafeParseResult<FixedCompensations, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FixedCompensations$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FixedCompensations' from JSON`,
  );
}

/** @internal */
export const HourlyCompensations$inboundSchema: z.ZodType<
  HourlyCompensations,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  hours: z.string().optional(),
  amount: z.string().optional(),
  job_uuid: z.string().optional(),
  compensation_multiplier: z.number().optional(),
  flsa_status: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "job_uuid": "jobUuid",
    "compensation_multiplier": "compensationMultiplier",
    "flsa_status": "flsaStatus",
  });
});

export function hourlyCompensationsFromJSON(
  jsonString: string,
): SafeParseResult<HourlyCompensations, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HourlyCompensations$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HourlyCompensations' from JSON`,
  );
}

/** @internal */
export const PayrollEmployeeCompensationsTypePaidTimeOff$inboundSchema:
  z.ZodType<
    PayrollEmployeeCompensationsTypePaidTimeOff,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string().optional(),
    hours: z.string().optional(),
    final_payout_unused_hours_input: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "final_payout_unused_hours_input": "finalPayoutUnusedHoursInput",
    });
  });

export function payrollEmployeeCompensationsTypePaidTimeOffFromJSON(
  jsonString: string,
): SafeParseResult<
  PayrollEmployeeCompensationsTypePaidTimeOff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PayrollEmployeeCompensationsTypePaidTimeOff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PayrollEmployeeCompensationsTypePaidTimeOff' from JSON`,
  );
}

/** @internal */
export const AmountType$inboundSchema: z.ZodNativeEnum<typeof AmountType> = z
  .nativeEnum(AmountType);

/** @internal */
export const Deductions$inboundSchema: z.ZodType<
  Deductions,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  amount: z.number().optional(),
  amount_type: AmountType$inboundSchema.optional(),
  uuid: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "amount_type": "amountType",
  });
});

export function deductionsFromJSON(
  jsonString: string,
): SafeParseResult<Deductions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Deductions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Deductions' from JSON`,
  );
}

/** @internal */
export const Reimbursements$inboundSchema: z.ZodType<
  Reimbursements,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.string(),
  description: z.nullable(z.string()),
  uuid: z.nullable(z.string()).optional(),
  recurring: z.boolean().optional(),
});

export function reimbursementsFromJSON(
  jsonString: string,
): SafeParseResult<Reimbursements, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Reimbursements$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Reimbursements' from JSON`,
  );
}

/** @internal */
export const PayrollEmployeeCompensationsType$inboundSchema: z.ZodType<
  PayrollEmployeeCompensationsType,
  z.ZodTypeDef,
  unknown
> = z.object({
  employee_uuid: z.string().optional(),
  excluded: z.boolean().optional(),
  version: z.string().optional(),
  first_name: z.nullable(z.string()).optional(),
  preferred_first_name: z.nullable(z.string()).optional(),
  last_name: z.nullable(z.string()).optional(),
  gross_pay: z.nullable(z.number()).optional(),
  net_pay: z.nullable(z.number()).optional(),
  check_amount: z.nullable(z.number()).optional(),
  payment_method: z.nullable(
    PayrollEmployeeCompensationsTypePaymentMethod$inboundSchema,
  ).optional(),
  memo: z.nullable(z.string()).optional(),
  fixed_compensations: z.array(z.lazy(() => FixedCompensations$inboundSchema))
    .optional(),
  hourly_compensations: z.array(z.lazy(() => HourlyCompensations$inboundSchema))
    .optional(),
  paid_time_off: z.array(
    z.lazy(() => PayrollEmployeeCompensationsTypePaidTimeOff$inboundSchema),
  ).optional(),
  deductions: z.array(z.lazy(() => Deductions$inboundSchema)).optional(),
  reimbursements: z.array(z.lazy(() => Reimbursements$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "employee_uuid": "employeeUuid",
    "first_name": "firstName",
    "preferred_first_name": "preferredFirstName",
    "last_name": "lastName",
    "gross_pay": "grossPay",
    "net_pay": "netPay",
    "check_amount": "checkAmount",
    "payment_method": "paymentMethod",
    "fixed_compensations": "fixedCompensations",
    "hourly_compensations": "hourlyCompensations",
    "paid_time_off": "paidTimeOff",
  });
});

export function payrollEmployeeCompensationsTypeFromJSON(
  jsonString: string,
): SafeParseResult<PayrollEmployeeCompensationsType, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayrollEmployeeCompensationsType$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayrollEmployeeCompensationsType' from JSON`,
  );
}

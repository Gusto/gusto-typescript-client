/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Represents the notification's status as managed by our system. It is updated based on observable system events and internal business logic, and does not reflect resolution steps taken outside our system. This field is read-only and cannot be modified via the API.
 */
export const NotificationStatus = {
  Open: "open",
  Resolved: "resolved",
  Expired: "expired",
} as const;
/**
 * Represents the notification's status as managed by our system. It is updated based on observable system events and internal business logic, and does not reflect resolution steps taken outside our system. This field is read-only and cannot be modified via the API.
 */
export type NotificationStatus = ClosedEnum<typeof NotificationStatus>;

export type Resources = {
  /**
   * The type of entity being described, could be “Contractor”, “Employee”, “BankAccount”, “Payroll”, “ContractorPayment”, “RecoveryCase”, or “Signatory”
   */
  entityType: string;
  /**
   * Unique identifier of the entity
   */
  entityUuid: string;
  /**
   * Optional. The type of a resource that is related to the one described by entity_type and entity_uuid. For instance, if the entity_type is “BankAccount”, the reference_type could be the “Employee” or “Contractor” to whom the bank account belongs.
   */
  referenceType?: string | undefined;
  /**
   * Optional. Unique identifier of the reference.
   */
  referenceUuid?: string | undefined;
};

/**
 * Example response
 */
export type Notification = {
  /**
   * Unique identifier of a notification.
   */
  uuid: string;
  /**
   * Unique identifier of the company to which the notification belongs.
   */
  companyUuid: string;
  /**
   * The title of the notification. This highlights the actionable component of the notification.
   */
  title: string;
  /**
   * The message of the notification. This provides additional context for the user and recommends a specific action to resolve the notification.
   */
  message: string;
  /**
   * Represents the notification's status as managed by our system. It is updated based on observable system events and internal business logic, and does not reflect resolution steps taken outside our system. This field is read-only and cannot be modified via the API.
   */
  status: NotificationStatus;
  /**
   * The notification's category.
   */
  category: string;
  /**
   * Indicates whether a notification requires action or not. If false, the notification provides critical information only.
   */
  actionable: boolean;
  /**
   * Indicates whether a notification may block ability to run payroll. If true, we suggest that these notifications are prioritized to your end users.
   */
  canBlockPayroll: boolean;
  /**
   * Timestamp of when the notification was published.
   */
  publishedAt: string;
  /**
   * Timestamp of when the notification is due. If the notification has no due date, this field will be null.
   */
  dueAt: string | null;
  /**
   * An object containing template variables used to render the notification. The structure of this object depends on the notification category. Each category defines a fixed set of variable names (keys), which are always present. The values of these variables can vary depending on the specific notification instance.
   */
  templateVariables?: { [k: string]: string } | undefined;
  /**
   * An array of entities relevant to the notification
   */
  resources: Array<Resources>;
};

/** @internal */
export const NotificationStatus$inboundSchema: z.ZodNativeEnum<
  typeof NotificationStatus
> = z.nativeEnum(NotificationStatus);

/** @internal */
export const NotificationStatus$outboundSchema: z.ZodNativeEnum<
  typeof NotificationStatus
> = NotificationStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace NotificationStatus$ {
  /** @deprecated use `NotificationStatus$inboundSchema` instead. */
  export const inboundSchema = NotificationStatus$inboundSchema;
  /** @deprecated use `NotificationStatus$outboundSchema` instead. */
  export const outboundSchema = NotificationStatus$outboundSchema;
}

/** @internal */
export const Resources$inboundSchema: z.ZodType<
  Resources,
  z.ZodTypeDef,
  unknown
> = z.object({
  entity_type: z.string(),
  entity_uuid: z.string(),
  reference_type: z.string().optional(),
  reference_uuid: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "entity_type": "entityType",
    "entity_uuid": "entityUuid",
    "reference_type": "referenceType",
    "reference_uuid": "referenceUuid",
  });
});

/** @internal */
export type Resources$Outbound = {
  entity_type: string;
  entity_uuid: string;
  reference_type?: string | undefined;
  reference_uuid?: string | undefined;
};

/** @internal */
export const Resources$outboundSchema: z.ZodType<
  Resources$Outbound,
  z.ZodTypeDef,
  Resources
> = z.object({
  entityType: z.string(),
  entityUuid: z.string(),
  referenceType: z.string().optional(),
  referenceUuid: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    entityType: "entity_type",
    entityUuid: "entity_uuid",
    referenceType: "reference_type",
    referenceUuid: "reference_uuid",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Resources$ {
  /** @deprecated use `Resources$inboundSchema` instead. */
  export const inboundSchema = Resources$inboundSchema;
  /** @deprecated use `Resources$outboundSchema` instead. */
  export const outboundSchema = Resources$outboundSchema;
  /** @deprecated use `Resources$Outbound` instead. */
  export type Outbound = Resources$Outbound;
}

export function resourcesToJSON(resources: Resources): string {
  return JSON.stringify(Resources$outboundSchema.parse(resources));
}

export function resourcesFromJSON(
  jsonString: string,
): SafeParseResult<Resources, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Resources$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Resources' from JSON`,
  );
}

/** @internal */
export const Notification$inboundSchema: z.ZodType<
  Notification,
  z.ZodTypeDef,
  unknown
> = z.object({
  uuid: z.string(),
  company_uuid: z.string(),
  title: z.string(),
  message: z.string(),
  status: NotificationStatus$inboundSchema,
  category: z.string(),
  actionable: z.boolean(),
  can_block_payroll: z.boolean(),
  published_at: z.string(),
  due_at: z.nullable(z.string()),
  template_variables: z.record(z.string()).optional(),
  resources: z.array(z.lazy(() => Resources$inboundSchema)),
}).transform((v) => {
  return remap$(v, {
    "company_uuid": "companyUuid",
    "can_block_payroll": "canBlockPayroll",
    "published_at": "publishedAt",
    "due_at": "dueAt",
    "template_variables": "templateVariables",
  });
});

/** @internal */
export type Notification$Outbound = {
  uuid: string;
  company_uuid: string;
  title: string;
  message: string;
  status: string;
  category: string;
  actionable: boolean;
  can_block_payroll: boolean;
  published_at: string;
  due_at: string | null;
  template_variables?: { [k: string]: string } | undefined;
  resources: Array<Resources$Outbound>;
};

/** @internal */
export const Notification$outboundSchema: z.ZodType<
  Notification$Outbound,
  z.ZodTypeDef,
  Notification
> = z.object({
  uuid: z.string(),
  companyUuid: z.string(),
  title: z.string(),
  message: z.string(),
  status: NotificationStatus$outboundSchema,
  category: z.string(),
  actionable: z.boolean(),
  canBlockPayroll: z.boolean(),
  publishedAt: z.string(),
  dueAt: z.nullable(z.string()),
  templateVariables: z.record(z.string()).optional(),
  resources: z.array(z.lazy(() => Resources$outboundSchema)),
}).transform((v) => {
  return remap$(v, {
    companyUuid: "company_uuid",
    canBlockPayroll: "can_block_payroll",
    publishedAt: "published_at",
    dueAt: "due_at",
    templateVariables: "template_variables",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Notification$ {
  /** @deprecated use `Notification$inboundSchema` instead. */
  export const inboundSchema = Notification$inboundSchema;
  /** @deprecated use `Notification$outboundSchema` instead. */
  export const outboundSchema = Notification$outboundSchema;
  /** @deprecated use `Notification$Outbound` instead. */
  export type Outbound = Notification$Outbound;
}

export function notificationToJSON(notification: Notification): string {
  return JSON.stringify(Notification$outboundSchema.parse(notification));
}

export function notificationFromJSON(
  jsonString: string,
): SafeParseResult<Notification, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Notification$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Notification' from JSON`,
  );
}

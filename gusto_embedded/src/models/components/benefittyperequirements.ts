/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type DefaultValue = {
  value?: string | undefined;
  type?: string | undefined;
};

/**
 * The amount to be deducted, per pay period, from the employee's pay.
 */
export type EmployeeDeduction = {
  required?: boolean | undefined;
  editable?: boolean | undefined;
  defaultValue?: DefaultValue | undefined;
  choices?: Array<string> | undefined;
};

export type BenefitTypeRequirementsDefaultValue = {
  value?: string | undefined;
  type?: string | undefined;
};

/**
 * An object representing the type and value of the company contribution.
 */
export type BenefitTypeRequirementsContribution = {
  required?: boolean | undefined;
  editable?: boolean | undefined;
  defaultValue?: BenefitTypeRequirementsDefaultValue | undefined;
  choices?: Array<string> | undefined;
};

export type BenefitTypeRequirementsDeductAsPercentageDefaultValue = {
  value?: string | undefined;
  type?: string | undefined;
};

/**
 * Whether the employee deduction amount should be treated as a percentage to be deducted from each payroll.
 */
export type DeductAsPercentage = {
  required?: boolean | undefined;
  editable?: boolean | undefined;
  defaultValue?:
    | BenefitTypeRequirementsDeductAsPercentageDefaultValue
    | undefined;
  choices?: Array<string> | undefined;
};

export type BenefitTypeRequirementsCatchUpDefaultValue = {
  value?: string | undefined;
  type?: string | undefined;
};

/**
 * Whether the employee should use a benefit’s 'catch up' rate. Only Roth 401k and 401k benefits use this value for employees over 50.
 */
export type CatchUp = {
  required?: boolean | undefined;
  editable?: boolean | undefined;
  defaultValue?: BenefitTypeRequirementsCatchUpDefaultValue | undefined;
  choices?: Array<string> | undefined;
};

export type BenefitTypeRequirementsLimitOptionDefaultValue = {
  value?: string | undefined;
  type?: string | undefined;
};

/**
 * Some benefits require additional information to determine their limit. For example, for an HSA benefit, the limit option should be either 'Family' or 'Individual'. For a Dependent Care FSA benefit, the limit option should be either 'Joint Filing or Single' or 'Married and Filing Separately'.
 */
export type LimitOption = {
  required?: boolean | undefined;
  editable?: boolean | undefined;
  defaultValue?: BenefitTypeRequirementsLimitOptionDefaultValue | undefined;
  choices?: Array<string> | undefined;
};

export type BenefitTypeRequirementsCompanyContributionAnnualMaximumDefaultValue =
  {
    value?: string | undefined;
    type?: string | undefined;
  };

/**
 * The maximum company contribution amount per year. A null value signifies no limit.
 */
export type CompanyContributionAnnualMaximum = {
  required?: boolean | undefined;
  editable?: boolean | undefined;
  defaultValue?:
    | BenefitTypeRequirementsCompanyContributionAnnualMaximumDefaultValue
    | undefined;
  choices?: Array<string> | undefined;
};

export type BenefitTypeRequirementsCoverageSalaryMultiplierDefaultValue = {
  value?: string | undefined;
  type?: string | undefined;
};

/**
 * The coverage amount as a multiple of the employee's salary. Only applicable for Group Term Life benefits. Note: cannot be set if coverage amount is also set.
 */
export type CoverageSalaryMultiplier = {
  required?: boolean | undefined;
  editable?: boolean | undefined;
  defaultValue?:
    | BenefitTypeRequirementsCoverageSalaryMultiplierDefaultValue
    | undefined;
  choices?: Array<string> | undefined;
};

export type BenefitTypeRequirementsCoverageAmountDefaultValue = {
  value?: string | undefined;
  type?: string | undefined;
};

/**
 * The amount that the employee is insured for. Note: company contribution cannot be present if coverage amount is set.
 */
export type CoverageAmount = {
  required?: boolean | undefined;
  editable?: boolean | undefined;
  defaultValue?: BenefitTypeRequirementsCoverageAmountDefaultValue | undefined;
  choices?: Array<string> | undefined;
};

/**
 * Benefit type requirements response
 */
export type BenefitTypeRequirements = {
  /**
   * The amount to be deducted, per pay period, from the employee's pay.
   */
  employeeDeduction?: EmployeeDeduction | undefined;
  /**
   * An object representing the type and value of the company contribution.
   */
  contribution?: BenefitTypeRequirementsContribution | undefined;
  /**
   * Whether the employee deduction amount should be treated as a percentage to be deducted from each payroll.
   */
  deductAsPercentage?: DeductAsPercentage | undefined;
  /**
   * Whether the employee should use a benefit’s 'catch up' rate. Only Roth 401k and 401k benefits use this value for employees over 50.
   */
  catchUp?: CatchUp | undefined;
  /**
   * Some benefits require additional information to determine their limit. For example, for an HSA benefit, the limit option should be either 'Family' or 'Individual'. For a Dependent Care FSA benefit, the limit option should be either 'Joint Filing or Single' or 'Married and Filing Separately'.
   */
  limitOption?: LimitOption | undefined;
  /**
   * The maximum company contribution amount per year. A null value signifies no limit.
   */
  companyContributionAnnualMaximum?:
    | CompanyContributionAnnualMaximum
    | undefined;
  /**
   * The coverage amount as a multiple of the employee's salary. Only applicable for Group Term Life benefits. Note: cannot be set if coverage amount is also set.
   */
  coverageSalaryMultiplier?: CoverageSalaryMultiplier | undefined;
  /**
   * The amount that the employee is insured for. Note: company contribution cannot be present if coverage amount is set.
   */
  coverageAmount?: CoverageAmount | undefined;
};

/** @internal */
export const DefaultValue$inboundSchema: z.ZodType<
  DefaultValue,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
  type: z.string().optional(),
});

export function defaultValueFromJSON(
  jsonString: string,
): SafeParseResult<DefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DefaultValue' from JSON`,
  );
}

/** @internal */
export const EmployeeDeduction$inboundSchema: z.ZodType<
  EmployeeDeduction,
  z.ZodTypeDef,
  unknown
> = z.object({
  required: z.boolean().optional(),
  editable: z.boolean().optional(),
  default_value: z.lazy(() => DefaultValue$inboundSchema).optional(),
  choices: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "default_value": "defaultValue",
  });
});

export function employeeDeductionFromJSON(
  jsonString: string,
): SafeParseResult<EmployeeDeduction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmployeeDeduction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmployeeDeduction' from JSON`,
  );
}

/** @internal */
export const BenefitTypeRequirementsDefaultValue$inboundSchema: z.ZodType<
  BenefitTypeRequirementsDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string().optional(),
  type: z.string().optional(),
});

export function benefitTypeRequirementsDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<BenefitTypeRequirementsDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      BenefitTypeRequirementsDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BenefitTypeRequirementsDefaultValue' from JSON`,
  );
}

/** @internal */
export const BenefitTypeRequirementsContribution$inboundSchema: z.ZodType<
  BenefitTypeRequirementsContribution,
  z.ZodTypeDef,
  unknown
> = z.object({
  required: z.boolean().optional(),
  editable: z.boolean().optional(),
  default_value: z.lazy(() => BenefitTypeRequirementsDefaultValue$inboundSchema)
    .optional(),
  choices: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "default_value": "defaultValue",
  });
});

export function benefitTypeRequirementsContributionFromJSON(
  jsonString: string,
): SafeParseResult<BenefitTypeRequirementsContribution, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      BenefitTypeRequirementsContribution$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BenefitTypeRequirementsContribution' from JSON`,
  );
}

/** @internal */
export const BenefitTypeRequirementsDeductAsPercentageDefaultValue$inboundSchema:
  z.ZodType<
    BenefitTypeRequirementsDeductAsPercentageDefaultValue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    value: z.string().optional(),
    type: z.string().optional(),
  });

export function benefitTypeRequirementsDeductAsPercentageDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<
  BenefitTypeRequirementsDeductAsPercentageDefaultValue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      BenefitTypeRequirementsDeductAsPercentageDefaultValue$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'BenefitTypeRequirementsDeductAsPercentageDefaultValue' from JSON`,
  );
}

/** @internal */
export const DeductAsPercentage$inboundSchema: z.ZodType<
  DeductAsPercentage,
  z.ZodTypeDef,
  unknown
> = z.object({
  required: z.boolean().optional(),
  editable: z.boolean().optional(),
  default_value: z.lazy(() =>
    BenefitTypeRequirementsDeductAsPercentageDefaultValue$inboundSchema
  ).optional(),
  choices: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "default_value": "defaultValue",
  });
});

export function deductAsPercentageFromJSON(
  jsonString: string,
): SafeParseResult<DeductAsPercentage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeductAsPercentage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeductAsPercentage' from JSON`,
  );
}

/** @internal */
export const BenefitTypeRequirementsCatchUpDefaultValue$inboundSchema:
  z.ZodType<BenefitTypeRequirementsCatchUpDefaultValue, z.ZodTypeDef, unknown> =
    z.object({
      value: z.string().optional(),
      type: z.string().optional(),
    });

export function benefitTypeRequirementsCatchUpDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<
  BenefitTypeRequirementsCatchUpDefaultValue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      BenefitTypeRequirementsCatchUpDefaultValue$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'BenefitTypeRequirementsCatchUpDefaultValue' from JSON`,
  );
}

/** @internal */
export const CatchUp$inboundSchema: z.ZodType<CatchUp, z.ZodTypeDef, unknown> =
  z.object({
    required: z.boolean().optional(),
    editable: z.boolean().optional(),
    default_value: z.lazy(() =>
      BenefitTypeRequirementsCatchUpDefaultValue$inboundSchema
    ).optional(),
    choices: z.array(z.string()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "default_value": "defaultValue",
    });
  });

export function catchUpFromJSON(
  jsonString: string,
): SafeParseResult<CatchUp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CatchUp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CatchUp' from JSON`,
  );
}

/** @internal */
export const BenefitTypeRequirementsLimitOptionDefaultValue$inboundSchema:
  z.ZodType<
    BenefitTypeRequirementsLimitOptionDefaultValue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    value: z.string().optional(),
    type: z.string().optional(),
  });

export function benefitTypeRequirementsLimitOptionDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<
  BenefitTypeRequirementsLimitOptionDefaultValue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      BenefitTypeRequirementsLimitOptionDefaultValue$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'BenefitTypeRequirementsLimitOptionDefaultValue' from JSON`,
  );
}

/** @internal */
export const LimitOption$inboundSchema: z.ZodType<
  LimitOption,
  z.ZodTypeDef,
  unknown
> = z.object({
  required: z.boolean().optional(),
  editable: z.boolean().optional(),
  default_value: z.lazy(() =>
    BenefitTypeRequirementsLimitOptionDefaultValue$inboundSchema
  ).optional(),
  choices: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "default_value": "defaultValue",
  });
});

export function limitOptionFromJSON(
  jsonString: string,
): SafeParseResult<LimitOption, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LimitOption$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LimitOption' from JSON`,
  );
}

/** @internal */
export const BenefitTypeRequirementsCompanyContributionAnnualMaximumDefaultValue$inboundSchema:
  z.ZodType<
    BenefitTypeRequirementsCompanyContributionAnnualMaximumDefaultValue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    value: z.string().optional(),
    type: z.string().optional(),
  });

export function benefitTypeRequirementsCompanyContributionAnnualMaximumDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<
  BenefitTypeRequirementsCompanyContributionAnnualMaximumDefaultValue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      BenefitTypeRequirementsCompanyContributionAnnualMaximumDefaultValue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'BenefitTypeRequirementsCompanyContributionAnnualMaximumDefaultValue' from JSON`,
  );
}

/** @internal */
export const CompanyContributionAnnualMaximum$inboundSchema: z.ZodType<
  CompanyContributionAnnualMaximum,
  z.ZodTypeDef,
  unknown
> = z.object({
  required: z.boolean().optional(),
  editable: z.boolean().optional(),
  default_value: z.lazy(() =>
    BenefitTypeRequirementsCompanyContributionAnnualMaximumDefaultValue$inboundSchema
  ).optional(),
  choices: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "default_value": "defaultValue",
  });
});

export function companyContributionAnnualMaximumFromJSON(
  jsonString: string,
): SafeParseResult<CompanyContributionAnnualMaximum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CompanyContributionAnnualMaximum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompanyContributionAnnualMaximum' from JSON`,
  );
}

/** @internal */
export const BenefitTypeRequirementsCoverageSalaryMultiplierDefaultValue$inboundSchema:
  z.ZodType<
    BenefitTypeRequirementsCoverageSalaryMultiplierDefaultValue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    value: z.string().optional(),
    type: z.string().optional(),
  });

export function benefitTypeRequirementsCoverageSalaryMultiplierDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<
  BenefitTypeRequirementsCoverageSalaryMultiplierDefaultValue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      BenefitTypeRequirementsCoverageSalaryMultiplierDefaultValue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'BenefitTypeRequirementsCoverageSalaryMultiplierDefaultValue' from JSON`,
  );
}

/** @internal */
export const CoverageSalaryMultiplier$inboundSchema: z.ZodType<
  CoverageSalaryMultiplier,
  z.ZodTypeDef,
  unknown
> = z.object({
  required: z.boolean().optional(),
  editable: z.boolean().optional(),
  default_value: z.lazy(() =>
    BenefitTypeRequirementsCoverageSalaryMultiplierDefaultValue$inboundSchema
  ).optional(),
  choices: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "default_value": "defaultValue",
  });
});

export function coverageSalaryMultiplierFromJSON(
  jsonString: string,
): SafeParseResult<CoverageSalaryMultiplier, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CoverageSalaryMultiplier$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CoverageSalaryMultiplier' from JSON`,
  );
}

/** @internal */
export const BenefitTypeRequirementsCoverageAmountDefaultValue$inboundSchema:
  z.ZodType<
    BenefitTypeRequirementsCoverageAmountDefaultValue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    value: z.string().optional(),
    type: z.string().optional(),
  });

export function benefitTypeRequirementsCoverageAmountDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<
  BenefitTypeRequirementsCoverageAmountDefaultValue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      BenefitTypeRequirementsCoverageAmountDefaultValue$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'BenefitTypeRequirementsCoverageAmountDefaultValue' from JSON`,
  );
}

/** @internal */
export const CoverageAmount$inboundSchema: z.ZodType<
  CoverageAmount,
  z.ZodTypeDef,
  unknown
> = z.object({
  required: z.boolean().optional(),
  editable: z.boolean().optional(),
  default_value: z.lazy(() =>
    BenefitTypeRequirementsCoverageAmountDefaultValue$inboundSchema
  ).optional(),
  choices: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "default_value": "defaultValue",
  });
});

export function coverageAmountFromJSON(
  jsonString: string,
): SafeParseResult<CoverageAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CoverageAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CoverageAmount' from JSON`,
  );
}

/** @internal */
export const BenefitTypeRequirements$inboundSchema: z.ZodType<
  BenefitTypeRequirements,
  z.ZodTypeDef,
  unknown
> = z.object({
  employee_deduction: z.lazy(() => EmployeeDeduction$inboundSchema).optional(),
  contribution: z.lazy(() => BenefitTypeRequirementsContribution$inboundSchema)
    .optional(),
  deduct_as_percentage: z.lazy(() => DeductAsPercentage$inboundSchema)
    .optional(),
  catch_up: z.lazy(() => CatchUp$inboundSchema).optional(),
  limit_option: z.lazy(() => LimitOption$inboundSchema).optional(),
  company_contribution_annual_maximum: z.lazy(() =>
    CompanyContributionAnnualMaximum$inboundSchema
  ).optional(),
  coverage_salary_multiplier: z.lazy(() =>
    CoverageSalaryMultiplier$inboundSchema
  ).optional(),
  coverage_amount: z.lazy(() => CoverageAmount$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "employee_deduction": "employeeDeduction",
    "deduct_as_percentage": "deductAsPercentage",
    "catch_up": "catchUp",
    "limit_option": "limitOption",
    "company_contribution_annual_maximum": "companyContributionAnnualMaximum",
    "coverage_salary_multiplier": "coverageSalaryMultiplier",
    "coverage_amount": "coverageAmount",
  });
});

export function benefitTypeRequirementsFromJSON(
  jsonString: string,
): SafeParseResult<BenefitTypeRequirements, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BenefitTypeRequirements$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BenefitTypeRequirements' from JSON`,
  );
}

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  CompanyAddress,
  CompanyAddress$inboundSchema,
  CompanyAddress$Outbound,
  CompanyAddress$outboundSchema,
} from "./companyaddress.js";

/**
 * The tax payer type of the company.
 */
export const EntityType = {
  CCorporation: "C-Corporation",
  SCorporation: "S-Corporation",
  SoleProprietor: "Sole proprietor",
  Llc: "LLC",
  Llp: "LLP",
  LimitedPartnership: "Limited partnership",
  CoOwnership: "Co-ownership",
  Association: "Association",
  Trusteeship: "Trusteeship",
  GeneralPartnership: "General partnership",
  JointVenture: "Joint venture",
  NonProfit: "Non-Profit",
} as const;
/**
 * The tax payer type of the company.
 */
export type EntityType = ClosedEnum<typeof EntityType>;

/**
 * The Gusto product tier of the company (not applicable to Embedded partner managed companies).
 */
export const Tier = {
  Simple: "simple",
  Plus: "plus",
  Premium: "premium",
  Core: "core",
  Complete: "complete",
  Concierge: "concierge",
  ContractorOnly: "contractor_only",
  Basic: "basic",
} as const;
/**
 * The Gusto product tier of the company (not applicable to Embedded partner managed companies).
 */
export type Tier = ClosedEnum<typeof Tier>;

/**
 * The status of the company in Gusto. "Approved" companies are approved to run payroll from a risk and compliance perspective. However, an approved company may still need to resolve other [payroll blockers](https://docs.gusto.com/embedded-payroll/docs/payroll-blockers) to be able to run payroll. "Not Approved" companies may not yet run payroll with Gusto and may need to complete onboarding or contact support. "Suspended" companies may not run payroll with Gusto. In order to unsuspend their account, the company must contact support.
 */
export const CompanyStatus = {
  Approved: "Approved",
  NotApproved: "Not Approved",
  Suspended: "Suspended",
} as const;
/**
 * The status of the company in Gusto. "Approved" companies are approved to run payroll from a risk and compliance perspective. However, an approved company may still need to resolve other [payroll blockers](https://docs.gusto.com/embedded-payroll/docs/payroll-blockers) to be able to run payroll. "Not Approved" companies may not yet run payroll with Gusto and may need to complete onboarding or contact support. "Suspended" companies may not run payroll with Gusto. In order to unsuspend their account, the company must contact support.
 */
export type CompanyStatus = ClosedEnum<typeof CompanyStatus>;

/**
 * The pay schedule assignment type.
 */
export const PayScheduleType = {
  Single: "single",
  HourlySalaried: "hourly_salaried",
  ByEmployee: "by_employee",
  ByDepartment: "by_department",
} as const;
/**
 * The pay schedule assignment type.
 */
export type PayScheduleType = ClosedEnum<typeof PayScheduleType>;

/**
 * Company's default funding type
 */
export const FundingType = {
  Ach: "ach",
  ReverseWire: "reverse_wire",
  WireIn: "wire_in",
  Brex: "brex",
} as const;
/**
 * Company's default funding type
 */
export type FundingType = ClosedEnum<typeof FundingType>;

export type Hourly = {
  /**
   * The name of the hourly compensation rate.
   */
  name?: string | undefined;
  /**
   * The amount multiplied by the base rate of a job to calculate compensation.
   */
  multiple?: number | undefined;
};

export type Fixed = {
  /**
   * The name of the fixed compensation.
   */
  name?: string | undefined;
};

export type CompanyPaidTimeOff = {
  /**
   * The name of the paid time off type.
   */
  name?: string | undefined;
};

/**
 * The available company-wide compensation rates for the company.
 */
export type Compensations = {
  /**
   * The available hourly compensation rates for the company.
   */
  hourly?: Array<Hourly> | undefined;
  /**
   * The available fixed compensation rates for the company.
   */
  fixed?: Array<Fixed> | undefined;
  /**
   * The available types of paid time off for the company.
   */
  paidTimeOff?: Array<CompanyPaidTimeOff> | undefined;
};

/**
 * The company's primary signatory's home address.
 */
export type CompanyHomeAddress = {
  street1?: string | undefined;
  street2?: string | null | undefined;
  city?: string | undefined;
  state?: string | undefined;
  zip?: string | undefined;
  country?: string | undefined;
};

/**
 * The primary signatory of the company.
 */
export type PrimarySignatory = {
  /**
   * The UUID of the company's primary signatory.
   */
  uuid?: string | undefined;
  /**
   * The company's primary signatory's first name.
   */
  firstName?: string | undefined;
  /**
   * The company's primary signatory's middle initial.
   */
  middleInitial?: string | undefined;
  /**
   * The company's primary signatory's last name.
   */
  lastName?: string | undefined;
  /**
   * The company's primary signatory's phone number.
   */
  phone?: string | undefined;
  /**
   * The company's primary signatory's email address.
   */
  email?: string | undefined;
  /**
   * The company's primary signatory's home address.
   */
  homeAddress?: CompanyHomeAddress | undefined;
};

/**
 * The primary payroll admin of the company.
 */
export type PrimaryPayrollAdmin = {
  /**
   * The company's primary payroll admin's first name.
   */
  firstName?: string | undefined;
  /**
   * The company's primary payroll admin's last name.
   */
  lastName?: string | undefined;
  /**
   * The company's primary payroll admin's phone number.
   */
  phone?: string | null | undefined;
  /**
   * The company's primary payroll admin's email address.
   */
  email?: string | undefined;
};

/**
 * The representation of a company in Gusto.
 */
export type Company = {
  /**
   * The Federal Employer Identification Number of the company.
   */
  ein?: string | undefined;
  /**
   * The tax payer type of the company.
   */
  entityType?: EntityType | null | undefined;
  /**
   * Whether the company only supports contractors.
   */
  contractorOnly?: boolean | undefined;
  /**
   * The Gusto product tier of the company (not applicable to Embedded partner managed companies).
   */
  tier?: Tier | null | undefined;
  /**
   * Whether or not the company is suspended in Gusto. Suspended companies may not run payroll.
   */
  isSuspended?: boolean | undefined;
  /**
   * The status of the company in Gusto. "Approved" companies are approved to run payroll from a risk and compliance perspective. However, an approved company may still need to resolve other [payroll blockers](https://docs.gusto.com/embedded-payroll/docs/payroll-blockers) to be able to run payroll. "Not Approved" companies may not yet run payroll with Gusto and may need to complete onboarding or contact support. "Suspended" companies may not run payroll with Gusto. In order to unsuspend their account, the company must contact support.
   */
  companyStatus?: CompanyStatus | undefined;
  /**
   * A unique identifier of the company in Gusto.
   */
  uuid: string;
  /**
   * The name of the company.
   */
  name?: string | undefined;
  /**
   * The slug of the name of the company.
   */
  slug?: string | undefined;
  /**
   * The trade name of the company.
   */
  tradeName?: string | null | undefined;
  /**
   * Whether the company is fully managed by a partner via the API
   */
  isPartnerManaged?: boolean | undefined;
  /**
   * The pay schedule assignment type.
   */
  payScheduleType?: PayScheduleType | null | undefined;
  /**
   * Company's first invoiceable event date
   */
  joinDate?: string | null | undefined;
  /**
   * Company's default funding type
   */
  fundingType?: FundingType | null | undefined;
  /**
   * The locations of the company.
   */
  locations?: Array<CompanyAddress> | undefined;
  /**
   * The available company-wide compensation rates for the company.
   */
  compensations?: Compensations | undefined;
  /**
   * The primary signatory of the company.
   */
  primarySignatory?: PrimarySignatory | null | undefined;
  /**
   * The primary payroll admin of the company.
   */
  primaryPayrollAdmin?: PrimaryPayrollAdmin | undefined;
};

/** @internal */
export const EntityType$inboundSchema: z.ZodNativeEnum<typeof EntityType> = z
  .nativeEnum(EntityType);

/** @internal */
export const EntityType$outboundSchema: z.ZodNativeEnum<typeof EntityType> =
  EntityType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EntityType$ {
  /** @deprecated use `EntityType$inboundSchema` instead. */
  export const inboundSchema = EntityType$inboundSchema;
  /** @deprecated use `EntityType$outboundSchema` instead. */
  export const outboundSchema = EntityType$outboundSchema;
}

/** @internal */
export const Tier$inboundSchema: z.ZodNativeEnum<typeof Tier> = z.nativeEnum(
  Tier,
);

/** @internal */
export const Tier$outboundSchema: z.ZodNativeEnum<typeof Tier> =
  Tier$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Tier$ {
  /** @deprecated use `Tier$inboundSchema` instead. */
  export const inboundSchema = Tier$inboundSchema;
  /** @deprecated use `Tier$outboundSchema` instead. */
  export const outboundSchema = Tier$outboundSchema;
}

/** @internal */
export const CompanyStatus$inboundSchema: z.ZodNativeEnum<
  typeof CompanyStatus
> = z.nativeEnum(CompanyStatus);

/** @internal */
export const CompanyStatus$outboundSchema: z.ZodNativeEnum<
  typeof CompanyStatus
> = CompanyStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompanyStatus$ {
  /** @deprecated use `CompanyStatus$inboundSchema` instead. */
  export const inboundSchema = CompanyStatus$inboundSchema;
  /** @deprecated use `CompanyStatus$outboundSchema` instead. */
  export const outboundSchema = CompanyStatus$outboundSchema;
}

/** @internal */
export const PayScheduleType$inboundSchema: z.ZodNativeEnum<
  typeof PayScheduleType
> = z.nativeEnum(PayScheduleType);

/** @internal */
export const PayScheduleType$outboundSchema: z.ZodNativeEnum<
  typeof PayScheduleType
> = PayScheduleType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PayScheduleType$ {
  /** @deprecated use `PayScheduleType$inboundSchema` instead. */
  export const inboundSchema = PayScheduleType$inboundSchema;
  /** @deprecated use `PayScheduleType$outboundSchema` instead. */
  export const outboundSchema = PayScheduleType$outboundSchema;
}

/** @internal */
export const FundingType$inboundSchema: z.ZodNativeEnum<typeof FundingType> = z
  .nativeEnum(FundingType);

/** @internal */
export const FundingType$outboundSchema: z.ZodNativeEnum<typeof FundingType> =
  FundingType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FundingType$ {
  /** @deprecated use `FundingType$inboundSchema` instead. */
  export const inboundSchema = FundingType$inboundSchema;
  /** @deprecated use `FundingType$outboundSchema` instead. */
  export const outboundSchema = FundingType$outboundSchema;
}

/** @internal */
export const Hourly$inboundSchema: z.ZodType<Hourly, z.ZodTypeDef, unknown> = z
  .object({
    name: z.string().optional(),
    multiple: z.number().optional(),
  });

/** @internal */
export type Hourly$Outbound = {
  name?: string | undefined;
  multiple?: number | undefined;
};

/** @internal */
export const Hourly$outboundSchema: z.ZodType<
  Hourly$Outbound,
  z.ZodTypeDef,
  Hourly
> = z.object({
  name: z.string().optional(),
  multiple: z.number().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Hourly$ {
  /** @deprecated use `Hourly$inboundSchema` instead. */
  export const inboundSchema = Hourly$inboundSchema;
  /** @deprecated use `Hourly$outboundSchema` instead. */
  export const outboundSchema = Hourly$outboundSchema;
  /** @deprecated use `Hourly$Outbound` instead. */
  export type Outbound = Hourly$Outbound;
}

export function hourlyToJSON(hourly: Hourly): string {
  return JSON.stringify(Hourly$outboundSchema.parse(hourly));
}

export function hourlyFromJSON(
  jsonString: string,
): SafeParseResult<Hourly, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Hourly$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Hourly' from JSON`,
  );
}

/** @internal */
export const Fixed$inboundSchema: z.ZodType<Fixed, z.ZodTypeDef, unknown> = z
  .object({
    name: z.string().optional(),
  });

/** @internal */
export type Fixed$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const Fixed$outboundSchema: z.ZodType<
  Fixed$Outbound,
  z.ZodTypeDef,
  Fixed
> = z.object({
  name: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Fixed$ {
  /** @deprecated use `Fixed$inboundSchema` instead. */
  export const inboundSchema = Fixed$inboundSchema;
  /** @deprecated use `Fixed$outboundSchema` instead. */
  export const outboundSchema = Fixed$outboundSchema;
  /** @deprecated use `Fixed$Outbound` instead. */
  export type Outbound = Fixed$Outbound;
}

export function fixedToJSON(fixed: Fixed): string {
  return JSON.stringify(Fixed$outboundSchema.parse(fixed));
}

export function fixedFromJSON(
  jsonString: string,
): SafeParseResult<Fixed, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Fixed$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Fixed' from JSON`,
  );
}

/** @internal */
export const CompanyPaidTimeOff$inboundSchema: z.ZodType<
  CompanyPaidTimeOff,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
});

/** @internal */
export type CompanyPaidTimeOff$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const CompanyPaidTimeOff$outboundSchema: z.ZodType<
  CompanyPaidTimeOff$Outbound,
  z.ZodTypeDef,
  CompanyPaidTimeOff
> = z.object({
  name: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompanyPaidTimeOff$ {
  /** @deprecated use `CompanyPaidTimeOff$inboundSchema` instead. */
  export const inboundSchema = CompanyPaidTimeOff$inboundSchema;
  /** @deprecated use `CompanyPaidTimeOff$outboundSchema` instead. */
  export const outboundSchema = CompanyPaidTimeOff$outboundSchema;
  /** @deprecated use `CompanyPaidTimeOff$Outbound` instead. */
  export type Outbound = CompanyPaidTimeOff$Outbound;
}

export function companyPaidTimeOffToJSON(
  companyPaidTimeOff: CompanyPaidTimeOff,
): string {
  return JSON.stringify(
    CompanyPaidTimeOff$outboundSchema.parse(companyPaidTimeOff),
  );
}

export function companyPaidTimeOffFromJSON(
  jsonString: string,
): SafeParseResult<CompanyPaidTimeOff, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CompanyPaidTimeOff$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompanyPaidTimeOff' from JSON`,
  );
}

/** @internal */
export const Compensations$inboundSchema: z.ZodType<
  Compensations,
  z.ZodTypeDef,
  unknown
> = z.object({
  hourly: z.array(z.lazy(() => Hourly$inboundSchema)).optional(),
  fixed: z.array(z.lazy(() => Fixed$inboundSchema)).optional(),
  paid_time_off: z.array(z.lazy(() => CompanyPaidTimeOff$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "paid_time_off": "paidTimeOff",
  });
});

/** @internal */
export type Compensations$Outbound = {
  hourly?: Array<Hourly$Outbound> | undefined;
  fixed?: Array<Fixed$Outbound> | undefined;
  paid_time_off?: Array<CompanyPaidTimeOff$Outbound> | undefined;
};

/** @internal */
export const Compensations$outboundSchema: z.ZodType<
  Compensations$Outbound,
  z.ZodTypeDef,
  Compensations
> = z.object({
  hourly: z.array(z.lazy(() => Hourly$outboundSchema)).optional(),
  fixed: z.array(z.lazy(() => Fixed$outboundSchema)).optional(),
  paidTimeOff: z.array(z.lazy(() => CompanyPaidTimeOff$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    paidTimeOff: "paid_time_off",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Compensations$ {
  /** @deprecated use `Compensations$inboundSchema` instead. */
  export const inboundSchema = Compensations$inboundSchema;
  /** @deprecated use `Compensations$outboundSchema` instead. */
  export const outboundSchema = Compensations$outboundSchema;
  /** @deprecated use `Compensations$Outbound` instead. */
  export type Outbound = Compensations$Outbound;
}

export function compensationsToJSON(compensations: Compensations): string {
  return JSON.stringify(Compensations$outboundSchema.parse(compensations));
}

export function compensationsFromJSON(
  jsonString: string,
): SafeParseResult<Compensations, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Compensations$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Compensations' from JSON`,
  );
}

/** @internal */
export const CompanyHomeAddress$inboundSchema: z.ZodType<
  CompanyHomeAddress,
  z.ZodTypeDef,
  unknown
> = z.object({
  street_1: z.string().optional(),
  street_2: z.nullable(z.string()).optional(),
  city: z.string().optional(),
  state: z.string().optional(),
  zip: z.string().optional(),
  country: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "street_1": "street1",
    "street_2": "street2",
  });
});

/** @internal */
export type CompanyHomeAddress$Outbound = {
  street_1?: string | undefined;
  street_2?: string | null | undefined;
  city?: string | undefined;
  state?: string | undefined;
  zip?: string | undefined;
  country?: string | undefined;
};

/** @internal */
export const CompanyHomeAddress$outboundSchema: z.ZodType<
  CompanyHomeAddress$Outbound,
  z.ZodTypeDef,
  CompanyHomeAddress
> = z.object({
  street1: z.string().optional(),
  street2: z.nullable(z.string()).optional(),
  city: z.string().optional(),
  state: z.string().optional(),
  zip: z.string().optional(),
  country: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    street1: "street_1",
    street2: "street_2",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompanyHomeAddress$ {
  /** @deprecated use `CompanyHomeAddress$inboundSchema` instead. */
  export const inboundSchema = CompanyHomeAddress$inboundSchema;
  /** @deprecated use `CompanyHomeAddress$outboundSchema` instead. */
  export const outboundSchema = CompanyHomeAddress$outboundSchema;
  /** @deprecated use `CompanyHomeAddress$Outbound` instead. */
  export type Outbound = CompanyHomeAddress$Outbound;
}

export function companyHomeAddressToJSON(
  companyHomeAddress: CompanyHomeAddress,
): string {
  return JSON.stringify(
    CompanyHomeAddress$outboundSchema.parse(companyHomeAddress),
  );
}

export function companyHomeAddressFromJSON(
  jsonString: string,
): SafeParseResult<CompanyHomeAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CompanyHomeAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompanyHomeAddress' from JSON`,
  );
}

/** @internal */
export const PrimarySignatory$inboundSchema: z.ZodType<
  PrimarySignatory,
  z.ZodTypeDef,
  unknown
> = z.object({
  uuid: z.string().optional(),
  first_name: z.string().optional(),
  middle_initial: z.string().optional(),
  last_name: z.string().optional(),
  phone: z.string().optional(),
  email: z.string().optional(),
  home_address: z.lazy(() => CompanyHomeAddress$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "first_name": "firstName",
    "middle_initial": "middleInitial",
    "last_name": "lastName",
    "home_address": "homeAddress",
  });
});

/** @internal */
export type PrimarySignatory$Outbound = {
  uuid?: string | undefined;
  first_name?: string | undefined;
  middle_initial?: string | undefined;
  last_name?: string | undefined;
  phone?: string | undefined;
  email?: string | undefined;
  home_address?: CompanyHomeAddress$Outbound | undefined;
};

/** @internal */
export const PrimarySignatory$outboundSchema: z.ZodType<
  PrimarySignatory$Outbound,
  z.ZodTypeDef,
  PrimarySignatory
> = z.object({
  uuid: z.string().optional(),
  firstName: z.string().optional(),
  middleInitial: z.string().optional(),
  lastName: z.string().optional(),
  phone: z.string().optional(),
  email: z.string().optional(),
  homeAddress: z.lazy(() => CompanyHomeAddress$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    firstName: "first_name",
    middleInitial: "middle_initial",
    lastName: "last_name",
    homeAddress: "home_address",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrimarySignatory$ {
  /** @deprecated use `PrimarySignatory$inboundSchema` instead. */
  export const inboundSchema = PrimarySignatory$inboundSchema;
  /** @deprecated use `PrimarySignatory$outboundSchema` instead. */
  export const outboundSchema = PrimarySignatory$outboundSchema;
  /** @deprecated use `PrimarySignatory$Outbound` instead. */
  export type Outbound = PrimarySignatory$Outbound;
}

export function primarySignatoryToJSON(
  primarySignatory: PrimarySignatory,
): string {
  return JSON.stringify(
    PrimarySignatory$outboundSchema.parse(primarySignatory),
  );
}

export function primarySignatoryFromJSON(
  jsonString: string,
): SafeParseResult<PrimarySignatory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrimarySignatory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrimarySignatory' from JSON`,
  );
}

/** @internal */
export const PrimaryPayrollAdmin$inboundSchema: z.ZodType<
  PrimaryPayrollAdmin,
  z.ZodTypeDef,
  unknown
> = z.object({
  first_name: z.string().optional(),
  last_name: z.string().optional(),
  phone: z.nullable(z.string()).optional(),
  email: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "first_name": "firstName",
    "last_name": "lastName",
  });
});

/** @internal */
export type PrimaryPayrollAdmin$Outbound = {
  first_name?: string | undefined;
  last_name?: string | undefined;
  phone?: string | null | undefined;
  email?: string | undefined;
};

/** @internal */
export const PrimaryPayrollAdmin$outboundSchema: z.ZodType<
  PrimaryPayrollAdmin$Outbound,
  z.ZodTypeDef,
  PrimaryPayrollAdmin
> = z.object({
  firstName: z.string().optional(),
  lastName: z.string().optional(),
  phone: z.nullable(z.string()).optional(),
  email: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    firstName: "first_name",
    lastName: "last_name",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrimaryPayrollAdmin$ {
  /** @deprecated use `PrimaryPayrollAdmin$inboundSchema` instead. */
  export const inboundSchema = PrimaryPayrollAdmin$inboundSchema;
  /** @deprecated use `PrimaryPayrollAdmin$outboundSchema` instead. */
  export const outboundSchema = PrimaryPayrollAdmin$outboundSchema;
  /** @deprecated use `PrimaryPayrollAdmin$Outbound` instead. */
  export type Outbound = PrimaryPayrollAdmin$Outbound;
}

export function primaryPayrollAdminToJSON(
  primaryPayrollAdmin: PrimaryPayrollAdmin,
): string {
  return JSON.stringify(
    PrimaryPayrollAdmin$outboundSchema.parse(primaryPayrollAdmin),
  );
}

export function primaryPayrollAdminFromJSON(
  jsonString: string,
): SafeParseResult<PrimaryPayrollAdmin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrimaryPayrollAdmin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrimaryPayrollAdmin' from JSON`,
  );
}

/** @internal */
export const Company$inboundSchema: z.ZodType<Company, z.ZodTypeDef, unknown> =
  z.object({
    ein: z.string().optional(),
    entity_type: z.nullable(EntityType$inboundSchema).optional(),
    contractor_only: z.boolean().optional(),
    tier: z.nullable(Tier$inboundSchema).optional(),
    is_suspended: z.boolean().optional(),
    company_status: CompanyStatus$inboundSchema.optional(),
    uuid: z.string(),
    name: z.string().optional(),
    slug: z.string().optional(),
    trade_name: z.nullable(z.string()).optional(),
    is_partner_managed: z.boolean().optional(),
    pay_schedule_type: z.nullable(PayScheduleType$inboundSchema).optional(),
    join_date: z.nullable(z.string()).optional(),
    funding_type: z.nullable(FundingType$inboundSchema).optional(),
    locations: z.array(CompanyAddress$inboundSchema).optional(),
    compensations: z.lazy(() => Compensations$inboundSchema).optional(),
    primary_signatory: z.nullable(z.lazy(() => PrimarySignatory$inboundSchema))
      .optional(),
    primary_payroll_admin: z.lazy(() => PrimaryPayrollAdmin$inboundSchema)
      .optional(),
  }).transform((v) => {
    return remap$(v, {
      "entity_type": "entityType",
      "contractor_only": "contractorOnly",
      "is_suspended": "isSuspended",
      "company_status": "companyStatus",
      "trade_name": "tradeName",
      "is_partner_managed": "isPartnerManaged",
      "pay_schedule_type": "payScheduleType",
      "join_date": "joinDate",
      "funding_type": "fundingType",
      "primary_signatory": "primarySignatory",
      "primary_payroll_admin": "primaryPayrollAdmin",
    });
  });

/** @internal */
export type Company$Outbound = {
  ein?: string | undefined;
  entity_type?: string | null | undefined;
  contractor_only?: boolean | undefined;
  tier?: string | null | undefined;
  is_suspended?: boolean | undefined;
  company_status?: string | undefined;
  uuid: string;
  name?: string | undefined;
  slug?: string | undefined;
  trade_name?: string | null | undefined;
  is_partner_managed?: boolean | undefined;
  pay_schedule_type?: string | null | undefined;
  join_date?: string | null | undefined;
  funding_type?: string | null | undefined;
  locations?: Array<CompanyAddress$Outbound> | undefined;
  compensations?: Compensations$Outbound | undefined;
  primary_signatory?: PrimarySignatory$Outbound | null | undefined;
  primary_payroll_admin?: PrimaryPayrollAdmin$Outbound | undefined;
};

/** @internal */
export const Company$outboundSchema: z.ZodType<
  Company$Outbound,
  z.ZodTypeDef,
  Company
> = z.object({
  ein: z.string().optional(),
  entityType: z.nullable(EntityType$outboundSchema).optional(),
  contractorOnly: z.boolean().optional(),
  tier: z.nullable(Tier$outboundSchema).optional(),
  isSuspended: z.boolean().optional(),
  companyStatus: CompanyStatus$outboundSchema.optional(),
  uuid: z.string(),
  name: z.string().optional(),
  slug: z.string().optional(),
  tradeName: z.nullable(z.string()).optional(),
  isPartnerManaged: z.boolean().optional(),
  payScheduleType: z.nullable(PayScheduleType$outboundSchema).optional(),
  joinDate: z.nullable(z.string()).optional(),
  fundingType: z.nullable(FundingType$outboundSchema).optional(),
  locations: z.array(CompanyAddress$outboundSchema).optional(),
  compensations: z.lazy(() => Compensations$outboundSchema).optional(),
  primarySignatory: z.nullable(z.lazy(() => PrimarySignatory$outboundSchema))
    .optional(),
  primaryPayrollAdmin: z.lazy(() => PrimaryPayrollAdmin$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    entityType: "entity_type",
    contractorOnly: "contractor_only",
    isSuspended: "is_suspended",
    companyStatus: "company_status",
    tradeName: "trade_name",
    isPartnerManaged: "is_partner_managed",
    payScheduleType: "pay_schedule_type",
    joinDate: "join_date",
    fundingType: "funding_type",
    primarySignatory: "primary_signatory",
    primaryPayrollAdmin: "primary_payroll_admin",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Company$ {
  /** @deprecated use `Company$inboundSchema` instead. */
  export const inboundSchema = Company$inboundSchema;
  /** @deprecated use `Company$outboundSchema` instead. */
  export const outboundSchema = Company$outboundSchema;
  /** @deprecated use `Company$Outbound` instead. */
  export type Outbound = Company$Outbound;
}

export function companyToJSON(company: Company): string {
  return JSON.stringify(Company$outboundSchema.parse(company));
}

export function companyFromJSON(
  jsonString: string,
): SafeParseResult<Company, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Company$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Company' from JSON`,
  );
}

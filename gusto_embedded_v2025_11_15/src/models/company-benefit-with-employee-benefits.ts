/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";

/**
 * The source of the company benefit. This can be "internal", "external", or "partnered". Company benefits created via the API default to "external". Certain partners can create company benefits with a source of "partnered".
 */
export const CompanyBenefitWithEmployeeBenefitsSource = {
  Internal: "internal",
  External: "external",
  Partnered: "partnered",
} as const;
/**
 * The source of the company benefit. This can be "internal", "external", or "partnered". Company benefits created via the API default to "external". Certain partners can create company benefits with a source of "partnered".
 */
export type CompanyBenefitWithEmployeeBenefitsSource = OpenEnum<
  typeof CompanyBenefitWithEmployeeBenefitsSource
>;

/**
 * The type of catch-up contribution for this benefit, as required by Section 603 of the SECURE 2.0 Act. Only applicable to pre-tax 401(k) and 403(b) benefits.
 */
export const CompanyBenefitWithEmployeeBenefitsCatchUpType = {
  Elective: "elective",
  Deemed: "deemed",
} as const;
/**
 * The type of catch-up contribution for this benefit, as required by Section 603 of the SECURE 2.0 Act. Only applicable to pre-tax 401(k) and 403(b) benefits.
 */
export type CompanyBenefitWithEmployeeBenefitsCatchUpType = OpenEnum<
  typeof CompanyBenefitWithEmployeeBenefitsCatchUpType
>;

/**
 * A single tier of a tiered matching scheme.
 */
export type CompanyBenefitWithEmployeeBenefitsTier = {
  /**
   * The percentage of employee deduction within this tier the company contribution will match.
   */
  rate?: string | undefined;
  /**
   * Specifies the upper limit (inclusive) percentage of the employee contribution that this tier applies to.
   *
   * @remarks
   *
   * Use threshold to define each tier's end point, with tiers applied cumulatively from 0% upwards.
   *
   * For example:
   *
   * If the first tier has a threshold of "3", and `rate` of "100", the company will match 100% of employee contributions from 0% up to and including 3% of payroll.
   *
   * If the next tier has a threshold of "5" and a rate of "50", the company will match 50% of contributions from above 3% up to and including 5% of payroll.
   */
  threshold?: string | undefined;
  /**
   * The step up difference between this tier's threshold and the previous tier's threshold. In the first tier, this is equivalent to threshold.
   */
  thresholdDelta?: string | undefined;
};

export type CompanyBenefitWithEmployeeBenefitsValue = {
  tiers?: Array<CompanyBenefitWithEmployeeBenefitsTier> | undefined;
};

/**
 * For the `amount` and `percentage` contribution types, the value of the corresponding amount or percentage.
 *
 * @remarks
 *
 * For the `tiered` contribution type, an array of tiers.
 */
export type CompanyBenefitWithEmployeeBenefitsValueUnion =
  | string
  | CompanyBenefitWithEmployeeBenefitsValue;

/**
 * An object representing the type and value of the company contribution.
 */
export type CompanyBenefitWithEmployeeBenefitsContribution = {
  /**
   * The company contribution scheme.
   *
   * @remarks
   *
   * "amount": The company contributes a fixed amount per payroll. If elective is true, the contribution is matching, dollar-for-dollar.
   *
   * "percentage": The company contributes a percentage of the payroll amount per payroll period. If elective is true, the contribution is matching, dollar-for-dollar.
   *
   * "tiered": The company contribution varies according to the size of the employee deduction.
   */
  type?: string | undefined;
  /**
   * For the `amount` and `percentage` contribution types, the value of the corresponding amount or percentage.
   *
   * @remarks
   *
   * For the `tiered` contribution type, an array of tiers.
   */
  value?: string | CompanyBenefitWithEmployeeBenefitsValue | undefined;
};

export type CompanyBenefitWithEmployeeBenefitsEmployeeBenefit = {
  /**
   * The UUID of the employee to which the benefit belongs.
   */
  employeeUuid?: string | undefined;
  /**
   * The UUID of the company benefit.
   */
  companyBenefitUuid?: string | undefined;
  /**
   * Whether the employee benefit is active.
   */
  active: boolean;
  /**
   * Whether the employee deduction amount should be treated as a percentage to be deducted from each payroll.
   */
  deductAsPercentage: boolean;
  /**
   * The amount to be deducted, per pay period, from the employee's pay.
   */
  employeeDeduction: string;
  /**
   * The value of the company contribution
   */
  companyContribution?: string | undefined;
  /**
   * The date when the employee benefit becomes effective. If not provided, the benefit will be effective from 1970-01-01 (unix epoch).
   */
  effectiveDate?: string | undefined;
  /**
   * The date when the employee benefit expires. If not provided, the benefit will have no expiration date.
   */
  expirationDate?: string | undefined;
  /**
   * An object representing the type and value of the company contribution.
   */
  contribution?: CompanyBenefitWithEmployeeBenefitsContribution | undefined;
};

/**
 * The representation of a company benefit.
 */
export type CompanyBenefitWithEmployeeBenefits = {
  /**
   * The current version of the object. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
   */
  version?: string | undefined;
  /**
   * The UUID of the company.
   */
  companyUuid?: string | undefined;
  /**
   * The UUID of the company benefit.
   */
  uuid: string;
  /**
   * The type of the benefit to which the company benefit belongs (same as benefit_id).
   */
  benefitType?: number | undefined;
  /**
   * Whether this benefit is active for employee participation. Company benefits may only be deactivated if no employees are actively participating.
   */
  active: boolean;
  /**
   * The description of the company benefit. For example, a company may offer multiple benefits with an ID of 1 (for Medical Insurance). The description would show something more specific like “Kaiser Permanente” or “Blue Cross/ Blue Shield”.
   */
  description?: string | undefined;
  /**
   * The source of the company benefit. This can be "internal", "external", or "partnered". Company benefits created via the API default to "external". Certain partners can create company benefits with a source of "partnered".
   */
  source?: CompanyBenefitWithEmployeeBenefitsSource | undefined;
  /**
   * The partner name of the partner that created the company benefit. For example, "XYZ Corp".
   */
  partnerName?: string | null | undefined;
  /**
   * Whether this company benefit can be deleted. Deletable will be set to true if the benefit has not been used in payroll, has no employee benefits associated, and the benefit is not owned by Gusto or a Partner
   */
  deletable?: boolean | undefined;
  /**
   * Whether employee deductions and company contributions can be set as percentages of payroll for an individual employee. This is determined by the type of benefit and is not configurable by the company.
   */
  supportsPercentageAmounts?: boolean | undefined;
  /**
   * Whether the employer is subject to pay employer taxes when an employee is on leave. Only applicable to third party sick pay benefits.
   */
  responsibleForEmployerTaxes?: boolean | undefined;
  /**
   * Whether the employer is subject to file W-2 forms for an employee on leave. Only applicable to third party sick pay benefits.
   */
  responsibleForEmployeeW2?: boolean | undefined;
  /**
   * The type of catch-up contribution for this benefit, as required by Section 603 of the SECURE 2.0 Act. Only applicable to pre-tax 401(k) and 403(b) benefits.
   */
  catchUpType?:
    | CompanyBenefitWithEmployeeBenefitsCatchUpType
    | null
    | undefined;
  employeeBenefits?:
    | Array<CompanyBenefitWithEmployeeBenefitsEmployeeBenefit>
    | undefined;
};

/** @internal */
export const CompanyBenefitWithEmployeeBenefitsSource$inboundSchema:
  z.ZodMiniType<CompanyBenefitWithEmployeeBenefitsSource, unknown> = openEnums
    .inboundSchema(CompanyBenefitWithEmployeeBenefitsSource);

/** @internal */
export const CompanyBenefitWithEmployeeBenefitsCatchUpType$inboundSchema:
  z.ZodMiniType<CompanyBenefitWithEmployeeBenefitsCatchUpType, unknown> =
    openEnums.inboundSchema(CompanyBenefitWithEmployeeBenefitsCatchUpType);

/** @internal */
export const CompanyBenefitWithEmployeeBenefitsTier$inboundSchema:
  z.ZodMiniType<CompanyBenefitWithEmployeeBenefitsTier, unknown> = z.pipe(
    z.object({
      rate: types.optional(types.string()),
      threshold: types.optional(types.string()),
      threshold_delta: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "threshold_delta": "thresholdDelta",
      });
    }),
  );

export function companyBenefitWithEmployeeBenefitsTierFromJSON(
  jsonString: string,
): SafeParseResult<CompanyBenefitWithEmployeeBenefitsTier, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CompanyBenefitWithEmployeeBenefitsTier$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompanyBenefitWithEmployeeBenefitsTier' from JSON`,
  );
}

/** @internal */
export const CompanyBenefitWithEmployeeBenefitsValue$inboundSchema:
  z.ZodMiniType<CompanyBenefitWithEmployeeBenefitsValue, unknown> = z.object({
    tiers: types.optional(
      z.array(
        z.lazy(() => CompanyBenefitWithEmployeeBenefitsTier$inboundSchema),
      ),
    ),
  });

export function companyBenefitWithEmployeeBenefitsValueFromJSON(
  jsonString: string,
): SafeParseResult<
  CompanyBenefitWithEmployeeBenefitsValue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CompanyBenefitWithEmployeeBenefitsValue$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CompanyBenefitWithEmployeeBenefitsValue' from JSON`,
  );
}

/** @internal */
export const CompanyBenefitWithEmployeeBenefitsValueUnion$inboundSchema:
  z.ZodMiniType<CompanyBenefitWithEmployeeBenefitsValueUnion, unknown> =
    smartUnion([
      types.string(),
      z.lazy(() => CompanyBenefitWithEmployeeBenefitsValue$inboundSchema),
    ]);

export function companyBenefitWithEmployeeBenefitsValueUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  CompanyBenefitWithEmployeeBenefitsValueUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CompanyBenefitWithEmployeeBenefitsValueUnion$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CompanyBenefitWithEmployeeBenefitsValueUnion' from JSON`,
  );
}

/** @internal */
export const CompanyBenefitWithEmployeeBenefitsContribution$inboundSchema:
  z.ZodMiniType<CompanyBenefitWithEmployeeBenefitsContribution, unknown> = z
    .object({
      type: types.optional(types.string()),
      value: types.optional(
        smartUnion([
          types.string(),
          z.lazy(() => CompanyBenefitWithEmployeeBenefitsValue$inboundSchema),
        ]),
      ),
    });

export function companyBenefitWithEmployeeBenefitsContributionFromJSON(
  jsonString: string,
): SafeParseResult<
  CompanyBenefitWithEmployeeBenefitsContribution,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CompanyBenefitWithEmployeeBenefitsContribution$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CompanyBenefitWithEmployeeBenefitsContribution' from JSON`,
  );
}

/** @internal */
export const CompanyBenefitWithEmployeeBenefitsEmployeeBenefit$inboundSchema:
  z.ZodMiniType<CompanyBenefitWithEmployeeBenefitsEmployeeBenefit, unknown> = z
    .pipe(
      z.object({
        employee_uuid: types.optional(types.string()),
        company_benefit_uuid: types.optional(types.string()),
        active: z._default(types.boolean(), true),
        deduct_as_percentage: z._default(types.boolean(), false),
        employee_deduction: z._default(types.string(), "0.00"),
        company_contribution: types.optional(types.string()),
        effective_date: types.optional(types.string()),
        expiration_date: types.optional(types.string()),
        contribution: types.optional(z.lazy(() =>
          CompanyBenefitWithEmployeeBenefitsContribution$inboundSchema
        )),
      }),
      z.transform((v) => {
        return remap$(v, {
          "employee_uuid": "employeeUuid",
          "company_benefit_uuid": "companyBenefitUuid",
          "deduct_as_percentage": "deductAsPercentage",
          "employee_deduction": "employeeDeduction",
          "company_contribution": "companyContribution",
          "effective_date": "effectiveDate",
          "expiration_date": "expirationDate",
        });
      }),
    );

export function companyBenefitWithEmployeeBenefitsEmployeeBenefitFromJSON(
  jsonString: string,
): SafeParseResult<
  CompanyBenefitWithEmployeeBenefitsEmployeeBenefit,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CompanyBenefitWithEmployeeBenefitsEmployeeBenefit$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CompanyBenefitWithEmployeeBenefitsEmployeeBenefit' from JSON`,
  );
}

/** @internal */
export const CompanyBenefitWithEmployeeBenefits$inboundSchema: z.ZodMiniType<
  CompanyBenefitWithEmployeeBenefits,
  unknown
> = z.pipe(
  z.object({
    version: types.optional(types.string()),
    company_uuid: types.optional(types.string()),
    uuid: types.string(),
    benefit_type: types.optional(types.number()),
    active: z._default(types.boolean(), true),
    description: types.optional(types.string()),
    source: types.optional(
      CompanyBenefitWithEmployeeBenefitsSource$inboundSchema,
    ),
    partner_name: z.optional(z.nullable(types.string())),
    deletable: types.optional(types.boolean()),
    supports_percentage_amounts: types.optional(types.boolean()),
    responsible_for_employer_taxes: types.optional(types.boolean()),
    responsible_for_employee_w2: types.optional(types.boolean()),
    catch_up_type: z.optional(
      z.nullable(CompanyBenefitWithEmployeeBenefitsCatchUpType$inboundSchema),
    ),
    employee_benefits: types.optional(z.array(z.lazy(() =>
      CompanyBenefitWithEmployeeBenefitsEmployeeBenefit$inboundSchema
    ))),
  }),
  z.transform((v) => {
    return remap$(v, {
      "company_uuid": "companyUuid",
      "benefit_type": "benefitType",
      "partner_name": "partnerName",
      "supports_percentage_amounts": "supportsPercentageAmounts",
      "responsible_for_employer_taxes": "responsibleForEmployerTaxes",
      "responsible_for_employee_w2": "responsibleForEmployeeW2",
      "catch_up_type": "catchUpType",
      "employee_benefits": "employeeBenefits",
    });
  }),
);

export function companyBenefitWithEmployeeBenefitsFromJSON(
  jsonString: string,
): SafeParseResult<CompanyBenefitWithEmployeeBenefits, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CompanyBenefitWithEmployeeBenefits$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompanyBenefitWithEmployeeBenefits' from JSON`,
  );
}

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";

/**
 * The employee's compensation payment method. Is *only* `Historical` when retrieving external payrolls initially run outside of Gusto, then put into Gusto.
 */
export const PayrollEmployeeCompensationsTypePaymentMethod = {
  DirectDeposit: "Direct Deposit",
  Check: "Check",
  Historical: "Historical",
} as const;
/**
 * The employee's compensation payment method. Is *only* `Historical` when retrieving external payrolls initially run outside of Gusto, then put into Gusto.
 */
export type PayrollEmployeeCompensationsTypePaymentMethod = OpenEnum<
  typeof PayrollEmployeeCompensationsTypePaymentMethod
>;

export type PayrollEmployeeCompensationsTypeFixedCompensation = {
  /**
   * The name of the compensation. This also serves as the unique, immutable identifier for this compensation.
   */
  name?: string | undefined;
  /**
   * The amount of the compensation for the pay period.
   */
  amount?: string | undefined;
  /**
   * The UUID of the job for the compensation.
   */
  jobUuid?: string | undefined;
};

export type PayrollEmployeeCompensationsTypeHourlyCompensation = {
  /**
   * The name of the compensation. This also serves as the unique, immutable identifier for this compensation.
   */
  name?: string | undefined;
  /**
   * The number of hours to be compensated for this pay period.
   */
  hours?: string | undefined;
  /**
   * The amount of the compensation. This field is only available after the payroll is calculated and cannot be used for updating hourly compensations.
   */
  amount?: string | undefined;
  /**
   * The UUID of the job for the compensation.
   */
  jobUuid?: string | undefined;
  /**
   * The amount multiplied by the base rate to calculate total compensation per hour worked.
   */
  compensationMultiplier?: number | undefined;
  /**
   * The FLSA Status of the employee's primary job compensation
   */
  flsaStatus?: string | undefined;
};

export type PayrollEmployeeCompensationsTypePaidTimeOff = {
  /**
   * The name of the PTO. This also serves as the unique, immutable identifier for the PTO.
   */
  name?: string | undefined;
  /**
   * The hours of this PTO taken during the pay period.
   */
  hours?: string | undefined;
  /**
   * The outstanding hours paid upon termination. This field is only applicable for termination payrolls.
   */
  finalPayoutUnusedHoursInput?: string | undefined;
};

/**
 * The amount type of the deduction for the pay period. Only present for calculated or processed payrolls.
 */
export const PayrollEmployeeCompensationsTypeAmountType = {
  Fixed: "fixed",
  Percent: "percent",
} as const;
/**
 * The amount type of the deduction for the pay period. Only present for calculated or processed payrolls.
 */
export type PayrollEmployeeCompensationsTypeAmountType = OpenEnum<
  typeof PayrollEmployeeCompensationsTypeAmountType
>;

/**
 * An array of deductions for the employee.
 */
export type PayrollEmployeeCompensationsTypeDeduction = {
  /**
   * The name of the deduction.
   */
  name?: string | undefined;
  /**
   * The amount of the deduction for the pay period.
   */
  amount?: number | undefined;
  /**
   * The amount type of the deduction for the pay period. Only present for calculated or processed payrolls.
   */
  amountType?: PayrollEmployeeCompensationsTypeAmountType | undefined;
  /**
   * The UUID of the deduction. Only present for calculated or processed payrolls.
   */
  uuid?: string | undefined;
};

export type PayrollEmployeeCompensationsTypeReimbursement = {
  /**
   * The dollar amount of the reimbursement for the pay period.
   */
  amount: string;
  /**
   * The description of the reimbursement. Null for unnamed reimbursements.
   */
  description: string | null;
  /**
   * The UUID of the reimbursement. Null for unnamed reimbursements. This field is only available for unprocessed payrolls.
   */
  uuid?: string | null | undefined;
  /**
   * Whether the reimbursement is recurring. This field is only available for unprocessed payrolls.
   */
  recurring?: boolean | undefined;
};

export type PayrollEmployeeCompensationsType = {
  /**
   * The UUID of the employee.
   */
  employeeUuid?: string | undefined;
  /**
   * This employee will be excluded (skipped) from payroll calculation and will not be paid for the payroll. Cancelling a payroll would reset all employees' excluded back to false.
   */
  excluded?: boolean | undefined;
  /**
   * The current version of this employee compensation. This field is only available for prepared payrolls. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
   */
  version?: string | undefined;
  /**
   * The first name of the employee. Requires `employees:read` scope.
   */
  firstName?: string | null | undefined;
  /**
   * The preferred first name of the employee. Requires `employees:read` scope.
   */
  preferredFirstName?: string | null | undefined;
  /**
   * The last name of the employee. Requires `employees:read` scope.
   */
  lastName?: string | null | undefined;
  /**
   * The employee's gross pay, equal to regular wages + cash tips + payroll tips + any other additional earnings, excluding imputed income. This value is only available for processed payrolls.
   */
  grossPay?: number | null | undefined;
  /**
   * The employee's net pay, equal to gross_pay - employee taxes - employee deductions or garnishments - cash tips. This value is only available for processed payrolls.
   */
  netPay?: number | null | undefined;
  /**
   * The employee's check amount, equal to net_pay + reimbursements. This value is only available for processed payrolls.
   */
  checkAmount?: number | null | undefined;
  /**
   * The employee's compensation payment method. Is *only* `Historical` when retrieving external payrolls initially run outside of Gusto, then put into Gusto.
   */
  paymentMethod?:
    | PayrollEmployeeCompensationsTypePaymentMethod
    | null
    | undefined;
  /**
   * Custom text that will be printed as a personal note to the employee on a paystub.
   */
  memo?: string | null | undefined;
  /**
   * An array of fixed compensations for the employee. Fixed compensations include tips, bonuses, and one time reimbursements. If this payroll has been processed, only fixed compensations with a value greater than 0.00 are returned. For an unprocessed payroll, all active fixed compensations are returned.
   */
  fixedCompensations?:
    | Array<PayrollEmployeeCompensationsTypeFixedCompensation>
    | undefined;
  /**
   * An array of hourly compensations for the employee. Hourly compensations include regular, overtime, and double overtime hours. If this payroll has been processed, only hourly compensations with a value greater than 0.00 are returned. For an unprocessed payroll, all active hourly compensations are returned.
   */
  hourlyCompensations?:
    | Array<PayrollEmployeeCompensationsTypeHourlyCompensation>
    | undefined;
  /**
   * An array of all paid time off the employee is eligible for this pay period.
   */
  paidTimeOff?: Array<PayrollEmployeeCompensationsTypePaidTimeOff> | undefined;
  deductions?: Array<PayrollEmployeeCompensationsTypeDeduction> | undefined;
  /**
   * An array of reimbursements for the employee.
   */
  reimbursements?:
    | Array<PayrollEmployeeCompensationsTypeReimbursement>
    | undefined;
};

/** @internal */
export const PayrollEmployeeCompensationsTypePaymentMethod$inboundSchema:
  z.ZodMiniType<PayrollEmployeeCompensationsTypePaymentMethod, unknown> =
    openEnums.inboundSchema(PayrollEmployeeCompensationsTypePaymentMethod);

/** @internal */
export const PayrollEmployeeCompensationsTypeFixedCompensation$inboundSchema:
  z.ZodMiniType<PayrollEmployeeCompensationsTypeFixedCompensation, unknown> = z
    .pipe(
      z.object({
        name: types.optional(types.string()),
        amount: types.optional(types.string()),
        job_uuid: types.optional(types.string()),
      }),
      z.transform((v) => {
        return remap$(v, {
          "job_uuid": "jobUuid",
        });
      }),
    );

export function payrollEmployeeCompensationsTypeFixedCompensationFromJSON(
  jsonString: string,
): SafeParseResult<
  PayrollEmployeeCompensationsTypeFixedCompensation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PayrollEmployeeCompensationsTypeFixedCompensation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PayrollEmployeeCompensationsTypeFixedCompensation' from JSON`,
  );
}

/** @internal */
export const PayrollEmployeeCompensationsTypeHourlyCompensation$inboundSchema:
  z.ZodMiniType<PayrollEmployeeCompensationsTypeHourlyCompensation, unknown> = z
    .pipe(
      z.object({
        name: types.optional(types.string()),
        hours: types.optional(types.string()),
        amount: types.optional(types.string()),
        job_uuid: types.optional(types.string()),
        compensation_multiplier: types.optional(types.number()),
        flsa_status: types.optional(types.string()),
      }),
      z.transform((v) => {
        return remap$(v, {
          "job_uuid": "jobUuid",
          "compensation_multiplier": "compensationMultiplier",
          "flsa_status": "flsaStatus",
        });
      }),
    );

export function payrollEmployeeCompensationsTypeHourlyCompensationFromJSON(
  jsonString: string,
): SafeParseResult<
  PayrollEmployeeCompensationsTypeHourlyCompensation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PayrollEmployeeCompensationsTypeHourlyCompensation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PayrollEmployeeCompensationsTypeHourlyCompensation' from JSON`,
  );
}

/** @internal */
export const PayrollEmployeeCompensationsTypePaidTimeOff$inboundSchema:
  z.ZodMiniType<PayrollEmployeeCompensationsTypePaidTimeOff, unknown> = z.pipe(
    z.object({
      name: types.optional(types.string()),
      hours: types.optional(types.string()),
      final_payout_unused_hours_input: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "final_payout_unused_hours_input": "finalPayoutUnusedHoursInput",
      });
    }),
  );

export function payrollEmployeeCompensationsTypePaidTimeOffFromJSON(
  jsonString: string,
): SafeParseResult<
  PayrollEmployeeCompensationsTypePaidTimeOff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PayrollEmployeeCompensationsTypePaidTimeOff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PayrollEmployeeCompensationsTypePaidTimeOff' from JSON`,
  );
}

/** @internal */
export const PayrollEmployeeCompensationsTypeAmountType$inboundSchema:
  z.ZodMiniType<PayrollEmployeeCompensationsTypeAmountType, unknown> = openEnums
    .inboundSchema(PayrollEmployeeCompensationsTypeAmountType);

/** @internal */
export const PayrollEmployeeCompensationsTypeDeduction$inboundSchema:
  z.ZodMiniType<PayrollEmployeeCompensationsTypeDeduction, unknown> = z.pipe(
    z.object({
      name: types.optional(types.string()),
      amount: types.optional(types.number()),
      amount_type: types.optional(
        PayrollEmployeeCompensationsTypeAmountType$inboundSchema,
      ),
      uuid: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "amount_type": "amountType",
      });
    }),
  );

export function payrollEmployeeCompensationsTypeDeductionFromJSON(
  jsonString: string,
): SafeParseResult<
  PayrollEmployeeCompensationsTypeDeduction,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PayrollEmployeeCompensationsTypeDeduction$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PayrollEmployeeCompensationsTypeDeduction' from JSON`,
  );
}

/** @internal */
export const PayrollEmployeeCompensationsTypeReimbursement$inboundSchema:
  z.ZodMiniType<PayrollEmployeeCompensationsTypeReimbursement, unknown> = z
    .object({
      amount: types.string(),
      description: types.nullable(types.string()),
      uuid: z.optional(z.nullable(types.string())),
      recurring: types.optional(types.boolean()),
    });

export function payrollEmployeeCompensationsTypeReimbursementFromJSON(
  jsonString: string,
): SafeParseResult<
  PayrollEmployeeCompensationsTypeReimbursement,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PayrollEmployeeCompensationsTypeReimbursement$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PayrollEmployeeCompensationsTypeReimbursement' from JSON`,
  );
}

/** @internal */
export const PayrollEmployeeCompensationsType$inboundSchema: z.ZodMiniType<
  PayrollEmployeeCompensationsType,
  unknown
> = z.pipe(
  z.object({
    employee_uuid: types.optional(types.string()),
    excluded: types.optional(types.boolean()),
    version: types.optional(types.string()),
    first_name: z.optional(z.nullable(types.string())),
    preferred_first_name: z.optional(z.nullable(types.string())),
    last_name: z.optional(z.nullable(types.string())),
    gross_pay: z.optional(z.nullable(types.number())),
    net_pay: z.optional(z.nullable(types.number())),
    check_amount: z.optional(z.nullable(types.number())),
    payment_method: z.optional(
      z.nullable(PayrollEmployeeCompensationsTypePaymentMethod$inboundSchema),
    ),
    memo: z.optional(z.nullable(types.string())),
    fixed_compensations: types.optional(z.array(z.lazy(() =>
      PayrollEmployeeCompensationsTypeFixedCompensation$inboundSchema
    ))),
    hourly_compensations: types.optional(z.array(z.lazy(() =>
      PayrollEmployeeCompensationsTypeHourlyCompensation$inboundSchema
    ))),
    paid_time_off: types.optional(z.array(z.lazy(() =>
      PayrollEmployeeCompensationsTypePaidTimeOff$inboundSchema
    ))),
    deductions: types.optional(z.array(z.lazy(() =>
      PayrollEmployeeCompensationsTypeDeduction$inboundSchema
    ))),
    reimbursements: types.optional(z.array(z.lazy(() =>
      PayrollEmployeeCompensationsTypeReimbursement$inboundSchema
    ))),
  }),
  z.transform((v) => {
    return remap$(v, {
      "employee_uuid": "employeeUuid",
      "first_name": "firstName",
      "preferred_first_name": "preferredFirstName",
      "last_name": "lastName",
      "gross_pay": "grossPay",
      "net_pay": "netPay",
      "check_amount": "checkAmount",
      "payment_method": "paymentMethod",
      "fixed_compensations": "fixedCompensations",
      "hourly_compensations": "hourlyCompensations",
      "paid_time_off": "paidTimeOff",
    });
  }),
);

export function payrollEmployeeCompensationsTypeFromJSON(
  jsonString: string,
): SafeParseResult<PayrollEmployeeCompensationsType, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayrollEmployeeCompensationsType$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayrollEmployeeCompensationsType' from JSON`,
  );
}

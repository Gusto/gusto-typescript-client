/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";
import {
  PayrollCompanyTaxesType,
  PayrollCompanyTaxesType$inboundSchema,
} from "./payroll-company-taxes-type.js";
import {
  PayrollCreditBlockerType,
  PayrollCreditBlockerType$inboundSchema,
} from "./payroll-credit-blocker-type.js";
import {
  PayrollEmployeeCompensationsType,
  PayrollEmployeeCompensationsType$inboundSchema,
} from "./payroll-employee-compensations-type.js";
import {
  PayrollFixedCompensationTypesType,
  PayrollFixedCompensationTypesType$inboundSchema,
} from "./payroll-fixed-compensation-types-type.js";
import {
  PayrollPayPeriodType,
  PayrollPayPeriodType$inboundSchema,
} from "./payroll-pay-period-type.js";
import {
  PayrollPaymentSpeedChangedType,
  PayrollPaymentSpeedChangedType$inboundSchema,
} from "./payroll-payment-speed-changed-type.js";
import {
  PayrollPayrollStatusMetaType,
  PayrollPayrollStatusMetaType$inboundSchema,
} from "./payroll-payroll-status-meta-type.js";
import {
  PayrollProcessingRequest,
  PayrollProcessingRequest$inboundSchema,
} from "./payroll-processing-request.js";
import {
  PayrollSubmissionBlockerType,
  PayrollSubmissionBlockerType$inboundSchema,
} from "./payroll-submission-blocker-type.js";
import {
  PayrollTaxesType,
  PayrollTaxesType$inboundSchema,
} from "./payroll-taxes-type.js";
import {
  PayrollTotalsType,
  PayrollTotalsType$inboundSchema,
} from "./payroll-totals-type.js";
import {
  PayrollWithholdingPayPeriodType,
  PayrollWithholdingPayPeriodType$inboundSchema,
} from "./payroll-withholding-pay-period-type.js";

export const OffCycleReasonType = {
  Adhoc: "Adhoc",
  BenefitReversal: "Benefit reversal",
  Bonus: "Bonus",
  Correction: "Correction",
  DismissedEmployee: "Dismissed employee",
  HiredEmployee: "Hired employee",
  WageCorrection: "Wage correction",
  TaxReconciliation: "Tax reconciliation",
  Reversal: "Reversal",
  DisabilityInsuranceDistribution: "Disability insurance distribution",
  TransitionFromOldPaySchedule: "Transition from old pay schedule",
} as const;
export type OffCycleReasonType = OpenEnum<typeof OffCycleReasonType>;

export type Payroll = {
  /**
   * A timestamp that is the deadline for the payroll to be run in order for employees to be paid on time.  If payroll has not been run by the deadline, a prepare request will update both the check date and deadline to reflect the soonest employees can be paid and the deadline by which the payroll must be run in order for said check date to be met.
   */
  payrollDeadline?: Date | undefined;
  /**
   * The date on which employees will be paid for the payroll.
   */
  checkDate?: string | undefined;
  /**
   * Whether or not the payroll has been successfully processed. Note that processed payrolls cannot be updated. Additionally, a payroll is not guaranteed to be processed just because the payroll deadline has passed. Late payrolls are not uncommon. Conversely, users may choose to run payroll before the payroll deadline.
   */
  processed?: boolean | undefined;
  /**
   * The date at which the payroll was processed. Null if the payroll isn't processed yet.
   */
  processedDate?: string | null | undefined;
  /**
   * A timestamp of the last valid payroll calculation. Null if there isn't a valid calculation.
   */
  calculatedAt?: Date | null | undefined;
  /**
   * The UUID of the payroll.
   */
  uuid?: string | undefined;
  /**
   * The UUID of the payroll.
   */
  payrollUuid?: string | undefined;
  /**
   * The UUID of the company for the payroll.
   */
  companyUuid?: string | undefined;
  /**
   * Indicates whether the payroll is an off-cycle payroll
   */
  offCycle?: boolean | undefined;
  /**
   * The off-cycle reason. Only included for off-cycle payrolls.
   */
  offCycleReason?: OffCycleReasonType | null | undefined;
  /**
   * Indicates whether the payroll is an auto pilot payroll
   */
  autoPilot?: boolean | undefined;
  /**
   * Indicates whether the payroll is an external payroll
   */
  external?: boolean | undefined;
  /**
   * Indicates whether the payroll is the final payroll for a terminated employee. Only included for off-cycle payrolls.
   */
  finalTerminationPayroll?: boolean | undefined;
  /**
   * The payment schedule tax rate the payroll is based on. Only included for off-cycle payrolls.
   */
  withholdingPayPeriod?: PayrollWithholdingPayPeriodType | undefined;
  /**
   * Block regular deductions and contributions for this payroll.  Only included for off-cycle payrolls.
   */
  skipRegularDeductions?: boolean | null | undefined;
  /**
   * Enable taxes to be withheld at the IRS's required rate of 22% for federal income taxes. State income taxes will be taxed at the state's supplemental tax rate. Otherwise, we'll sum the entirety of the employee's wages and withhold taxes on the entire amount at the rate for regular wages. Only included for off-cycle payrolls.
   */
  fixedWithholdingRate?: boolean | null | undefined;
  payPeriod?: PayrollPayPeriodType | undefined;
  /**
   * Information about the payroll's status and expected dates
   */
  payrollStatusMeta?: PayrollPayrollStatusMetaType | undefined;
  /**
   * The subtotals for the payroll.
   */
  totals?: PayrollTotalsType | undefined;
  /**
   * An array of taxes applicable to this payroll in addition to taxes included in `employee_compensations`. Only included for processed or calculated payrolls when `taxes` is present in the `include` parameter.
   */
  companyTaxes?: Array<PayrollCompanyTaxesType> | undefined;
  /**
   * An array of tax totals applicable to this payroll. Only included for processed or calculated payrolls when `payroll_taxes` is present in the `include` parameter.
   */
  payrollTaxes?: Array<PayrollTaxesType> | undefined;
  /**
   * Only applicable when a payroll is moved to four day processing instead of fast ach.
   */
  paymentSpeedChanged?: PayrollPaymentSpeedChangedType | undefined;
  /**
   * Datetime for when the resource was created.
   */
  createdAt?: Date | undefined;
  /**
   * Only included for processed or calculated payrolls
   */
  submissionBlockers?: Array<PayrollSubmissionBlockerType> | undefined;
  /**
   * Only included for processed payrolls
   */
  creditBlockers?: Array<PayrollCreditBlockerType> | undefined;
  processingRequest?: PayrollProcessingRequest | null | undefined;
  /**
   * Will money movement for the payroll be performed by the partner rather than by Gusto?
   */
  partnerOwnedDisbursement?: boolean | null | undefined;
};

/**
 * A prepared payroll
 */
export type PayrollPrepared = {
  /**
   * A timestamp that is the deadline for the payroll to be run in order for employees to be paid on time.  If payroll has not been run by the deadline, a prepare request will update both the check date and deadline to reflect the soonest employees can be paid and the deadline by which the payroll must be run in order for said check date to be met.
   */
  payrollDeadline?: Date | undefined;
  /**
   * The date on which employees will be paid for the payroll.
   */
  checkDate?: string | undefined;
  /**
   * Whether or not the payroll has been successfully processed. Note that processed payrolls cannot be updated. Additionally, a payroll is not guaranteed to be processed just because the payroll deadline has passed. Late payrolls are not uncommon. Conversely, users may choose to run payroll before the payroll deadline.
   */
  processed?: boolean | undefined;
  /**
   * The date at which the payroll was processed. Null if the payroll isn't processed yet.
   */
  processedDate?: string | null | undefined;
  /**
   * A timestamp of the last valid payroll calculation. Null if there isn't a valid calculation.
   */
  calculatedAt?: Date | null | undefined;
  /**
   * The UUID of the payroll.
   */
  uuid?: string | undefined;
  /**
   * The UUID of the payroll.
   */
  payrollUuid?: string | undefined;
  /**
   * The UUID of the company for the payroll.
   */
  companyUuid?: string | undefined;
  /**
   * Indicates whether the payroll is an off-cycle payroll
   */
  offCycle?: boolean | undefined;
  /**
   * The off-cycle reason. Only included for off-cycle payrolls.
   */
  offCycleReason?: OffCycleReasonType | null | undefined;
  /**
   * Indicates whether the payroll is an auto pilot payroll
   */
  autoPilot?: boolean | undefined;
  /**
   * Indicates whether the payroll is an external payroll
   */
  external?: boolean | undefined;
  /**
   * Indicates whether the payroll is the final payroll for a terminated employee. Only included for off-cycle payrolls.
   */
  finalTerminationPayroll?: boolean | undefined;
  /**
   * The payment schedule tax rate the payroll is based on. Only included for off-cycle payrolls.
   */
  withholdingPayPeriod?: PayrollWithholdingPayPeriodType | undefined;
  /**
   * Block regular deductions and contributions for this payroll.  Only included for off-cycle payrolls.
   */
  skipRegularDeductions?: boolean | null | undefined;
  /**
   * Enable taxes to be withheld at the IRS's required rate of 22% for federal income taxes. State income taxes will be taxed at the state's supplemental tax rate. Otherwise, we'll sum the entirety of the employee's wages and withhold taxes on the entire amount at the rate for regular wages. Only included for off-cycle payrolls.
   */
  fixedWithholdingRate?: boolean | null | undefined;
  payPeriod?: PayrollPayPeriodType | undefined;
  /**
   * Information about the payroll's status and expected dates
   */
  payrollStatusMeta?: PayrollPayrollStatusMetaType | undefined;
  employeeCompensations?: Array<PayrollEmployeeCompensationsType> | undefined;
  /**
   * Only applicable when a payroll is moved to four day processing instead of fast ach.
   */
  paymentSpeedChanged?: PayrollPaymentSpeedChangedType | undefined;
  /**
   * Datetime for when the resource was created.
   */
  createdAt?: Date | undefined;
  fixedCompensationTypes?: Array<PayrollFixedCompensationTypesType> | undefined;
  processingRequest?: PayrollProcessingRequest | null | undefined;
  /**
   * Will money movement for the payroll be performed by the partner rather than by Gusto?
   */
  partnerOwnedDisbursement?: boolean | null | undefined;
};

/**
 * The employee's compensation payment method. Is *only* `Historical` when retrieving external payrolls initially run outside of Gusto, then put into Gusto.
 */
export const PayrollShowPaymentMethod = {
  DirectDeposit: "Direct Deposit",
  Check: "Check",
  Historical: "Historical",
} as const;
/**
 * The employee's compensation payment method. Is *only* `Historical` when retrieving external payrolls initially run outside of Gusto, then put into Gusto.
 */
export type PayrollShowPaymentMethod = OpenEnum<
  typeof PayrollShowPaymentMethod
>;

export type PayrollShowFixedCompensation = {
  /**
   * The name of the compensation. This also serves as the unique, immutable identifier for this compensation.
   */
  name?: string | undefined;
  /**
   * The amount of the compensation for the pay period.
   */
  amount?: string | undefined;
  /**
   * The UUID of the job for the compensation.
   */
  jobUuid?: string | undefined;
};

export type PayrollShowHourlyCompensation = {
  /**
   * The name of the compensation. This also serves as the unique, immutable identifier for this compensation.
   */
  name?: string | undefined;
  /**
   * The number of hours to be compensated for this pay period.
   */
  hours?: string | undefined;
  /**
   * The amount of the compensation. This field is only available after the payroll is calculated and cannot be used for updating hourly compensations.
   */
  amount?: string | undefined;
  /**
   * The UUID of the job for the compensation.
   */
  jobUuid?: string | undefined;
  /**
   * The amount multiplied by the base rate to calculate total compensation per hour worked.
   */
  compensationMultiplier?: number | undefined;
  /**
   * The FLSA Status of the employee's primary job compensation
   */
  flsaStatus?: string | undefined;
};

export type PayrollShowPaidTimeOff = {
  /**
   * The name of the PTO. This also serves as the unique, immutable identifier for the PTO.
   */
  name?: string | undefined;
  /**
   * The hours of this PTO taken during the pay period.
   */
  hours?: string | undefined;
  /**
   * The outstanding hours paid upon termination. This field is only applicable for termination payrolls.
   */
  finalPayoutUnusedHoursInput?: string | undefined;
};

/**
 * The amount type of the deduction for the pay period. Only present for calculated or processed payrolls.
 */
export const PayrollShowAmountType = {
  Fixed: "fixed",
  Percent: "percent",
} as const;
/**
 * The amount type of the deduction for the pay period. Only present for calculated or processed payrolls.
 */
export type PayrollShowAmountType = OpenEnum<typeof PayrollShowAmountType>;

export type PayrollShowDeduction = {
  /**
   * The name of the deduction.
   */
  name?: string | undefined;
  /**
   * The amount of the deduction for the pay period.
   */
  amount?: number | undefined;
  /**
   * The amount type of the deduction for the pay period. Only present for calculated or processed payrolls.
   */
  amountType?: PayrollShowAmountType | undefined;
  /**
   * The UUID of the deduction. Only present for calculated or processed payrolls.
   */
  uuid?: string | undefined;
};

export type PayrollShowReimbursement = {
  /**
   * The dollar amount of the reimbursement for the pay period.
   */
  amount: string;
  /**
   * The description of the reimbursement. Null for unnamed reimbursements.
   */
  description: string | null;
  /**
   * The UUID of the reimbursement. Null for unnamed reimbursements. This field is only available for unprocessed payrolls.
   */
  uuid?: string | null | undefined;
  /**
   * Whether the reimbursement is recurring. This field is only available for unprocessed payrolls.
   */
  recurring?: boolean | undefined;
};

export type PayrollShowTax = {
  name: string;
  employer: boolean;
  amount: number;
};

export type PayrollShowBenefit = {
  name?: string | undefined;
  employeeDeduction?: number | undefined;
  companyContribution?: number | undefined;
  imputed?: boolean | undefined;
};

export type PayrollShowEmployeeCompensation = {
  /**
   * The UUID of the employee.
   */
  employeeUuid?: string | undefined;
  /**
   * This employee will be excluded (skipped) from payroll calculation and will not be paid for the payroll. Cancelling a payroll would reset all employees' excluded back to false.
   */
  excluded?: boolean | undefined;
  /**
   * The current version of this employee compensation. This field is only available for prepared payrolls. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
   */
  version?: string | undefined;
  /**
   * The first name of the employee. Requires `employees:read` scope.
   */
  firstName?: string | null | undefined;
  /**
   * The preferred first name of the employee. Requires `employees:read` scope.
   */
  preferredFirstName?: string | null | undefined;
  /**
   * The last name of the employee. Requires `employees:read` scope.
   */
  lastName?: string | null | undefined;
  /**
   * The employee's gross pay, equal to regular wages + cash tips + payroll tips + any other additional earnings, excluding imputed income. This value is only available for processed payrolls.
   */
  grossPay?: number | null | undefined;
  /**
   * The employee's net pay, equal to gross_pay - employee taxes - employee deductions or garnishments - cash tips. This value is only available for processed payrolls.
   */
  netPay?: number | null | undefined;
  /**
   * The employee's check amount, equal to net_pay + reimbursements. This value is only available for processed payrolls.
   */
  checkAmount?: number | null | undefined;
  /**
   * The employee's compensation payment method. Is *only* `Historical` when retrieving external payrolls initially run outside of Gusto, then put into Gusto.
   */
  paymentMethod?: PayrollShowPaymentMethod | null | undefined;
  /**
   * Custom text that will be printed as a personal note to the employee on a paystub.
   */
  memo?: string | null | undefined;
  /**
   * An array of fixed compensations for the employee. Fixed compensations include tips, bonuses, and one time reimbursements. If this payroll has been processed, only fixed compensations with a value greater than 0.00 are returned. For an unprocessed payroll, all active fixed compensations are returned.
   */
  fixedCompensations?: Array<PayrollShowFixedCompensation> | undefined;
  /**
   * An array of hourly compensations for the employee. Hourly compensations include regular, overtime, and double overtime hours. If this payroll has been processed, only hourly compensations with a value greater than 0.00 are returned. For an unprocessed payroll, all active hourly compensations are returned.
   */
  hourlyCompensations?: Array<PayrollShowHourlyCompensation> | undefined;
  /**
   * An array of all paid time off the employee is eligible for this pay period.
   */
  paidTimeOff?: Array<PayrollShowPaidTimeOff> | undefined;
  /**
   * An array of employee deductions for the pay period.
   */
  deductions?: Array<PayrollShowDeduction> | undefined;
  /**
   * An array of reimbursements for the employee.
   */
  reimbursements?: Array<PayrollShowReimbursement> | undefined;
  /**
   * An array of employer and employee taxes for the pay period. Only included for processed or calculated payrolls when `taxes` is present in the `include` parameter.
   */
  taxes?: Array<PayrollShowTax> | undefined;
  /**
   * An array of employee benefits for the pay period. Benefits are only included for processed payroll when the include parameter is present.
   */
  benefits?: Array<PayrollShowBenefit> | undefined;
};

export type PayrollShow = {
  /**
   * A timestamp that is the deadline for the payroll to be run in order for employees to be paid on time.  If payroll has not been run by the deadline, a prepare request will update both the check date and deadline to reflect the soonest employees can be paid and the deadline by which the payroll must be run in order for said check date to be met.
   */
  payrollDeadline?: Date | undefined;
  /**
   * The date on which employees will be paid for the payroll.
   */
  checkDate?: string | undefined;
  /**
   * Whether or not the payroll has been successfully processed. Note that processed payrolls cannot be updated. Additionally, a payroll is not guaranteed to be processed just because the payroll deadline has passed. Late payrolls are not uncommon. Conversely, users may choose to run payroll before the payroll deadline.
   */
  processed?: boolean | undefined;
  /**
   * The date at which the payroll was processed. Null if the payroll isn't processed yet.
   */
  processedDate?: string | null | undefined;
  /**
   * A timestamp of the last valid payroll calculation. Null if there isn't a valid calculation.
   */
  calculatedAt?: Date | null | undefined;
  /**
   * The UUID of the payroll.
   */
  uuid?: string | undefined;
  /**
   * The UUID of the payroll.
   */
  payrollUuid?: string | undefined;
  /**
   * The UUID of the company for the payroll.
   */
  companyUuid?: string | undefined;
  /**
   * Indicates whether the payroll is an off-cycle payroll
   */
  offCycle?: boolean | undefined;
  /**
   * The off-cycle reason. Only included for off-cycle payrolls.
   */
  offCycleReason?: OffCycleReasonType | null | undefined;
  /**
   * Indicates whether the payroll is an auto pilot payroll
   */
  autoPilot?: boolean | undefined;
  /**
   * Indicates whether the payroll is an external payroll
   */
  external?: boolean | undefined;
  /**
   * Indicates whether the payroll is the final payroll for a terminated employee. Only included for off-cycle payrolls.
   */
  finalTerminationPayroll?: boolean | undefined;
  /**
   * The payment schedule tax rate the payroll is based on. Only included for off-cycle payrolls.
   */
  withholdingPayPeriod?: PayrollWithholdingPayPeriodType | undefined;
  /**
   * Block regular deductions and contributions for this payroll.  Only included for off-cycle payrolls.
   */
  skipRegularDeductions?: boolean | null | undefined;
  /**
   * Enable taxes to be withheld at the IRS's required rate of 22% for federal income taxes. State income taxes will be taxed at the state's supplemental tax rate. Otherwise, we'll sum the entirety of the employee's wages and withhold taxes on the entire amount at the rate for regular wages. Only included for off-cycle payrolls.
   */
  fixedWithholdingRate?: boolean | null | undefined;
  payPeriod?: PayrollPayPeriodType | undefined;
  /**
   * Information about the payroll's status and expected dates
   */
  payrollStatusMeta?: PayrollPayrollStatusMetaType | undefined;
  /**
   * The subtotals for the payroll.
   */
  totals?: PayrollTotalsType | undefined;
  /**
   * An array of taxes applicable to this payroll in addition to taxes included in `employee_compensations`. Only included for processed or calculated payrolls when `taxes` is present in the `include` parameter.
   */
  companyTaxes?: Array<PayrollCompanyTaxesType> | undefined;
  /**
   * An array of tax totals applicable to this payroll. Only included for processed or calculated payrolls when `payroll_taxes` is present in the `include` parameter.
   */
  payrollTaxes?: Array<PayrollTaxesType> | undefined;
  /**
   * Only applicable when a payroll is moved to four day processing instead of fast ach.
   */
  paymentSpeedChanged?: PayrollPaymentSpeedChangedType | undefined;
  /**
   * Datetime for when the resource was created.
   */
  createdAt?: Date | undefined;
  /**
   * Only included for processed or calculated payrolls
   */
  submissionBlockers?: Array<PayrollSubmissionBlockerType> | undefined;
  /**
   * Only included for processed payrolls
   */
  creditBlockers?: Array<PayrollCreditBlockerType> | undefined;
  processingRequest?: PayrollProcessingRequest | null | undefined;
  /**
   * Will money movement for the payroll be performed by the partner rather than by Gusto?
   */
  partnerOwnedDisbursement?: boolean | null | undefined;
  employeeCompensations?: Array<PayrollShowEmployeeCompensation> | undefined;
};

/**
 * A payroll that has been transitioned back to unprocessed state after cancellation.
 */
export type UnprocessedPayroll = {
  /**
   * A timestamp that is the deadline for the payroll to be run in order for employees to be paid on time.  If payroll has not been run by the deadline, a prepare request will update both the check date and deadline to reflect the soonest employees can be paid and the deadline by which the payroll must be run in order for said check date to be met.
   */
  payrollDeadline?: Date | undefined;
  /**
   * The date on which employees will be paid for the payroll.
   */
  checkDate?: string | undefined;
  /**
   * Whether or not the payroll has been successfully processed. Note that processed payrolls cannot be updated. Additionally, a payroll is not guaranteed to be processed just because the payroll deadline has passed. Late payrolls are not uncommon. Conversely, users may choose to run payroll before the payroll deadline.
   */
  processed?: boolean | undefined;
  /**
   * The date at which the payroll was processed. Null if the payroll isn't processed yet.
   */
  processedDate?: string | null | undefined;
  /**
   * A timestamp of the last valid payroll calculation. Null if there isn't a valid calculation.
   */
  calculatedAt?: Date | null | undefined;
  /**
   * The UUID of the payroll.
   */
  uuid?: string | undefined;
  /**
   * The UUID of the payroll.
   */
  payrollUuid?: string | undefined;
  /**
   * The UUID of the company for the payroll.
   */
  companyUuid?: string | undefined;
  /**
   * Indicates whether the payroll is an off-cycle payroll
   */
  offCycle?: boolean | undefined;
  /**
   * The off-cycle reason. Only included for off-cycle payrolls.
   */
  offCycleReason?: OffCycleReasonType | null | undefined;
  /**
   * Indicates whether the payroll is an auto pilot payroll
   */
  autoPilot?: boolean | undefined;
  /**
   * Indicates whether the payroll is an external payroll
   */
  external?: boolean | undefined;
  payPeriod?: PayrollPayPeriodType | undefined;
  /**
   * Datetime for when the resource was created.
   */
  createdAt?: Date | undefined;
  /**
   * Will money movement for the payroll be performed by the partner rather than by Gusto?
   */
  partnerOwnedDisbursement?: boolean | null | undefined;
};

/** @internal */
export const OffCycleReasonType$inboundSchema: z.ZodMiniType<
  OffCycleReasonType,
  unknown
> = openEnums.inboundSchema(OffCycleReasonType);

/** @internal */
export const Payroll$inboundSchema: z.ZodMiniType<Payroll, unknown> = z.pipe(
  z.object({
    payroll_deadline: types.optional(types.date()),
    check_date: types.optional(types.string()),
    processed: types.optional(types.boolean()),
    processed_date: z.optional(z.nullable(types.string())),
    calculated_at: z.optional(z.nullable(types.date())),
    uuid: types.optional(types.string()),
    payroll_uuid: types.optional(types.string()),
    company_uuid: types.optional(types.string()),
    off_cycle: types.optional(types.boolean()),
    off_cycle_reason: z.optional(z.nullable(OffCycleReasonType$inboundSchema)),
    auto_pilot: types.optional(types.boolean()),
    external: types.optional(types.boolean()),
    final_termination_payroll: types.optional(types.boolean()),
    withholding_pay_period: types.optional(
      PayrollWithholdingPayPeriodType$inboundSchema,
    ),
    skip_regular_deductions: z.optional(z.nullable(types.boolean())),
    fixed_withholding_rate: z.optional(z.nullable(types.boolean())),
    pay_period: types.optional(PayrollPayPeriodType$inboundSchema),
    payroll_status_meta: types.optional(
      PayrollPayrollStatusMetaType$inboundSchema,
    ),
    totals: types.optional(PayrollTotalsType$inboundSchema),
    company_taxes: types.optional(
      z.array(PayrollCompanyTaxesType$inboundSchema),
    ),
    payroll_taxes: types.optional(z.array(PayrollTaxesType$inboundSchema)),
    payment_speed_changed: types.optional(
      PayrollPaymentSpeedChangedType$inboundSchema,
    ),
    created_at: types.optional(types.date()),
    submission_blockers: types.optional(
      z.array(PayrollSubmissionBlockerType$inboundSchema),
    ),
    credit_blockers: types.optional(
      z.array(PayrollCreditBlockerType$inboundSchema),
    ),
    processing_request: z.optional(
      z.nullable(PayrollProcessingRequest$inboundSchema),
    ),
    partner_owned_disbursement: z.optional(z.nullable(types.boolean())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "payroll_deadline": "payrollDeadline",
      "check_date": "checkDate",
      "processed_date": "processedDate",
      "calculated_at": "calculatedAt",
      "payroll_uuid": "payrollUuid",
      "company_uuid": "companyUuid",
      "off_cycle": "offCycle",
      "off_cycle_reason": "offCycleReason",
      "auto_pilot": "autoPilot",
      "final_termination_payroll": "finalTerminationPayroll",
      "withholding_pay_period": "withholdingPayPeriod",
      "skip_regular_deductions": "skipRegularDeductions",
      "fixed_withholding_rate": "fixedWithholdingRate",
      "pay_period": "payPeriod",
      "payroll_status_meta": "payrollStatusMeta",
      "company_taxes": "companyTaxes",
      "payroll_taxes": "payrollTaxes",
      "payment_speed_changed": "paymentSpeedChanged",
      "created_at": "createdAt",
      "submission_blockers": "submissionBlockers",
      "credit_blockers": "creditBlockers",
      "processing_request": "processingRequest",
      "partner_owned_disbursement": "partnerOwnedDisbursement",
    });
  }),
);

export function payrollFromJSON(
  jsonString: string,
): SafeParseResult<Payroll, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Payroll$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Payroll' from JSON`,
  );
}

/** @internal */
export const PayrollPrepared$inboundSchema: z.ZodMiniType<
  PayrollPrepared,
  unknown
> = z.pipe(
  z.object({
    payroll_deadline: types.optional(types.date()),
    check_date: types.optional(types.string()),
    processed: types.optional(types.boolean()),
    processed_date: z.optional(z.nullable(types.string())),
    calculated_at: z.optional(z.nullable(types.date())),
    uuid: types.optional(types.string()),
    payroll_uuid: types.optional(types.string()),
    company_uuid: types.optional(types.string()),
    off_cycle: types.optional(types.boolean()),
    off_cycle_reason: z.optional(z.nullable(OffCycleReasonType$inboundSchema)),
    auto_pilot: types.optional(types.boolean()),
    external: types.optional(types.boolean()),
    final_termination_payroll: types.optional(types.boolean()),
    withholding_pay_period: types.optional(
      PayrollWithholdingPayPeriodType$inboundSchema,
    ),
    skip_regular_deductions: z.optional(z.nullable(types.boolean())),
    fixed_withholding_rate: z.optional(z.nullable(types.boolean())),
    pay_period: types.optional(PayrollPayPeriodType$inboundSchema),
    payroll_status_meta: types.optional(
      PayrollPayrollStatusMetaType$inboundSchema,
    ),
    employee_compensations: types.optional(
      z.array(PayrollEmployeeCompensationsType$inboundSchema),
    ),
    payment_speed_changed: types.optional(
      PayrollPaymentSpeedChangedType$inboundSchema,
    ),
    created_at: types.optional(types.date()),
    fixed_compensation_types: types.optional(
      z.array(PayrollFixedCompensationTypesType$inboundSchema),
    ),
    processing_request: z.optional(
      z.nullable(PayrollProcessingRequest$inboundSchema),
    ),
    partner_owned_disbursement: z.optional(z.nullable(types.boolean())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "payroll_deadline": "payrollDeadline",
      "check_date": "checkDate",
      "processed_date": "processedDate",
      "calculated_at": "calculatedAt",
      "payroll_uuid": "payrollUuid",
      "company_uuid": "companyUuid",
      "off_cycle": "offCycle",
      "off_cycle_reason": "offCycleReason",
      "auto_pilot": "autoPilot",
      "final_termination_payroll": "finalTerminationPayroll",
      "withholding_pay_period": "withholdingPayPeriod",
      "skip_regular_deductions": "skipRegularDeductions",
      "fixed_withholding_rate": "fixedWithholdingRate",
      "pay_period": "payPeriod",
      "payroll_status_meta": "payrollStatusMeta",
      "employee_compensations": "employeeCompensations",
      "payment_speed_changed": "paymentSpeedChanged",
      "created_at": "createdAt",
      "fixed_compensation_types": "fixedCompensationTypes",
      "processing_request": "processingRequest",
      "partner_owned_disbursement": "partnerOwnedDisbursement",
    });
  }),
);

export function payrollPreparedFromJSON(
  jsonString: string,
): SafeParseResult<PayrollPrepared, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayrollPrepared$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayrollPrepared' from JSON`,
  );
}

/** @internal */
export const PayrollShowPaymentMethod$inboundSchema: z.ZodMiniType<
  PayrollShowPaymentMethod,
  unknown
> = openEnums.inboundSchema(PayrollShowPaymentMethod);

/** @internal */
export const PayrollShowFixedCompensation$inboundSchema: z.ZodMiniType<
  PayrollShowFixedCompensation,
  unknown
> = z.pipe(
  z.object({
    name: types.optional(types.string()),
    amount: types.optional(types.string()),
    job_uuid: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "job_uuid": "jobUuid",
    });
  }),
);

export function payrollShowFixedCompensationFromJSON(
  jsonString: string,
): SafeParseResult<PayrollShowFixedCompensation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayrollShowFixedCompensation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayrollShowFixedCompensation' from JSON`,
  );
}

/** @internal */
export const PayrollShowHourlyCompensation$inboundSchema: z.ZodMiniType<
  PayrollShowHourlyCompensation,
  unknown
> = z.pipe(
  z.object({
    name: types.optional(types.string()),
    hours: types.optional(types.string()),
    amount: types.optional(types.string()),
    job_uuid: types.optional(types.string()),
    compensation_multiplier: types.optional(types.number()),
    flsa_status: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "job_uuid": "jobUuid",
      "compensation_multiplier": "compensationMultiplier",
      "flsa_status": "flsaStatus",
    });
  }),
);

export function payrollShowHourlyCompensationFromJSON(
  jsonString: string,
): SafeParseResult<PayrollShowHourlyCompensation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayrollShowHourlyCompensation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayrollShowHourlyCompensation' from JSON`,
  );
}

/** @internal */
export const PayrollShowPaidTimeOff$inboundSchema: z.ZodMiniType<
  PayrollShowPaidTimeOff,
  unknown
> = z.pipe(
  z.object({
    name: types.optional(types.string()),
    hours: types.optional(types.string()),
    final_payout_unused_hours_input: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "final_payout_unused_hours_input": "finalPayoutUnusedHoursInput",
    });
  }),
);

export function payrollShowPaidTimeOffFromJSON(
  jsonString: string,
): SafeParseResult<PayrollShowPaidTimeOff, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayrollShowPaidTimeOff$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayrollShowPaidTimeOff' from JSON`,
  );
}

/** @internal */
export const PayrollShowAmountType$inboundSchema: z.ZodMiniType<
  PayrollShowAmountType,
  unknown
> = openEnums.inboundSchema(PayrollShowAmountType);

/** @internal */
export const PayrollShowDeduction$inboundSchema: z.ZodMiniType<
  PayrollShowDeduction,
  unknown
> = z.pipe(
  z.object({
    name: types.optional(types.string()),
    amount: types.optional(types.number()),
    amount_type: types.optional(PayrollShowAmountType$inboundSchema),
    uuid: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "amount_type": "amountType",
    });
  }),
);

export function payrollShowDeductionFromJSON(
  jsonString: string,
): SafeParseResult<PayrollShowDeduction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayrollShowDeduction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayrollShowDeduction' from JSON`,
  );
}

/** @internal */
export const PayrollShowReimbursement$inboundSchema: z.ZodMiniType<
  PayrollShowReimbursement,
  unknown
> = z.object({
  amount: types.string(),
  description: types.nullable(types.string()),
  uuid: z.optional(z.nullable(types.string())),
  recurring: types.optional(types.boolean()),
});

export function payrollShowReimbursementFromJSON(
  jsonString: string,
): SafeParseResult<PayrollShowReimbursement, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayrollShowReimbursement$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayrollShowReimbursement' from JSON`,
  );
}

/** @internal */
export const PayrollShowTax$inboundSchema: z.ZodMiniType<
  PayrollShowTax,
  unknown
> = z.object({
  name: types.string(),
  employer: types.boolean(),
  amount: types.number(),
});

export function payrollShowTaxFromJSON(
  jsonString: string,
): SafeParseResult<PayrollShowTax, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayrollShowTax$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayrollShowTax' from JSON`,
  );
}

/** @internal */
export const PayrollShowBenefit$inboundSchema: z.ZodMiniType<
  PayrollShowBenefit,
  unknown
> = z.pipe(
  z.object({
    name: types.optional(types.string()),
    employee_deduction: types.optional(types.number()),
    company_contribution: types.optional(types.number()),
    imputed: types.optional(types.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "employee_deduction": "employeeDeduction",
      "company_contribution": "companyContribution",
    });
  }),
);

export function payrollShowBenefitFromJSON(
  jsonString: string,
): SafeParseResult<PayrollShowBenefit, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayrollShowBenefit$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayrollShowBenefit' from JSON`,
  );
}

/** @internal */
export const PayrollShowEmployeeCompensation$inboundSchema: z.ZodMiniType<
  PayrollShowEmployeeCompensation,
  unknown
> = z.pipe(
  z.object({
    employee_uuid: types.optional(types.string()),
    excluded: types.optional(types.boolean()),
    version: types.optional(types.string()),
    first_name: z.optional(z.nullable(types.string())),
    preferred_first_name: z.optional(z.nullable(types.string())),
    last_name: z.optional(z.nullable(types.string())),
    gross_pay: z.optional(z.nullable(types.number())),
    net_pay: z.optional(z.nullable(types.number())),
    check_amount: z.optional(z.nullable(types.number())),
    payment_method: z.optional(
      z.nullable(PayrollShowPaymentMethod$inboundSchema),
    ),
    memo: z.optional(z.nullable(types.string())),
    fixed_compensations: types.optional(
      z.array(z.lazy(() => PayrollShowFixedCompensation$inboundSchema)),
    ),
    hourly_compensations: types.optional(
      z.array(z.lazy(() => PayrollShowHourlyCompensation$inboundSchema)),
    ),
    paid_time_off: types.optional(
      z.array(z.lazy(() => PayrollShowPaidTimeOff$inboundSchema)),
    ),
    deductions: types.optional(
      z.array(z.lazy(() => PayrollShowDeduction$inboundSchema)),
    ),
    reimbursements: types.optional(
      z.array(z.lazy(() => PayrollShowReimbursement$inboundSchema)),
    ),
    taxes: types.optional(z.array(z.lazy(() => PayrollShowTax$inboundSchema))),
    benefits: types.optional(
      z.array(z.lazy(() => PayrollShowBenefit$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "employee_uuid": "employeeUuid",
      "first_name": "firstName",
      "preferred_first_name": "preferredFirstName",
      "last_name": "lastName",
      "gross_pay": "grossPay",
      "net_pay": "netPay",
      "check_amount": "checkAmount",
      "payment_method": "paymentMethod",
      "fixed_compensations": "fixedCompensations",
      "hourly_compensations": "hourlyCompensations",
      "paid_time_off": "paidTimeOff",
    });
  }),
);

export function payrollShowEmployeeCompensationFromJSON(
  jsonString: string,
): SafeParseResult<PayrollShowEmployeeCompensation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayrollShowEmployeeCompensation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayrollShowEmployeeCompensation' from JSON`,
  );
}

/** @internal */
export const PayrollShow$inboundSchema: z.ZodMiniType<PayrollShow, unknown> = z
  .pipe(
    z.object({
      payroll_deadline: types.optional(types.date()),
      check_date: types.optional(types.string()),
      processed: types.optional(types.boolean()),
      processed_date: z.optional(z.nullable(types.string())),
      calculated_at: z.optional(z.nullable(types.date())),
      uuid: types.optional(types.string()),
      payroll_uuid: types.optional(types.string()),
      company_uuid: types.optional(types.string()),
      off_cycle: types.optional(types.boolean()),
      off_cycle_reason: z.optional(
        z.nullable(OffCycleReasonType$inboundSchema),
      ),
      auto_pilot: types.optional(types.boolean()),
      external: types.optional(types.boolean()),
      final_termination_payroll: types.optional(types.boolean()),
      withholding_pay_period: types.optional(
        PayrollWithholdingPayPeriodType$inboundSchema,
      ),
      skip_regular_deductions: z.optional(z.nullable(types.boolean())),
      fixed_withholding_rate: z.optional(z.nullable(types.boolean())),
      pay_period: types.optional(PayrollPayPeriodType$inboundSchema),
      payroll_status_meta: types.optional(
        PayrollPayrollStatusMetaType$inboundSchema,
      ),
      totals: types.optional(PayrollTotalsType$inboundSchema),
      company_taxes: types.optional(
        z.array(PayrollCompanyTaxesType$inboundSchema),
      ),
      payroll_taxes: types.optional(z.array(PayrollTaxesType$inboundSchema)),
      payment_speed_changed: types.optional(
        PayrollPaymentSpeedChangedType$inboundSchema,
      ),
      created_at: types.optional(types.date()),
      submission_blockers: types.optional(
        z.array(PayrollSubmissionBlockerType$inboundSchema),
      ),
      credit_blockers: types.optional(
        z.array(PayrollCreditBlockerType$inboundSchema),
      ),
      processing_request: z.optional(
        z.nullable(PayrollProcessingRequest$inboundSchema),
      ),
      partner_owned_disbursement: z.optional(z.nullable(types.boolean())),
      employee_compensations: types.optional(
        z.array(z.lazy(() => PayrollShowEmployeeCompensation$inboundSchema)),
      ),
    }),
    z.transform((v) => {
      return remap$(v, {
        "payroll_deadline": "payrollDeadline",
        "check_date": "checkDate",
        "processed_date": "processedDate",
        "calculated_at": "calculatedAt",
        "payroll_uuid": "payrollUuid",
        "company_uuid": "companyUuid",
        "off_cycle": "offCycle",
        "off_cycle_reason": "offCycleReason",
        "auto_pilot": "autoPilot",
        "final_termination_payroll": "finalTerminationPayroll",
        "withholding_pay_period": "withholdingPayPeriod",
        "skip_regular_deductions": "skipRegularDeductions",
        "fixed_withholding_rate": "fixedWithholdingRate",
        "pay_period": "payPeriod",
        "payroll_status_meta": "payrollStatusMeta",
        "company_taxes": "companyTaxes",
        "payroll_taxes": "payrollTaxes",
        "payment_speed_changed": "paymentSpeedChanged",
        "created_at": "createdAt",
        "submission_blockers": "submissionBlockers",
        "credit_blockers": "creditBlockers",
        "processing_request": "processingRequest",
        "partner_owned_disbursement": "partnerOwnedDisbursement",
        "employee_compensations": "employeeCompensations",
      });
    }),
  );

export function payrollShowFromJSON(
  jsonString: string,
): SafeParseResult<PayrollShow, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayrollShow$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayrollShow' from JSON`,
  );
}

/** @internal */
export const UnprocessedPayroll$inboundSchema: z.ZodMiniType<
  UnprocessedPayroll,
  unknown
> = z.pipe(
  z.object({
    payroll_deadline: types.optional(types.date()),
    check_date: types.optional(types.string()),
    processed: types.optional(types.boolean()),
    processed_date: z.optional(z.nullable(types.string())),
    calculated_at: z.optional(z.nullable(types.date())),
    uuid: types.optional(types.string()),
    payroll_uuid: types.optional(types.string()),
    company_uuid: types.optional(types.string()),
    off_cycle: types.optional(types.boolean()),
    off_cycle_reason: z.optional(z.nullable(OffCycleReasonType$inboundSchema)),
    auto_pilot: types.optional(types.boolean()),
    external: types.optional(types.boolean()),
    pay_period: types.optional(PayrollPayPeriodType$inboundSchema),
    created_at: types.optional(types.date()),
    partner_owned_disbursement: z.optional(z.nullable(types.boolean())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "payroll_deadline": "payrollDeadline",
      "check_date": "checkDate",
      "processed_date": "processedDate",
      "calculated_at": "calculatedAt",
      "payroll_uuid": "payrollUuid",
      "company_uuid": "companyUuid",
      "off_cycle": "offCycle",
      "off_cycle_reason": "offCycleReason",
      "auto_pilot": "autoPilot",
      "pay_period": "payPeriod",
      "created_at": "createdAt",
      "partner_owned_disbursement": "partnerOwnedDisbursement",
    });
  }),
);

export function unprocessedPayrollFromJSON(
  jsonString: string,
): SafeParseResult<UnprocessedPayroll, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UnprocessedPayroll$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UnprocessedPayroll' from JSON`,
  );
}

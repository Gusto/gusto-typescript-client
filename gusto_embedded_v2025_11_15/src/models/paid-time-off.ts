/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";

/**
 * The name of the paid time off type.
 */
export const Name = {
  VacationHours: "Vacation Hours",
  SickHours: "Sick Hours",
  HolidayHours: "Holiday Hours",
} as const;
/**
 * The name of the paid time off type.
 */
export type Name = OpenEnum<typeof Name>;

/**
 * The representation of paid time off in Gusto.
 */
export type PaidTimeOff = {
  /**
   * The name of the paid time off type.
   */
  name?: Name | null | undefined;
  /**
   * The name of the time off policy.
   */
  policyName?: string | null | undefined;
  /**
   * The UUID of the time off policy.
   */
  policyUuid?: string | null | undefined;
  /**
   * The unit the PTO type is accrued in.
   */
  accrualUnit?: string | null | undefined;
  /**
   * The number of accrual units accrued per accrual period.
   */
  accrualRate?: string | null | undefined;
  /**
   * The accrual method of the time off policy
   */
  accrualMethod?: string | null | undefined;
  /**
   * The frequency at which the PTO type is accrued.
   */
  accrualPeriod?: string | null | undefined;
  /**
   * The number of accrual units accrued.
   */
  accrualBalance?: string | null | undefined;
  /**
   * The maximum number of accrual units allowed. A null value signifies no maximum.
   */
  maximumAccrualBalance?: string | null | undefined;
  /**
   * Whether the accrual balance is paid to the employee upon termination.
   */
  paidAtTermination?: boolean | undefined;
};

/** @internal */
export const Name$inboundSchema: z.ZodMiniType<Name, unknown> = openEnums
  .inboundSchema(Name);

/** @internal */
export const PaidTimeOff$inboundSchema: z.ZodMiniType<PaidTimeOff, unknown> = z
  .pipe(
    z.object({
      name: z.optional(z.nullable(Name$inboundSchema)),
      policy_name: z.optional(z.nullable(types.string())),
      policy_uuid: z.optional(z.nullable(types.string())),
      accrual_unit: z.optional(z.nullable(types.string())),
      accrual_rate: z.optional(z.nullable(types.string())),
      accrual_method: z.optional(z.nullable(types.string())),
      accrual_period: z.optional(z.nullable(types.string())),
      accrual_balance: z.optional(z.nullable(types.string())),
      maximum_accrual_balance: z.optional(z.nullable(types.string())),
      paid_at_termination: types.optional(types.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "policy_name": "policyName",
        "policy_uuid": "policyUuid",
        "accrual_unit": "accrualUnit",
        "accrual_rate": "accrualRate",
        "accrual_method": "accrualMethod",
        "accrual_period": "accrualPeriod",
        "accrual_balance": "accrualBalance",
        "maximum_accrual_balance": "maximumAccrualBalance",
        "paid_at_termination": "paidAtTermination",
      });
    }),
  );

export function paidTimeOffFromJSON(
  jsonString: string,
): SafeParseResult<PaidTimeOff, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PaidTimeOff$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PaidTimeOff' from JSON`,
  );
}

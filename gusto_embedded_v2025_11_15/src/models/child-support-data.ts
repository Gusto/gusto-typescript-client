/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";

export type FipsCode = {
  /**
   * FIPS code for state or county
   */
  code?: string | undefined;
  /**
   * Name of county in the state for the corresponding FIPS code. When `null` the FIPS code applies state wide.
   */
  county?: string | null | undefined;
};

/**
 * A required attribute when creating a garnishment for this state agency. The current values are listed as an enum; though unlikely, values could be added if state agency requirements change in the future.
 */
export const Key = {
  CaseNumber: "case_number",
  OrderNumber: "order_number",
  RemittanceNumber: "remittance_number",
} as const;
/**
 * A required attribute when creating a garnishment for this state agency. The current values are listed as an enum; though unlikely, values could be added if state agency requirements change in the future.
 */
export type Key = OpenEnum<typeof Key>;

export type RequiredAttribute = {
  /**
   * A required attribute when creating a garnishment for this state agency. The current values are listed as an enum; though unlikely, values could be added if state agency requirements change in the future.
   */
  key?: Key | undefined;
  /**
   * A human readable name of the attribute, e.g. CSE Case Number
   */
  label?: string | undefined;
};

export type Agency = {
  /**
   * Two letter state abbreviation
   */
  state?: string | undefined;
  /**
   * Name of state child support agency
   */
  name?: string | undefined;
  /**
   * Specifies if remitting payment to the agency is required outside of Gusto. If true, Gusto includes garnishment amounts for this agency in payroll calculation, but does not debit for or remit payment to the agency automatically. As of September 2024, only garnishments for South Carolina Integrated Child Support Services require manual payment.
   */
  manualPaymentRequired?: boolean | undefined;
  /**
   * FIPS codes for state or county child support orders
   */
  fipsCodes?: Array<FipsCode> | undefined;
  /**
   * Describes which child support case identifying attributes are required for this agency. While most agencies only require a single identifier, some (e.g. OH) require multiple identifiers.
   */
  requiredAttributes?: Array<RequiredAttribute> | undefined;
};

/**
 * Child Support agency data
 */
export type ChildSupportData = {
  /**
   * State child support agencies
   */
  agencies?: Array<Agency> | undefined;
};

/** @internal */
export const FipsCode$inboundSchema: z.ZodMiniType<FipsCode, unknown> = z
  .object({
    code: types.optional(types.string()),
    county: z.optional(z.nullable(types.string())),
  });

export function fipsCodeFromJSON(
  jsonString: string,
): SafeParseResult<FipsCode, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FipsCode$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FipsCode' from JSON`,
  );
}

/** @internal */
export const Key$inboundSchema: z.ZodMiniType<Key, unknown> = openEnums
  .inboundSchema(Key);

/** @internal */
export const RequiredAttribute$inboundSchema: z.ZodMiniType<
  RequiredAttribute,
  unknown
> = z.object({
  key: types.optional(Key$inboundSchema),
  label: types.optional(types.string()),
});

export function requiredAttributeFromJSON(
  jsonString: string,
): SafeParseResult<RequiredAttribute, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequiredAttribute$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequiredAttribute' from JSON`,
  );
}

/** @internal */
export const Agency$inboundSchema: z.ZodMiniType<Agency, unknown> = z.pipe(
  z.object({
    state: types.optional(types.string()),
    name: types.optional(types.string()),
    manual_payment_required: types.optional(types.boolean()),
    fips_codes: types.optional(z.array(z.lazy(() => FipsCode$inboundSchema))),
    required_attributes: types.optional(z.array(z.lazy(() =>
      RequiredAttribute$inboundSchema
    ))),
  }),
  z.transform((v) => {
    return remap$(v, {
      "manual_payment_required": "manualPaymentRequired",
      "fips_codes": "fipsCodes",
      "required_attributes": "requiredAttributes",
    });
  }),
);

export function agencyFromJSON(
  jsonString: string,
): SafeParseResult<Agency, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Agency$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Agency' from JSON`,
  );
}

/** @internal */
export const ChildSupportData$inboundSchema: z.ZodMiniType<
  ChildSupportData,
  unknown
> = z.object({
  agencies: types.optional(z.array(z.lazy(() => Agency$inboundSchema))),
});

export function childSupportDataFromJSON(
  jsonString: string,
): SafeParseResult<ChildSupportData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChildSupportData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChildSupportData' from JSON`,
  );
}

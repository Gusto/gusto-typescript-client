/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";

/**
 * The subtotals for the contractor payment.
 */
export type ContractorPaymentReceiptTotals = {
  /**
   * The total company debit for the contractor payment.
   */
  companyDebit?: string | undefined;
};

/**
 * The payment method.
 */
export const ContractorPaymentReceiptPaymentMethod = {
  DirectDeposit: "Direct Deposit",
  Check: "Check",
  HistoricalPayment: "Historical Payment",
  CorrectionPayment: "Correction Payment",
} as const;
/**
 * The payment method.
 */
export type ContractorPaymentReceiptPaymentMethod = OpenEnum<
  typeof ContractorPaymentReceiptPaymentMethod
>;

export type ContractorPaymentReceiptContractorPayment = {
  /**
   * The UUID of the contractor.
   */
  contractorUuid?: string | undefined;
  /**
   * The first name of the contractor. Applies when `contractor_type` is `Individual`.
   */
  contractorFirstName?: string | undefined;
  /**
   * The last name of the contractor.  Applies when `contractor_type` is `Individual`.
   */
  contractorLastName?: string | undefined;
  /**
   * The business name of the contractor. Applies when `contractor_type` is `Business`.
   */
  contractorBusinessName?: string | undefined;
  /**
   * The type of contractor.
   *
   * @remarks
   *
   * `Individual` `Business`
   */
  contractorType?: string | undefined;
  /**
   * The payment method.
   */
  paymentMethod?: ContractorPaymentReceiptPaymentMethod | undefined;
  /**
   * The fixed wage of the payment, regardless of hours worked.
   */
  wage?: string | undefined;
  /**
   * The bonus amount in the payment.
   */
  bonus?: string | undefined;
  /**
   * The reimbursement amount in the payment.
   */
  reimbursement?: string | undefined;
};

/**
 * The licensed payroll processor
 */
export type ContractorPaymentReceiptLicensee = {
  /**
   * Always the fixed string "Gusto, Zenpayroll Inc."
   */
  name?: string | undefined;
  /**
   * Always the fixed string "525 20th St"
   */
  address?: string | undefined;
  /**
   * Always the fixed string "San Francisco"
   */
  city?: string | undefined;
  /**
   * Always the fixed string "CA"
   */
  state?: string | undefined;
  /**
   * Always the fixed string "94107"
   */
  postalCode?: string | undefined;
  /**
   * Always the fixed string "4157778888"
   */
  phoneNumber?: string | undefined;
};

/**
 * Example response
 */
export type ContractorPaymentReceipt = {
  /**
   * A unique identifier of the contractor payment receipt.
   */
  contractorPaymentUuid?: string | undefined;
  /**
   * A unique identifier of the company making the contractor payment.
   */
  companyUuid?: string | undefined;
  /**
   * The name of the company making the contractor payment.
   */
  nameOfSender?: string | undefined;
  /**
   * The individual or company name of the contractor receiving payment.
   */
  nameOfRecipient?: string | undefined;
  /**
   * The debit date for the contractor payment.
   */
  debitDate?: Date | undefined;
  /**
   * Always the fixed string "Your payroll provider partners with Gusto Inc. for payments processing. Gusto Inc. is a licensed money transmitter. Learn more on our license page."
   */
  license?: string | undefined;
  /**
   * URL for the license information for the licensed payroll processor. Always the fixed string "https://gusto.com/about/licenses"
   */
  licenseUri?: string | undefined;
  /**
   * URL for information related to right to refund. Always the fixed string "https://gusto.com/about/licenses"
   */
  rightToRefund?: string | undefined;
  /**
   * URL for information related to right to liability of licensee. Always the fixed string "https://gusto.com/about/licenses"
   */
  liabilityOfLicensee?: string | undefined;
  /**
   * The subtotals for the contractor payment.
   */
  totals?: ContractorPaymentReceiptTotals | undefined;
  /**
   * An array of contractor payments for this contractor payment.
   */
  contractorPayments?:
    | Array<ContractorPaymentReceiptContractorPayment>
    | undefined;
  /**
   * The licensed payroll processor
   */
  licensee?: ContractorPaymentReceiptLicensee | undefined;
};

/** @internal */
export const ContractorPaymentReceiptTotals$inboundSchema: z.ZodMiniType<
  ContractorPaymentReceiptTotals,
  unknown
> = z.pipe(
  z.object({
    company_debit: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "company_debit": "companyDebit",
    });
  }),
);

export function contractorPaymentReceiptTotalsFromJSON(
  jsonString: string,
): SafeParseResult<ContractorPaymentReceiptTotals, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContractorPaymentReceiptTotals$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContractorPaymentReceiptTotals' from JSON`,
  );
}

/** @internal */
export const ContractorPaymentReceiptPaymentMethod$inboundSchema: z.ZodMiniType<
  ContractorPaymentReceiptPaymentMethod,
  unknown
> = openEnums.inboundSchema(ContractorPaymentReceiptPaymentMethod);

/** @internal */
export const ContractorPaymentReceiptContractorPayment$inboundSchema:
  z.ZodMiniType<ContractorPaymentReceiptContractorPayment, unknown> = z.pipe(
    z.object({
      contractor_uuid: types.optional(types.string()),
      contractor_first_name: types.optional(types.string()),
      contractor_last_name: types.optional(types.string()),
      contractor_business_name: types.optional(types.string()),
      contractor_type: types.optional(types.string()),
      payment_method: types.optional(
        ContractorPaymentReceiptPaymentMethod$inboundSchema,
      ),
      wage: types.optional(types.string()),
      bonus: types.optional(types.string()),
      reimbursement: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "contractor_uuid": "contractorUuid",
        "contractor_first_name": "contractorFirstName",
        "contractor_last_name": "contractorLastName",
        "contractor_business_name": "contractorBusinessName",
        "contractor_type": "contractorType",
        "payment_method": "paymentMethod",
      });
    }),
  );

export function contractorPaymentReceiptContractorPaymentFromJSON(
  jsonString: string,
): SafeParseResult<
  ContractorPaymentReceiptContractorPayment,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ContractorPaymentReceiptContractorPayment$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ContractorPaymentReceiptContractorPayment' from JSON`,
  );
}

/** @internal */
export const ContractorPaymentReceiptLicensee$inboundSchema: z.ZodMiniType<
  ContractorPaymentReceiptLicensee,
  unknown
> = z.pipe(
  z.object({
    name: types.optional(types.string()),
    address: types.optional(types.string()),
    city: types.optional(types.string()),
    state: types.optional(types.string()),
    postal_code: types.optional(types.string()),
    phone_number: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "postal_code": "postalCode",
      "phone_number": "phoneNumber",
    });
  }),
);

export function contractorPaymentReceiptLicenseeFromJSON(
  jsonString: string,
): SafeParseResult<ContractorPaymentReceiptLicensee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContractorPaymentReceiptLicensee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContractorPaymentReceiptLicensee' from JSON`,
  );
}

/** @internal */
export const ContractorPaymentReceipt$inboundSchema: z.ZodMiniType<
  ContractorPaymentReceipt,
  unknown
> = z.pipe(
  z.object({
    contractor_payment_uuid: types.optional(types.string()),
    company_uuid: types.optional(types.string()),
    name_of_sender: types.optional(types.string()),
    name_of_recipient: types.optional(types.string()),
    debit_date: types.optional(types.date()),
    license: types.optional(types.string()),
    license_uri: types.optional(types.string()),
    right_to_refund: types.optional(types.string()),
    liability_of_licensee: types.optional(types.string()),
    totals: types.optional(
      z.lazy(() => ContractorPaymentReceiptTotals$inboundSchema),
    ),
    contractor_payments: types.optional(z.array(z.lazy(() =>
      ContractorPaymentReceiptContractorPayment$inboundSchema
    ))),
    licensee: types.optional(z.lazy(() =>
      ContractorPaymentReceiptLicensee$inboundSchema
    )),
  }),
  z.transform((v) => {
    return remap$(v, {
      "contractor_payment_uuid": "contractorPaymentUuid",
      "company_uuid": "companyUuid",
      "name_of_sender": "nameOfSender",
      "name_of_recipient": "nameOfRecipient",
      "debit_date": "debitDate",
      "license_uri": "licenseUri",
      "right_to_refund": "rightToRefund",
      "liability_of_licensee": "liabilityOfLicensee",
      "contractor_payments": "contractorPayments",
    });
  }),
);

export function contractorPaymentReceiptFromJSON(
  jsonString: string,
): SafeParseResult<ContractorPaymentReceipt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContractorPaymentReceipt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContractorPaymentReceipt' from JSON`,
  );
}

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";

/**
 * The type of recipient associated with the document (will be `Contractor` for Contractor Documents)
 */
export const DocumentRecipientType = {
  Company: "Company",
  Employee: "Employee",
  Contractor: "Contractor",
} as const;
/**
 * The type of recipient associated with the document (will be `Contractor` for Contractor Documents)
 */
export type DocumentRecipientType = OpenEnum<typeof DocumentRecipientType>;

export type Page = {
  /**
   * Image URL for the page
   */
  imageUrl?: string | undefined;
  /**
   * Page number
   */
  pageNumber?: number | undefined;
};

export type Field = {
  /**
   * Unique identifier of the field
   */
  key?: string | undefined;
  /**
   * Auto-filled value of the field
   */
  value?: string | null | undefined;
  /**
   * X-coordinate location of the field on the page
   */
  x?: number | undefined;
  /**
   * Y-coordinate location of the field on the page
   */
  y?: number | undefined;
  /**
   * Width of the field
   */
  width?: number | undefined;
  /**
   * Height of the field
   */
  height?: number | undefined;
  /**
   * Page number of the field
   */
  pageNumber?: number | undefined;
  /**
   * The field's data type
   */
  dataType?: string | undefined;
  /**
   * Whether the field is required
   */
  required?: boolean | undefined;
};

export type Document = {
  /**
   * The UUID of the document
   */
  uuid?: string | undefined;
  /**
   * The title of the document
   */
  title?: string | undefined;
  /**
   * The type identifier of the document
   */
  name?: string | undefined;
  /**
   * The type of recipient associated with the document (will be `Contractor` for Contractor Documents)
   */
  recipientType?: DocumentRecipientType | undefined;
  /**
   * Unique identifier for the recipient associated with the document
   */
  recipientUuid?: string | undefined;
  /**
   * List of the document's pages and associated image URLs. This is only returned for documents with `required_signing` = `true`, and can be used for signing preparation.
   */
  pages?: Array<Page> | undefined;
  /**
   * List of the document's fields and associated data. Values are set for auto-filled fields. This is only returned for documents with `required_signing` = `true`, and can be used for signing preparation.
   */
  fields?: Array<Field> | undefined;
  /**
   * When the document was signed (will be `null` if unsigned)
   */
  signedAt?: string | null | undefined;
  /**
   * The description of the document
   */
  description?: string | undefined;
  /**
   * A boolean flag that indicates whether the document needs signing or not. Note that this value will change after the document is signed.
   */
  requiresSigning?: boolean | undefined;
  /**
   * If the document is in a draft state
   */
  draft?: boolean | undefined;
  /**
   * The year of this document. This value is nullable and will not be present on all documents.
   */
  year?: number | null | undefined;
  /**
   * The quarter of this document. This value is nullable and will not be present on all documents.
   */
  quarter?: number | null | undefined;
};

/** @internal */
export const DocumentRecipientType$inboundSchema: z.ZodMiniType<
  DocumentRecipientType,
  unknown
> = openEnums.inboundSchema(DocumentRecipientType);

/** @internal */
export const Page$inboundSchema: z.ZodMiniType<Page, unknown> = z.pipe(
  z.object({
    image_url: types.optional(types.string()),
    page_number: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "image_url": "imageUrl",
      "page_number": "pageNumber",
    });
  }),
);

export function pageFromJSON(
  jsonString: string,
): SafeParseResult<Page, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Page$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Page' from JSON`,
  );
}

/** @internal */
export const Field$inboundSchema: z.ZodMiniType<Field, unknown> = z.pipe(
  z.object({
    key: types.optional(types.string()),
    value: z.optional(z.nullable(types.string())),
    x: types.optional(types.number()),
    y: types.optional(types.number()),
    width: types.optional(types.number()),
    height: types.optional(types.number()),
    page_number: types.optional(types.number()),
    data_type: types.optional(types.string()),
    required: types.optional(types.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "page_number": "pageNumber",
      "data_type": "dataType",
    });
  }),
);

export function fieldFromJSON(
  jsonString: string,
): SafeParseResult<Field, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Field$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Field' from JSON`,
  );
}

/** @internal */
export const Document$inboundSchema: z.ZodMiniType<Document, unknown> = z.pipe(
  z.object({
    uuid: types.optional(types.string()),
    title: types.optional(types.string()),
    name: types.optional(types.string()),
    recipient_type: types.optional(DocumentRecipientType$inboundSchema),
    recipient_uuid: types.optional(types.string()),
    pages: types.optional(z.array(z.lazy(() => Page$inboundSchema))),
    fields: types.optional(z.array(z.lazy(() => Field$inboundSchema))),
    signed_at: z.optional(z.nullable(types.string())),
    description: types.optional(types.string()),
    requires_signing: types.optional(types.boolean()),
    draft: types.optional(types.boolean()),
    year: z.optional(z.nullable(types.number())),
    quarter: z.optional(z.nullable(types.number())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "recipient_type": "recipientType",
      "recipient_uuid": "recipientUuid",
      "signed_at": "signedAt",
      "requires_signing": "requiresSigning",
    });
  }),
);

export function documentFromJSON(
  jsonString: string,
): SafeParseResult<Document, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Document$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Document' from JSON`,
  );
}

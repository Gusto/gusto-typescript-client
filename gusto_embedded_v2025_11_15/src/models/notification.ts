/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";

/**
 * Represents the notification's status as managed by our system. It is updated based on observable system events and internal business logic, and does not reflect resolution steps taken outside our system. This field is read-only and cannot be modified via the API.
 */
export const NotificationStatus = {
  Open: "open",
  Resolved: "resolved",
  Expired: "expired",
} as const;
/**
 * Represents the notification's status as managed by our system. It is updated based on observable system events and internal business logic, and does not reflect resolution steps taken outside our system. This field is read-only and cannot be modified via the API.
 */
export type NotificationStatus = OpenEnum<typeof NotificationStatus>;

/**
 * The type of entity being described.
 */
export const NotificationEntityType = {
  BankAccount: "BankAccount",
  Contractor: "Contractor",
  ContractorPayment: "ContractorPayment",
  Employee: "Employee",
  Payroll: "Payroll",
  PaySchedule: "PaySchedule",
  RecoveryCase: "RecoveryCase",
  Signatory: "Signatory",
  WireInRequest: "Wire In Request",
} as const;
/**
 * The type of entity being described.
 */
export type NotificationEntityType = OpenEnum<typeof NotificationEntityType>;

export type Resource = {
  /**
   * The type of entity being described.
   */
  entityType: NotificationEntityType;
  /**
   * Unique identifier of the entity
   */
  entityUuid: string;
  /**
   * Optional. The type of a resource that is related to the one described by entity_type and entity_uuid. For instance, if the entity_type is “BankAccount”, the reference_type could be the “Employee” or “Contractor” to whom the bank account belongs.
   */
  referenceType?: string | undefined;
  /**
   * Optional. Unique identifier of the reference.
   */
  referenceUuid?: string | undefined;
};

/**
 * Example response
 */
export type Notification = {
  /**
   * Unique identifier of a notification.
   */
  uuid: string;
  /**
   * Unique identifier of the company to which the notification belongs.
   */
  companyUuid: string;
  /**
   * The title of the notification. This highlights the actionable component of the notification.
   */
  title: string;
  /**
   * The message of the notification. This provides additional context for the user and recommends a specific action to resolve the notification.
   */
  message: string;
  /**
   * Represents the notification's status as managed by our system. It is updated based on observable system events and internal business logic, and does not reflect resolution steps taken outside our system. This field is read-only and cannot be modified via the API.
   */
  status: NotificationStatus;
  /**
   * The notification's category.
   */
  category: string;
  /**
   * Indicates whether a notification requires action or not. If false, the notification provides critical information only.
   */
  actionable: boolean;
  /**
   * Indicates whether a notification may block ability to run payroll. If true, we suggest that these notifications are prioritized to your end users.
   */
  canBlockPayroll: boolean;
  /**
   * Timestamp of when the notification was published.
   */
  publishedAt: string;
  /**
   * Timestamp of when the notification is due. If the notification has no due date, this field will be null.
   */
  dueAt: string | null;
  /**
   * An object containing template variables used to render the notification. The structure of this object depends on the notification category. Each category defines a fixed set of variable names (keys), which are always present. The values of these variables can vary depending on the specific notification instance.
   */
  templateVariables?: { [k: string]: string } | undefined;
  /**
   * An array of entities relevant to the notification
   */
  resources: Array<Resource>;
};

/** @internal */
export const NotificationStatus$inboundSchema: z.ZodMiniType<
  NotificationStatus,
  unknown
> = openEnums.inboundSchema(NotificationStatus);

/** @internal */
export const NotificationEntityType$inboundSchema: z.ZodMiniType<
  NotificationEntityType,
  unknown
> = openEnums.inboundSchema(NotificationEntityType);

/** @internal */
export const Resource$inboundSchema: z.ZodMiniType<Resource, unknown> = z.pipe(
  z.object({
    entity_type: NotificationEntityType$inboundSchema,
    entity_uuid: types.string(),
    reference_type: types.optional(types.string()),
    reference_uuid: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "entity_type": "entityType",
      "entity_uuid": "entityUuid",
      "reference_type": "referenceType",
      "reference_uuid": "referenceUuid",
    });
  }),
);

export function resourceFromJSON(
  jsonString: string,
): SafeParseResult<Resource, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Resource$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Resource' from JSON`,
  );
}

/** @internal */
export const Notification$inboundSchema: z.ZodMiniType<Notification, unknown> =
  z.pipe(
    z.object({
      uuid: types.string(),
      company_uuid: types.string(),
      title: types.string(),
      message: types.string(),
      status: NotificationStatus$inboundSchema,
      category: types.string(),
      actionable: types.boolean(),
      can_block_payroll: types.boolean(),
      published_at: types.string(),
      due_at: types.nullable(types.string()),
      template_variables: types.optional(z.record(z.string(), types.string())),
      resources: z.array(z.lazy(() => Resource$inboundSchema)),
    }),
    z.transform((v) => {
      return remap$(v, {
        "company_uuid": "companyUuid",
        "can_block_payroll": "canBlockPayroll",
        "published_at": "publishedAt",
        "due_at": "dueAt",
        "template_variables": "templateVariables",
      });
    }),
  );

export function notificationFromJSON(
  jsonString: string,
): SafeParseResult<Notification, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Notification$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Notification' from JSON`,
  );
}

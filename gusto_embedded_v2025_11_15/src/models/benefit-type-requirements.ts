/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";

export type EmployeeDeductionDefaultValue = {
  value?: string | undefined;
  type?: string | undefined;
};

/**
 * The amount to be deducted, per pay period, from the employee's pay.
 */
export type EmployeeDeduction = {
  required?: boolean | undefined;
  editable?: boolean | undefined;
  defaultValue?: EmployeeDeductionDefaultValue | undefined;
  choices?: Array<string> | null | undefined;
};

export type ContributionDefaultValue = {
  value?: string | undefined;
  type?: string | undefined;
};

/**
 * An object representing the type and value of the company contribution.
 */
export type BenefitTypeRequirementsContribution = {
  required?: boolean | undefined;
  editable?: boolean | undefined;
  defaultValue?: ContributionDefaultValue | undefined;
  choices?: Array<string> | undefined;
};

export type DeductAsPercentageDefaultValue = {
  value?: string | undefined;
  type?: string | undefined;
};

/**
 * Whether the employee deduction amount should be treated as a percentage to be deducted from each payroll.
 */
export type DeductAsPercentage = {
  required?: boolean | undefined;
  editable?: boolean | undefined;
  defaultValue?: DeductAsPercentageDefaultValue | undefined;
  choices?: Array<string> | undefined;
};

export type CatchUpDefaultValue = {
  value?: string | undefined;
  type?: string | undefined;
};

/**
 * Whether the employee should use a benefit’s 'catch up' rate. Only Roth 401k and 401k benefits use this value for employees over 50.
 */
export type CatchUp = {
  required?: boolean | undefined;
  editable?: boolean | undefined;
  defaultValue?: CatchUpDefaultValue | undefined;
  choices?: Array<string> | undefined;
};

export type LimitOptionDefaultValue = {
  value?: string | undefined;
  type?: string | undefined;
};

/**
 * Some benefits require additional information to determine their limit. For example, for an HSA benefit, the limit option should be either 'Family' or 'Individual'. For a Dependent Care FSA benefit, the limit option should be either 'Joint Filing or Single' or 'Married and Filing Separately'.
 */
export type LimitOption = {
  required?: boolean | undefined;
  editable?: boolean | undefined;
  defaultValue?: LimitOptionDefaultValue | undefined;
  choices?: Array<string> | undefined;
};

export type CompanyContributionAnnualMaximumDefaultValue = {
  value?: string | undefined;
  type?: string | undefined;
};

/**
 * The maximum company contribution amount per year. A null value signifies no limit.
 */
export type CompanyContributionAnnualMaximum = {
  required?: boolean | undefined;
  editable?: boolean | undefined;
  defaultValue?: CompanyContributionAnnualMaximumDefaultValue | undefined;
  choices?: Array<string> | undefined;
};

export type CoverageSalaryMultiplierDefaultValue = {
  value?: string | undefined;
  type?: string | undefined;
};

/**
 * The coverage amount as a multiple of the employee's salary. Only applicable for Group Term Life benefits. Note: cannot be set if coverage amount is also set.
 */
export type CoverageSalaryMultiplier = {
  required?: boolean | undefined;
  editable?: boolean | undefined;
  defaultValue?: CoverageSalaryMultiplierDefaultValue | undefined;
  choices?: Array<string> | undefined;
};

export type CoverageAmountDefaultValue = {
  value?: string | undefined;
  type?: string | undefined;
};

/**
 * The amount that the employee is insured for. Note: company contribution cannot be present if coverage amount is set.
 */
export type CoverageAmount = {
  required?: boolean | undefined;
  editable?: boolean | undefined;
  defaultValue?: CoverageAmountDefaultValue | undefined;
  choices?: Array<string> | undefined;
};

/**
 * Benefit type requirements response
 */
export type BenefitTypeRequirements = {
  /**
   * The amount to be deducted, per pay period, from the employee's pay.
   */
  employeeDeduction?: EmployeeDeduction | undefined;
  /**
   * An object representing the type and value of the company contribution.
   */
  contribution?: BenefitTypeRequirementsContribution | undefined;
  /**
   * Whether the employee deduction amount should be treated as a percentage to be deducted from each payroll.
   */
  deductAsPercentage?: DeductAsPercentage | undefined;
  /**
   * Whether the employee should use a benefit’s 'catch up' rate. Only Roth 401k and 401k benefits use this value for employees over 50.
   */
  catchUp?: CatchUp | undefined;
  /**
   * Some benefits require additional information to determine their limit. For example, for an HSA benefit, the limit option should be either 'Family' or 'Individual'. For a Dependent Care FSA benefit, the limit option should be either 'Joint Filing or Single' or 'Married and Filing Separately'.
   */
  limitOption?: LimitOption | undefined;
  /**
   * The maximum company contribution amount per year. A null value signifies no limit.
   */
  companyContributionAnnualMaximum?:
    | CompanyContributionAnnualMaximum
    | undefined;
  /**
   * The coverage amount as a multiple of the employee's salary. Only applicable for Group Term Life benefits. Note: cannot be set if coverage amount is also set.
   */
  coverageSalaryMultiplier?: CoverageSalaryMultiplier | undefined;
  /**
   * The amount that the employee is insured for. Note: company contribution cannot be present if coverage amount is set.
   */
  coverageAmount?: CoverageAmount | undefined;
};

/** @internal */
export const EmployeeDeductionDefaultValue$inboundSchema: z.ZodMiniType<
  EmployeeDeductionDefaultValue,
  unknown
> = z.object({
  value: types.optional(types.string()),
  type: types.optional(types.string()),
});

export function employeeDeductionDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<EmployeeDeductionDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmployeeDeductionDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmployeeDeductionDefaultValue' from JSON`,
  );
}

/** @internal */
export const EmployeeDeduction$inboundSchema: z.ZodMiniType<
  EmployeeDeduction,
  unknown
> = z.pipe(
  z.object({
    required: types.optional(types.boolean()),
    editable: types.optional(types.boolean()),
    default_value: types.optional(
      z.lazy(() => EmployeeDeductionDefaultValue$inboundSchema),
    ),
    choices: z.optional(z.nullable(z.array(types.string()))),
  }),
  z.transform((v) => {
    return remap$(v, {
      "default_value": "defaultValue",
    });
  }),
);

export function employeeDeductionFromJSON(
  jsonString: string,
): SafeParseResult<EmployeeDeduction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmployeeDeduction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmployeeDeduction' from JSON`,
  );
}

/** @internal */
export const ContributionDefaultValue$inboundSchema: z.ZodMiniType<
  ContributionDefaultValue,
  unknown
> = z.object({
  value: types.optional(types.string()),
  type: types.optional(types.string()),
});

export function contributionDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<ContributionDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContributionDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContributionDefaultValue' from JSON`,
  );
}

/** @internal */
export const BenefitTypeRequirementsContribution$inboundSchema: z.ZodMiniType<
  BenefitTypeRequirementsContribution,
  unknown
> = z.pipe(
  z.object({
    required: types.optional(types.boolean()),
    editable: types.optional(types.boolean()),
    default_value: types.optional(
      z.lazy(() => ContributionDefaultValue$inboundSchema),
    ),
    choices: types.optional(z.array(types.string())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "default_value": "defaultValue",
    });
  }),
);

export function benefitTypeRequirementsContributionFromJSON(
  jsonString: string,
): SafeParseResult<BenefitTypeRequirementsContribution, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      BenefitTypeRequirementsContribution$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BenefitTypeRequirementsContribution' from JSON`,
  );
}

/** @internal */
export const DeductAsPercentageDefaultValue$inboundSchema: z.ZodMiniType<
  DeductAsPercentageDefaultValue,
  unknown
> = z.object({
  value: types.optional(types.string()),
  type: types.optional(types.string()),
});

export function deductAsPercentageDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<DeductAsPercentageDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeductAsPercentageDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeductAsPercentageDefaultValue' from JSON`,
  );
}

/** @internal */
export const DeductAsPercentage$inboundSchema: z.ZodMiniType<
  DeductAsPercentage,
  unknown
> = z.pipe(
  z.object({
    required: types.optional(types.boolean()),
    editable: types.optional(types.boolean()),
    default_value: types.optional(
      z.lazy(() => DeductAsPercentageDefaultValue$inboundSchema),
    ),
    choices: types.optional(z.array(types.string())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "default_value": "defaultValue",
    });
  }),
);

export function deductAsPercentageFromJSON(
  jsonString: string,
): SafeParseResult<DeductAsPercentage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeductAsPercentage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeductAsPercentage' from JSON`,
  );
}

/** @internal */
export const CatchUpDefaultValue$inboundSchema: z.ZodMiniType<
  CatchUpDefaultValue,
  unknown
> = z.object({
  value: types.optional(types.string()),
  type: types.optional(types.string()),
});

export function catchUpDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<CatchUpDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CatchUpDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CatchUpDefaultValue' from JSON`,
  );
}

/** @internal */
export const CatchUp$inboundSchema: z.ZodMiniType<CatchUp, unknown> = z.pipe(
  z.object({
    required: types.optional(types.boolean()),
    editable: types.optional(types.boolean()),
    default_value: types.optional(z.lazy(() =>
      CatchUpDefaultValue$inboundSchema
    )),
    choices: types.optional(z.array(types.string())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "default_value": "defaultValue",
    });
  }),
);

export function catchUpFromJSON(
  jsonString: string,
): SafeParseResult<CatchUp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CatchUp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CatchUp' from JSON`,
  );
}

/** @internal */
export const LimitOptionDefaultValue$inboundSchema: z.ZodMiniType<
  LimitOptionDefaultValue,
  unknown
> = z.object({
  value: types.optional(types.string()),
  type: types.optional(types.string()),
});

export function limitOptionDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<LimitOptionDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LimitOptionDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LimitOptionDefaultValue' from JSON`,
  );
}

/** @internal */
export const LimitOption$inboundSchema: z.ZodMiniType<LimitOption, unknown> = z
  .pipe(
    z.object({
      required: types.optional(types.boolean()),
      editable: types.optional(types.boolean()),
      default_value: types.optional(
        z.lazy(() => LimitOptionDefaultValue$inboundSchema),
      ),
      choices: types.optional(z.array(types.string())),
    }),
    z.transform((v) => {
      return remap$(v, {
        "default_value": "defaultValue",
      });
    }),
  );

export function limitOptionFromJSON(
  jsonString: string,
): SafeParseResult<LimitOption, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LimitOption$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LimitOption' from JSON`,
  );
}

/** @internal */
export const CompanyContributionAnnualMaximumDefaultValue$inboundSchema:
  z.ZodMiniType<CompanyContributionAnnualMaximumDefaultValue, unknown> = z
    .object({
      value: types.optional(types.string()),
      type: types.optional(types.string()),
    });

export function companyContributionAnnualMaximumDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<
  CompanyContributionAnnualMaximumDefaultValue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CompanyContributionAnnualMaximumDefaultValue$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CompanyContributionAnnualMaximumDefaultValue' from JSON`,
  );
}

/** @internal */
export const CompanyContributionAnnualMaximum$inboundSchema: z.ZodMiniType<
  CompanyContributionAnnualMaximum,
  unknown
> = z.pipe(
  z.object({
    required: types.optional(types.boolean()),
    editable: types.optional(types.boolean()),
    default_value: types.optional(
      z.lazy(() => CompanyContributionAnnualMaximumDefaultValue$inboundSchema),
    ),
    choices: types.optional(z.array(types.string())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "default_value": "defaultValue",
    });
  }),
);

export function companyContributionAnnualMaximumFromJSON(
  jsonString: string,
): SafeParseResult<CompanyContributionAnnualMaximum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CompanyContributionAnnualMaximum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompanyContributionAnnualMaximum' from JSON`,
  );
}

/** @internal */
export const CoverageSalaryMultiplierDefaultValue$inboundSchema: z.ZodMiniType<
  CoverageSalaryMultiplierDefaultValue,
  unknown
> = z.object({
  value: types.optional(types.string()),
  type: types.optional(types.string()),
});

export function coverageSalaryMultiplierDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<CoverageSalaryMultiplierDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CoverageSalaryMultiplierDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CoverageSalaryMultiplierDefaultValue' from JSON`,
  );
}

/** @internal */
export const CoverageSalaryMultiplier$inboundSchema: z.ZodMiniType<
  CoverageSalaryMultiplier,
  unknown
> = z.pipe(
  z.object({
    required: types.optional(types.boolean()),
    editable: types.optional(types.boolean()),
    default_value: types.optional(
      z.lazy(() => CoverageSalaryMultiplierDefaultValue$inboundSchema),
    ),
    choices: types.optional(z.array(types.string())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "default_value": "defaultValue",
    });
  }),
);

export function coverageSalaryMultiplierFromJSON(
  jsonString: string,
): SafeParseResult<CoverageSalaryMultiplier, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CoverageSalaryMultiplier$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CoverageSalaryMultiplier' from JSON`,
  );
}

/** @internal */
export const CoverageAmountDefaultValue$inboundSchema: z.ZodMiniType<
  CoverageAmountDefaultValue,
  unknown
> = z.object({
  value: types.optional(types.string()),
  type: types.optional(types.string()),
});

export function coverageAmountDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<CoverageAmountDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CoverageAmountDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CoverageAmountDefaultValue' from JSON`,
  );
}

/** @internal */
export const CoverageAmount$inboundSchema: z.ZodMiniType<
  CoverageAmount,
  unknown
> = z.pipe(
  z.object({
    required: types.optional(types.boolean()),
    editable: types.optional(types.boolean()),
    default_value: types.optional(
      z.lazy(() => CoverageAmountDefaultValue$inboundSchema),
    ),
    choices: types.optional(z.array(types.string())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "default_value": "defaultValue",
    });
  }),
);

export function coverageAmountFromJSON(
  jsonString: string,
): SafeParseResult<CoverageAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CoverageAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CoverageAmount' from JSON`,
  );
}

/** @internal */
export const BenefitTypeRequirements$inboundSchema: z.ZodMiniType<
  BenefitTypeRequirements,
  unknown
> = z.pipe(
  z.object({
    employee_deduction: types.optional(
      z.lazy(() => EmployeeDeduction$inboundSchema),
    ),
    contribution: types.optional(
      z.lazy(() => BenefitTypeRequirementsContribution$inboundSchema),
    ),
    deduct_as_percentage: types.optional(
      z.lazy(() => DeductAsPercentage$inboundSchema),
    ),
    catch_up: types.optional(z.lazy(() => CatchUp$inboundSchema)),
    limit_option: types.optional(z.lazy(() => LimitOption$inboundSchema)),
    company_contribution_annual_maximum: types.optional(
      z.lazy(() => CompanyContributionAnnualMaximum$inboundSchema),
    ),
    coverage_salary_multiplier: types.optional(
      z.lazy(() => CoverageSalaryMultiplier$inboundSchema),
    ),
    coverage_amount: types.optional(z.lazy(() => CoverageAmount$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "employee_deduction": "employeeDeduction",
      "deduct_as_percentage": "deductAsPercentage",
      "catch_up": "catchUp",
      "limit_option": "limitOption",
      "company_contribution_annual_maximum": "companyContributionAnnualMaximum",
      "coverage_salary_multiplier": "coverageSalaryMultiplier",
      "coverage_amount": "coverageAmount",
    });
  }),
);

export function benefitTypeRequirementsFromJSON(
  jsonString: string,
): SafeParseResult<BenefitTypeRequirements, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BenefitTypeRequirements$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BenefitTypeRequirements' from JSON`,
  );
}

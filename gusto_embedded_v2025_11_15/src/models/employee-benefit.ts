/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smart-union.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";

/**
 * A single tier of a tiered matching scheme.
 */
export type EmployeeBenefitTier = {
  /**
   * The percentage of employee deduction within this tier the company contribution will match.
   */
  rate?: string | undefined;
  /**
   * Specifies the upper limit (inclusive) percentage of the employee contribution that this tier applies to.
   *
   * @remarks
   *
   * Use threshold to define each tier's end point, with tiers applied cumulatively from 0% upwards.
   *
   * For example:
   *
   * If the first tier has a threshold of "3", and `rate` of "100", the company will match 100% of employee contributions from 0% up to and including 3% of payroll.
   *
   * If the next tier has a threshold of "5" and a rate of "50", the company will match 50% of contributions from above 3% up to and including 5% of payroll.
   */
  threshold?: string | undefined;
  /**
   * The step up difference between this tier's threshold and the previous tier's threshold. In the first tier, this is equivalent to threshold.
   */
  thresholdDelta?: string | undefined;
};

export type EmployeeBenefitValue = {
  tiers?: Array<EmployeeBenefitTier> | undefined;
};

/**
 * For the `amount` and `percentage` contribution types, the value of the corresponding amount or percentage.
 *
 * @remarks
 *
 * For the `tiered` contribution type, an array of tiers.
 */
export type EmployeeBenefitValueUnion = string | EmployeeBenefitValue;

/**
 * An object representing the type and value of the company contribution.
 */
export type EmployeeBenefitContribution = {
  /**
   * The company contribution scheme.
   *
   * @remarks
   *
   * "amount": The company contributes a fixed amount per payroll. If elective is true, the contribution is matching, dollar-for-dollar.
   *
   * "percentage": The company contributes a percentage of the payroll amount per payroll period. If elective is true, the contribution is matching, dollar-for-dollar.
   *
   * "tiered": The company contribution varies according to the size of the employee deduction.
   */
  type?: string | undefined;
  /**
   * For the `amount` and `percentage` contribution types, the value of the corresponding amount or percentage.
   *
   * @remarks
   *
   * For the `tiered` contribution type, an array of tiers.
   */
  value?: string | EmployeeBenefitValue | undefined;
};

/**
 * Whether the employee deduction reduces taxable income or not. Only valid for Group Term Life benefits. Note: when the value is not "unset", coverage amount and coverage salary multiplier are ignored.
 */
export const EmployeeBenefitDeductionReducesTaxableIncome = {
  Unset: "unset",
  ReducesTaxableIncome: "reduces_taxable_income",
  DoesNotReduceTaxableIncome: "does_not_reduce_taxable_income",
} as const;
/**
 * Whether the employee deduction reduces taxable income or not. Only valid for Group Term Life benefits. Note: when the value is not "unset", coverage amount and coverage salary multiplier are ignored.
 */
export type EmployeeBenefitDeductionReducesTaxableIncome = OpenEnum<
  typeof EmployeeBenefitDeductionReducesTaxableIncome
>;

/**
 * The representation of an employee benefit.
 */
export type EmployeeBenefit = {
  /**
   * The current version of the object. See the [versioning guide](https://docs.gusto.com/embedded-payroll/docs/idempotency) for information on how to use this field.
   */
  version?: string | undefined;
  /**
   * Whether the employee benefit is active.
   */
  active: boolean;
  /**
   * The amount to be deducted, per pay period, from the employee's pay.
   */
  employeeDeduction: string;
  /**
   * Whether the employee deduction amount should be treated as a percentage to be deducted from each payroll.
   */
  deductAsPercentage: boolean;
  /**
   * The maximum employee deduction amount per year. A null value signifies no limit.
   */
  employeeDeductionAnnualMaximum?: string | null | undefined;
  /**
   * An object representing the type and value of the company contribution.
   */
  contribution?: EmployeeBenefitContribution | undefined;
  /**
   * Whether the company contribution is elective (aka matching). For "tiered" contribution types, this is always true.
   */
  elective: boolean;
  /**
   * The maximum company contribution amount per year. A null value signifies no limit.
   */
  companyContributionAnnualMaximum?: string | null | undefined;
  /**
   * Some benefits require additional information to determine their limit.
   *
   * @remarks
   *
   * `Family` and `Individual` are applicable to HSA benefit.
   *
   * `Joint Filing or Single` and `Married and Filing Separately` are applicable to Dependent Care FSA benefit.
   */
  limitOption?: string | null | undefined;
  /**
   * Whether the employee should use a benefit's "catch up" rate. Only Roth 401k and 401k benefits use this value for employees over 50.
   */
  catchUp: boolean | null;
  /**
   * Identifier for a 401(k) loan assigned by the 401(k) provider
   */
  retirementLoanIdentifier?: string | undefined;
  /**
   * The amount that the employee is insured for. Note: company contribution cannot be present if coverage amount is set.
   */
  coverageAmount?: string | null | undefined;
  /**
   * Whether the employee deduction reduces taxable income or not. Only valid for Group Term Life benefits. Note: when the value is not "unset", coverage amount and coverage salary multiplier are ignored.
   */
  deductionReducesTaxableIncome:
    | EmployeeBenefitDeductionReducesTaxableIncome
    | null;
  /**
   * The coverage amount as a multiple of the employee's salary. Only applicable for Group Term Life benefits. Note: cannot be set if coverage amount is also set.
   */
  coverageSalaryMultiplier: string | null;
  /**
   * The amount to be paid, per pay period, by the company. This field will not appear for tiered contribution types.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  companyContribution: string;
  /**
   * Whether the company_contribution value should be treated as a percentage to be added to each payroll. This field will not appear for tiered contribution types.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  contributeAsPercentage: boolean;
  /**
   * The date the employee benefit will start.
   */
  effectiveDate?: Date | undefined;
  /**
   * The date the employee benefit will expire. A null value indicates the benefit will not expire.
   */
  expirationDate?: Date | null | undefined;
  /**
   * The UUID of the employee to which the benefit belongs.
   */
  employeeUuid?: string | undefined;
  /**
   * The UUID of the company benefit.
   */
  companyBenefitUuid?: string | undefined;
  /**
   * The UUID of the employee benefit.
   */
  uuid: string;
};

/** @internal */
export const EmployeeBenefitTier$inboundSchema: z.ZodMiniType<
  EmployeeBenefitTier,
  unknown
> = z.pipe(
  z.object({
    rate: types.optional(types.string()),
    threshold: types.optional(types.string()),
    threshold_delta: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "threshold_delta": "thresholdDelta",
    });
  }),
);

export function employeeBenefitTierFromJSON(
  jsonString: string,
): SafeParseResult<EmployeeBenefitTier, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmployeeBenefitTier$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmployeeBenefitTier' from JSON`,
  );
}

/** @internal */
export const EmployeeBenefitValue$inboundSchema: z.ZodMiniType<
  EmployeeBenefitValue,
  unknown
> = z.object({
  tiers: types.optional(
    z.array(z.lazy(() => EmployeeBenefitTier$inboundSchema)),
  ),
});

export function employeeBenefitValueFromJSON(
  jsonString: string,
): SafeParseResult<EmployeeBenefitValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmployeeBenefitValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmployeeBenefitValue' from JSON`,
  );
}

/** @internal */
export const EmployeeBenefitValueUnion$inboundSchema: z.ZodMiniType<
  EmployeeBenefitValueUnion,
  unknown
> = smartUnion([
  types.string(),
  z.lazy(() => EmployeeBenefitValue$inboundSchema),
]);

export function employeeBenefitValueUnionFromJSON(
  jsonString: string,
): SafeParseResult<EmployeeBenefitValueUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmployeeBenefitValueUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmployeeBenefitValueUnion' from JSON`,
  );
}

/** @internal */
export const EmployeeBenefitContribution$inboundSchema: z.ZodMiniType<
  EmployeeBenefitContribution,
  unknown
> = z.object({
  type: types.optional(types.string()),
  value: types.optional(
    smartUnion([
      types.string(),
      z.lazy(() => EmployeeBenefitValue$inboundSchema),
    ]),
  ),
});

export function employeeBenefitContributionFromJSON(
  jsonString: string,
): SafeParseResult<EmployeeBenefitContribution, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmployeeBenefitContribution$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmployeeBenefitContribution' from JSON`,
  );
}

/** @internal */
export const EmployeeBenefitDeductionReducesTaxableIncome$inboundSchema:
  z.ZodMiniType<EmployeeBenefitDeductionReducesTaxableIncome, unknown> =
    openEnums.inboundSchema(EmployeeBenefitDeductionReducesTaxableIncome);

/** @internal */
export const EmployeeBenefit$inboundSchema: z.ZodMiniType<
  EmployeeBenefit,
  unknown
> = z.pipe(
  z.object({
    version: types.optional(types.string()),
    active: z._default(types.boolean(), true),
    employee_deduction: z._default(types.string(), "0.00"),
    deduct_as_percentage: z._default(types.boolean(), false),
    employee_deduction_annual_maximum: z.optional(z.nullable(types.string())),
    contribution: types.optional(
      z.lazy(() => EmployeeBenefitContribution$inboundSchema),
    ),
    elective: z._default(types.boolean(), false),
    company_contribution_annual_maximum: z.optional(z.nullable(types.string())),
    limit_option: z.optional(z.nullable(types.string())),
    catch_up: z.nullable(z._default(types.boolean(), false)),
    retirement_loan_identifier: types.optional(types.string()),
    coverage_amount: z.optional(z.nullable(types.string())),
    deduction_reduces_taxable_income: z.nullable(
      z._default(
        EmployeeBenefitDeductionReducesTaxableIncome$inboundSchema,
        "unset",
      ),
    ),
    coverage_salary_multiplier: z.nullable(z._default(types.string(), "0.00")),
    company_contribution: z._default(types.string(), "0.00"),
    contribute_as_percentage: z._default(types.boolean(), false),
    effective_date: types.optional(types.date()),
    expiration_date: z.optional(z.nullable(types.date())),
    employee_uuid: types.optional(types.string()),
    company_benefit_uuid: types.optional(types.string()),
    uuid: types.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "employee_deduction": "employeeDeduction",
      "deduct_as_percentage": "deductAsPercentage",
      "employee_deduction_annual_maximum": "employeeDeductionAnnualMaximum",
      "company_contribution_annual_maximum": "companyContributionAnnualMaximum",
      "limit_option": "limitOption",
      "catch_up": "catchUp",
      "retirement_loan_identifier": "retirementLoanIdentifier",
      "coverage_amount": "coverageAmount",
      "deduction_reduces_taxable_income": "deductionReducesTaxableIncome",
      "coverage_salary_multiplier": "coverageSalaryMultiplier",
      "company_contribution": "companyContribution",
      "contribute_as_percentage": "contributeAsPercentage",
      "effective_date": "effectiveDate",
      "expiration_date": "expirationDate",
      "employee_uuid": "employeeUuid",
      "company_benefit_uuid": "companyBenefitUuid",
    });
  }),
);

export function employeeBenefitFromJSON(
  jsonString: string,
): SafeParseResult<EmployeeBenefit, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EmployeeBenefit$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EmployeeBenefit' from JSON`,
  );
}

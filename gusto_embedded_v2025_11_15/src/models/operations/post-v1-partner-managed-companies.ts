/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";
import * as models from "../index.js";

export type PostV1PartnerManagedCompaniesSecurity = {
  systemAccessAuth: string;
};

/**
 * Information for the user who will be the primary payroll administrator for the new company.
 */
export type User = {
  /**
   * The first name of the user who will be the primary payroll admin.
   */
  firstName: string;
  /**
   * The last name of the user who will be the primary payroll admin.
   */
  lastName: string;
  /**
   * The email of the user who will be the primary payroll admin.
   */
  email: string;
  /**
   * The phone number of the user who will be the primary payroll admin.
   */
  phone?: string | undefined;
};

export type Company = {
  /**
   * The legal name of the company.
   */
  name: string;
  /**
   * The name of the company.
   */
  tradeName?: string | undefined;
  /**
   * The employer identification number (EIN) of the company.
   */
  ein?: string | undefined;
  /**
   * Whether the company only supports contractors. Should be set to true if the company has no W-2 employees. If not passed, will default to false (i.e. the company will support both contractors and employees).
   */
  contractorOnly?: boolean | undefined;
};

export type PostV1PartnerManagedCompaniesRequestBody = {
  /**
   * Information for the user who will be the primary payroll administrator for the new company.
   */
  user: User;
  company: Company;
};

export type PostV1PartnerManagedCompaniesRequest = {
  /**
   * Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
   */
  xGustoAPIVersion?: models.VersionHeader | undefined;
  body: PostV1PartnerManagedCompaniesRequestBody;
};

/**
 * Object returned when creating a partner managed company
 */
export type PostV1PartnerManagedCompaniesResponse = {
  /**
   * Access token that can be used for OAuth access to the account. Access tokens expire 2 hours after they are issued.
   */
  accessToken?: string | undefined;
  /**
   * Refresh token that can be exchanged for a new access token.
   */
  refreshToken?: string | undefined;
  /**
   * Gustoâ€™s UUID for the company
   */
  companyUuid?: string | undefined;
  /**
   * Time of access_token expiration in seconds
   */
  expiresIn?: number | undefined;
};

/** @internal */
export type PostV1PartnerManagedCompaniesSecurity$Outbound = {
  SystemAccessAuth: string;
};

/** @internal */
export const PostV1PartnerManagedCompaniesSecurity$outboundSchema:
  z.ZodMiniType<
    PostV1PartnerManagedCompaniesSecurity$Outbound,
    PostV1PartnerManagedCompaniesSecurity
  > = z.pipe(
    z.object({
      systemAccessAuth: z.string(),
    }),
    z.transform((v) => {
      return remap$(v, {
        systemAccessAuth: "SystemAccessAuth",
      });
    }),
  );

export function postV1PartnerManagedCompaniesSecurityToJSON(
  postV1PartnerManagedCompaniesSecurity: PostV1PartnerManagedCompaniesSecurity,
): string {
  return JSON.stringify(
    PostV1PartnerManagedCompaniesSecurity$outboundSchema.parse(
      postV1PartnerManagedCompaniesSecurity,
    ),
  );
}

/** @internal */
export type User$Outbound = {
  first_name: string;
  last_name: string;
  email: string;
  phone?: string | undefined;
};

/** @internal */
export const User$outboundSchema: z.ZodMiniType<User$Outbound, User> = z.pipe(
  z.object({
    firstName: z.string(),
    lastName: z.string(),
    email: z.string(),
    phone: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      firstName: "first_name",
      lastName: "last_name",
    });
  }),
);

export function userToJSON(user: User): string {
  return JSON.stringify(User$outboundSchema.parse(user));
}

/** @internal */
export type Company$Outbound = {
  name: string;
  trade_name?: string | undefined;
  ein?: string | undefined;
  contractor_only?: boolean | undefined;
};

/** @internal */
export const Company$outboundSchema: z.ZodMiniType<Company$Outbound, Company> =
  z.pipe(
    z.object({
      name: z.string(),
      tradeName: z.optional(z.string()),
      ein: z.optional(z.string()),
      contractorOnly: z.optional(z.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        tradeName: "trade_name",
        contractorOnly: "contractor_only",
      });
    }),
  );

export function companyToJSON(company: Company): string {
  return JSON.stringify(Company$outboundSchema.parse(company));
}

/** @internal */
export type PostV1PartnerManagedCompaniesRequestBody$Outbound = {
  user: User$Outbound;
  company: Company$Outbound;
};

/** @internal */
export const PostV1PartnerManagedCompaniesRequestBody$outboundSchema:
  z.ZodMiniType<
    PostV1PartnerManagedCompaniesRequestBody$Outbound,
    PostV1PartnerManagedCompaniesRequestBody
  > = z.object({
    user: z.lazy(() => User$outboundSchema),
    company: z.lazy(() => Company$outboundSchema),
  });

export function postV1PartnerManagedCompaniesRequestBodyToJSON(
  postV1PartnerManagedCompaniesRequestBody:
    PostV1PartnerManagedCompaniesRequestBody,
): string {
  return JSON.stringify(
    PostV1PartnerManagedCompaniesRequestBody$outboundSchema.parse(
      postV1PartnerManagedCompaniesRequestBody,
    ),
  );
}

/** @internal */
export type PostV1PartnerManagedCompaniesRequest$Outbound = {
  "X-Gusto-API-Version": string;
  body: PostV1PartnerManagedCompaniesRequestBody$Outbound;
};

/** @internal */
export const PostV1PartnerManagedCompaniesRequest$outboundSchema: z.ZodMiniType<
  PostV1PartnerManagedCompaniesRequest$Outbound,
  PostV1PartnerManagedCompaniesRequest
> = z.pipe(
  z.object({
    xGustoAPIVersion: z._default(
      models.VersionHeader$outboundSchema,
      "2025-06-15",
    ),
    body: z.lazy(() => PostV1PartnerManagedCompaniesRequestBody$outboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      xGustoAPIVersion: "X-Gusto-API-Version",
    });
  }),
);

export function postV1PartnerManagedCompaniesRequestToJSON(
  postV1PartnerManagedCompaniesRequest: PostV1PartnerManagedCompaniesRequest,
): string {
  return JSON.stringify(
    PostV1PartnerManagedCompaniesRequest$outboundSchema.parse(
      postV1PartnerManagedCompaniesRequest,
    ),
  );
}

/** @internal */
export const PostV1PartnerManagedCompaniesResponse$inboundSchema: z.ZodMiniType<
  PostV1PartnerManagedCompaniesResponse,
  unknown
> = z.pipe(
  z.object({
    access_token: types.optional(types.string()),
    refresh_token: types.optional(types.string()),
    company_uuid: types.optional(types.string()),
    expires_in: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "access_token": "accessToken",
      "refresh_token": "refreshToken",
      "company_uuid": "companyUuid",
      "expires_in": "expiresIn",
    });
  }),
);

export function postV1PartnerManagedCompaniesResponseFromJSON(
  jsonString: string,
): SafeParseResult<PostV1PartnerManagedCompaniesResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      PostV1PartnerManagedCompaniesResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostV1PartnerManagedCompaniesResponse' from JSON`,
  );
}

/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { ClosedEnum } from "../../types/enums.js";

/**
 * Type of response - matches the question's response_type from GET
 */
export const ResponseType = {
  Text: "text",
  Document: "document",
} as const;
/**
 * Type of response - matches the question's response_type from GET
 */
export type ResponseType = ClosedEnum<typeof ResponseType>;

export type RequiredQuestion = {
  /**
   * UUID of the question being answered
   */
  questionUuid: string;
  /**
   * Type of response - matches the question's response_type from GET
   */
  responseType: ResponseType;
  /**
   * Text response (required when response_type is text)
   */
  textResponse?: string | undefined;
  /**
   * Data URL with base64-encoded file (e.g., "data:image/png;base64,..."). Required when response_type is document.
   */
  fileResponse?: string | undefined;
  /**
   * Original filename with extension (e.g., "document.pdf"). Used for document uploads.
   */
  fileName?: string | undefined;
};

export type SubmitInformationRequestRequestBody = {
  requiredQuestions?: Array<RequiredQuestion> | undefined;
};

export type SubmitInformationRequestRequest = {
  /**
   * The UUID of the information request
   */
  informationRequestUuid: string;
  body: SubmitInformationRequestRequestBody;
};

/** @internal */
export const ResponseType$outboundSchema: z.ZodMiniEnum<typeof ResponseType> = z
  .enum(ResponseType);

/** @internal */
export type RequiredQuestion$Outbound = {
  question_uuid: string;
  response_type: string;
  text_response?: string | undefined;
  file_response?: string | undefined;
  file_name?: string | undefined;
};

/** @internal */
export const RequiredQuestion$outboundSchema: z.ZodMiniType<
  RequiredQuestion$Outbound,
  RequiredQuestion
> = z.pipe(
  z.object({
    questionUuid: z.string(),
    responseType: ResponseType$outboundSchema,
    textResponse: z.optional(z.string()),
    fileResponse: z.optional(z.string()),
    fileName: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      questionUuid: "question_uuid",
      responseType: "response_type",
      textResponse: "text_response",
      fileResponse: "file_response",
      fileName: "file_name",
    });
  }),
);

export function requiredQuestionToJSON(
  requiredQuestion: RequiredQuestion,
): string {
  return JSON.stringify(
    RequiredQuestion$outboundSchema.parse(requiredQuestion),
  );
}

/** @internal */
export type SubmitInformationRequestRequestBody$Outbound = {
  required_questions?: Array<RequiredQuestion$Outbound> | undefined;
};

/** @internal */
export const SubmitInformationRequestRequestBody$outboundSchema: z.ZodMiniType<
  SubmitInformationRequestRequestBody$Outbound,
  SubmitInformationRequestRequestBody
> = z.pipe(
  z.object({
    requiredQuestions: z.optional(
      z.array(z.lazy(() => RequiredQuestion$outboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      requiredQuestions: "required_questions",
    });
  }),
);

export function submitInformationRequestRequestBodyToJSON(
  submitInformationRequestRequestBody: SubmitInformationRequestRequestBody,
): string {
  return JSON.stringify(
    SubmitInformationRequestRequestBody$outboundSchema.parse(
      submitInformationRequestRequestBody,
    ),
  );
}

/** @internal */
export type SubmitInformationRequestRequest$Outbound = {
  information_request_uuid: string;
  body: SubmitInformationRequestRequestBody$Outbound;
};

/** @internal */
export const SubmitInformationRequestRequest$outboundSchema: z.ZodMiniType<
  SubmitInformationRequestRequest$Outbound,
  SubmitInformationRequestRequest
> = z.pipe(
  z.object({
    informationRequestUuid: z.string(),
    body: z.lazy(() => SubmitInformationRequestRequestBody$outboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      informationRequestUuid: "information_request_uuid",
    });
  }),
);

export function submitInformationRequestRequestToJSON(
  submitInformationRequestRequest: SubmitInformationRequestRequest,
): string {
  return JSON.stringify(
    SubmitInformationRequestRequest$outboundSchema.parse(
      submitInformationRequestRequest,
    ),
  );
}

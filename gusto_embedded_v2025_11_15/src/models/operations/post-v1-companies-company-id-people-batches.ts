/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

/**
 * Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
 */
export const PostV1CompaniesCompanyIdPeopleBatchesXGustoAPIVersion = {
  TwoThousandAndTwentyFiveMinus06Minus15: "2025-06-15",
} as const;
/**
 * Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
 */
export type PostV1CompaniesCompanyIdPeopleBatchesXGustoAPIVersion = ClosedEnum<
  typeof PostV1CompaniesCompanyIdPeopleBatchesXGustoAPIVersion
>;

/**
 * The action to perform on the batch
 */
export const BatchAction = {
  Create: "create",
} as const;
/**
 * The action to perform on the batch
 */
export type BatchAction = ClosedEnum<typeof BatchAction>;

/**
 * The type of entity to create
 */
export const EntityType = {
  Employee: "employee",
} as const;
/**
 * The type of entity to create
 */
export type EntityType = ClosedEnum<typeof EntityType>;

export type Person = {
  /**
   * External identifier for the person
   */
  externalId: string;
  /**
   * Legal first name
   */
  firstName: string;
  /**
   * Legal last name
   */
  lastName: string;
  /**
   * Middle initial
   */
  middleInitial?: string | null | undefined;
  /**
   * Preferred first name
   */
  preferredFirstName?: string | null | undefined;
  /**
   * Personal email address
   */
  email?: string | null | undefined;
  /**
   * Work email address
   */
  workEmail?: string | null | undefined;
  /**
   * Social Security Number (format: xxx-xx-xxxx)
   */
  ssn?: string | null | undefined;
  /**
   * Date of birth (YYYY-MM-DD)
   */
  dateOfBirth?: Date | null | undefined;
  /**
   * Whether the employee will complete their own onboarding
   */
  selfOnboarding?: boolean | null | undefined;
};

/**
 * Home address for the employee
 */
export type PostV1CompaniesCompanyIdPeopleBatchesHomeAddress = {
  /**
   * Street address line 1
   */
  street1: string;
  /**
   * Street address line 2
   */
  street2?: string | undefined;
  /**
   * City
   */
  city: string;
  /**
   * State abbreviation
   */
  state: string;
  /**
   * ZIP code
   */
  zip: string;
  /**
   * Country (defaults to USA)
   */
  country?: string | undefined;
  /**
   * If true, a company work address will be created based on this home address and the `work_address` property is not allowed.
   */
  workFromHome?: boolean | undefined;
};

/**
 * Specify the company work location for the employee
 */
export type PostV1CompaniesCompanyIdPeopleBatchesWorkAddress = {
  /**
   * UUID of an existing company work location
   */
  locationUuid: string;
};

/**
 * Job details for the employee (required if compensation is provided)
 */
export type PostV1CompaniesCompanyIdPeopleBatchesJob = {
  /**
   * Job title
   */
  title: string;
  /**
   * The date when the employee was hired or rehired for the job.
   */
  hireDate: Date;
  /**
   * Whether the employee owns at least 2% of the company. Can only be `true` for S-Corp companies.
   */
  twoPercentShareholder?: boolean | undefined;
  /**
   * Whether this job is eligible for workers' compensation coverage in the state of Washington (WA).
   */
  stateWcCovered?: boolean | null | undefined;
  /**
   * The risk class code for workers' compensation in Washington state. Please visit [Washington state's Risk Class page](https://www.lni.wa.gov/insurance/rates-risk-classes/risk-classes-for-workers-compensation/risk-class-lookup#/) to learn more.
   */
  stateWcClassCode?: string | null | undefined;
};

/**
 * Department details for the employee
 */
export type Department = {
  /**
   * UUID of an existing company department
   */
  departmentUuid: string;
};

/**
 * The unit accompanying the compensation rate. If the employee is an owner, rate should be `Paycheck`.
 */
export const PostV1CompaniesCompanyIdPeopleBatchesPaymentUnit = {
  Hour: "Hour",
  Week: "Week",
  Month: "Month",
  Year: "Year",
  Paycheck: "Paycheck",
} as const;
/**
 * The unit accompanying the compensation rate. If the employee is an owner, rate should be `Paycheck`.
 */
export type PostV1CompaniesCompanyIdPeopleBatchesPaymentUnit = ClosedEnum<
  typeof PostV1CompaniesCompanyIdPeopleBatchesPaymentUnit
>;

/**
 * The FLSA status for this compensation. Salaried ('Exempt') employees are paid a fixed salary every pay period. Salaried with overtime ('Salaried Nonexempt') employees are paid a fixed salary every pay period, and receive overtime pay when applicable. Hourly ( 'Nonexempt') employees are paid for the hours they work, and receive overtime pay when applicable. Commissioned employees ('Commission Only Exempt') earn wages based only on commission. Commissioned with overtime ('Commission Only Nonexempt') earn wages based on commission, and receive overtime pay when applicable. Owners ('Owner') are employees that own at least twenty percent of the company. If selecting `Owner`, `payment_unit` must be `"Paycheck"`.
 */
export const FlsaStatus = {
  Exempt: "Exempt",
  SalariedNonexempt: "Salaried Nonexempt",
  Nonexempt: "Nonexempt",
  Owner: "Owner",
  CommissionOnlyExempt: "Commission Only Exempt",
  CommissionOnlyNonexempt: "Commission Only Nonexempt",
} as const;
/**
 * The FLSA status for this compensation. Salaried ('Exempt') employees are paid a fixed salary every pay period. Salaried with overtime ('Salaried Nonexempt') employees are paid a fixed salary every pay period, and receive overtime pay when applicable. Hourly ( 'Nonexempt') employees are paid for the hours they work, and receive overtime pay when applicable. Commissioned employees ('Commission Only Exempt') earn wages based only on commission. Commissioned with overtime ('Commission Only Nonexempt') earn wages based on commission, and receive overtime pay when applicable. Owners ('Owner') are employees that own at least twenty percent of the company. If selecting `Owner`, `payment_unit` must be `"Paycheck"`.
 */
export type FlsaStatus = ClosedEnum<typeof FlsaStatus>;

/**
 * Compensation details for the employee (requires job to be provided)
 */
export type Compensation = {
  /**
   * The dollar amount paid per payment unit.
   */
  rate: string;
  /**
   * The unit accompanying the compensation rate. If the employee is an owner, rate should be `Paycheck`.
   */
  paymentUnit: PostV1CompaniesCompanyIdPeopleBatchesPaymentUnit;
  /**
   * The date when the compensation takes effect.
   */
  effectiveDate?: Date | undefined;
  /**
   * The FLSA status for this compensation. Salaried ('Exempt') employees are paid a fixed salary every pay period. Salaried with overtime ('Salaried Nonexempt') employees are paid a fixed salary every pay period, and receive overtime pay when applicable. Hourly ( 'Nonexempt') employees are paid for the hours they work, and receive overtime pay when applicable. Commissioned employees ('Commission Only Exempt') earn wages based only on commission. Commissioned with overtime ('Commission Only Nonexempt') earn wages based on commission, and receive overtime pay when applicable. Owners ('Owner') are employees that own at least twenty percent of the company. If selecting `Owner`, `payment_unit` must be `"Paycheck"`.
   */
  flsaStatus: FlsaStatus;
};

/**
 * Type of bank account
 */
export const PostV1CompaniesCompanyIdPeopleBatchesAccountType = {
  Checking: "Checking",
  Savings: "Savings",
} as const;
/**
 * Type of bank account
 */
export type PostV1CompaniesCompanyIdPeopleBatchesAccountType = ClosedEnum<
  typeof PostV1CompaniesCompanyIdPeopleBatchesAccountType
>;

/**
 * Payment type (must be Direct Deposit)
 */
export const PostV1CompaniesCompanyIdPeopleBatchesType = {
  DirectDeposit: "Direct Deposit",
} as const;
/**
 * Payment type (must be Direct Deposit)
 */
export type PostV1CompaniesCompanyIdPeopleBatchesType = ClosedEnum<
  typeof PostV1CompaniesCompanyIdPeopleBatchesType
>;

/**
 * How to split deposits, must be the same for all bank accounts. If split_by is `Percentage`, then the split_amounts must add up to exactly 100.
 */
export const PostV1CompaniesCompanyIdPeopleBatchesSplitBy = {
  Amount: "Amount",
  Percentage: "Percentage",
} as const;
/**
 * How to split deposits, must be the same for all bank accounts. If split_by is `Percentage`, then the split_amounts must add up to exactly 100.
 */
export type PostV1CompaniesCompanyIdPeopleBatchesSplitBy = ClosedEnum<
  typeof PostV1CompaniesCompanyIdPeopleBatchesSplitBy
>;

export type BankAccount = {
  /**
   * Account nickname
   */
  name?: string | null | undefined;
  /**
   * Type of bank account
   */
  accountType: PostV1CompaniesCompanyIdPeopleBatchesAccountType;
  /**
   * Bank routing number
   */
  routingNumber: string;
  /**
   * Bank account number
   */
  accountNumber: string;
  /**
   * Payment type (must be Direct Deposit)
   */
  type: PostV1CompaniesCompanyIdPeopleBatchesType;
  /**
   * How to split deposits, must be the same for all bank accounts. If split_by is `Percentage`, then the split_amounts must add up to exactly 100.
   */
  splitBy: PostV1CompaniesCompanyIdPeopleBatchesSplitBy;
  /**
   * Split amount in percentage or CENTS (`null` for remainder account)
   */
  splitAmount?: string | null | undefined;
};

export type Batch = {
  /**
   * The type of entity to create
   */
  entityType: EntityType;
  person: Person;
  /**
   * Home address for the employee
   */
  homeAddress?: PostV1CompaniesCompanyIdPeopleBatchesHomeAddress | undefined;
  /**
   * Specify the company work location for the employee
   */
  workAddress?: PostV1CompaniesCompanyIdPeopleBatchesWorkAddress | undefined;
  /**
   * Job details for the employee (required if compensation is provided)
   */
  job?: PostV1CompaniesCompanyIdPeopleBatchesJob | undefined;
  /**
   * Department details for the employee
   */
  department?: Department | undefined;
  /**
   * Compensation details for the employee (requires job to be provided)
   */
  compensation?: Compensation | undefined;
  /**
   * Creates employee bank accounts and payment methods for direct deposit. If splitting payments by amount, the priority is set based on the order of the bank accounts in the array and the last bank account is the remainder account (should have `split_amount` set to `null`).
   */
  bankAccounts?: Array<BankAccount> | undefined;
};

export type PostV1CompaniesCompanyIdPeopleBatchesRequestBody = {
  /**
   * A unique identifier to ensure idempotency of the batch request
   */
  idempotencyKey: string;
  /**
   * The action to perform on the batch
   */
  batchAction: BatchAction;
  /**
   * Array of people to create
   */
  batch: Array<Batch>;
};

export type PostV1CompaniesCompanyIdPeopleBatchesRequest = {
  /**
   * The UUID of the company
   */
  companyId: string;
  /**
   * Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
   */
  xGustoAPIVersion?:
    | PostV1CompaniesCompanyIdPeopleBatchesXGustoAPIVersion
    | undefined;
  body: PostV1CompaniesCompanyIdPeopleBatchesRequestBody;
};

export type PostV1CompaniesCompanyIdPeopleBatchesMetadata = {
  entityUuid?: string | undefined;
  entityType?: string | undefined;
};

export type PostV1CompaniesCompanyIdPeopleBatchesError = {
  errorKey?: string | undefined;
  category?: string | undefined;
  message?: string | undefined;
  metadata?: PostV1CompaniesCompanyIdPeopleBatchesMetadata | undefined;
};

export const PostV1CompaniesCompanyIdPeopleBatchesStatus = {
  Pending: "pending",
  Processing: "processing",
  Completed: "completed",
  Failed: "failed",
} as const;
export type PostV1CompaniesCompanyIdPeopleBatchesStatus = OpenEnum<
  typeof PostV1CompaniesCompanyIdPeopleBatchesStatus
>;

/**
 * created
 */
export type PostV1CompaniesCompanyIdPeopleBatchesResponse = {
  uuid?: string | undefined;
  idempotencyKey?: string | undefined;
  status?: PostV1CompaniesCompanyIdPeopleBatchesStatus | undefined;
  batchAction?: string | undefined;
};

/** @internal */
export const PostV1CompaniesCompanyIdPeopleBatchesXGustoAPIVersion$outboundSchema:
  z.ZodMiniEnum<typeof PostV1CompaniesCompanyIdPeopleBatchesXGustoAPIVersion> =
    z.enum(PostV1CompaniesCompanyIdPeopleBatchesXGustoAPIVersion);

/** @internal */
export const BatchAction$outboundSchema: z.ZodMiniEnum<typeof BatchAction> = z
  .enum(BatchAction);

/** @internal */
export const EntityType$outboundSchema: z.ZodMiniEnum<typeof EntityType> = z
  .enum(EntityType);

/** @internal */
export type Person$Outbound = {
  external_id: string;
  first_name: string;
  last_name: string;
  middle_initial?: string | null | undefined;
  preferred_first_name?: string | null | undefined;
  email?: string | null | undefined;
  work_email?: string | null | undefined;
  ssn?: string | null | undefined;
  date_of_birth?: string | null | undefined;
  self_onboarding?: boolean | null | undefined;
};

/** @internal */
export const Person$outboundSchema: z.ZodMiniType<Person$Outbound, Person> = z
  .pipe(
    z.object({
      externalId: z.string(),
      firstName: z.string(),
      lastName: z.string(),
      middleInitial: z.optional(z.nullable(z.string())),
      preferredFirstName: z.optional(z.nullable(z.string())),
      email: z.optional(z.nullable(z.string())),
      workEmail: z.optional(z.nullable(z.string())),
      ssn: z.optional(z.nullable(z.string())),
      dateOfBirth: z.optional(z.nullable(z.pipe(
        z.date(),
        z.transform(v => v.toISOString().slice(0, "YYYY-MM-DD".length)),
      ))),
      selfOnboarding: z.optional(z.nullable(z.boolean())),
    }),
    z.transform((v) => {
      return remap$(v, {
        externalId: "external_id",
        firstName: "first_name",
        lastName: "last_name",
        middleInitial: "middle_initial",
        preferredFirstName: "preferred_first_name",
        workEmail: "work_email",
        dateOfBirth: "date_of_birth",
        selfOnboarding: "self_onboarding",
      });
    }),
  );

export function personToJSON(person: Person): string {
  return JSON.stringify(Person$outboundSchema.parse(person));
}

/** @internal */
export type PostV1CompaniesCompanyIdPeopleBatchesHomeAddress$Outbound = {
  street_1: string;
  street_2?: string | undefined;
  city: string;
  state: string;
  zip: string;
  country?: string | undefined;
  work_from_home?: boolean | undefined;
};

/** @internal */
export const PostV1CompaniesCompanyIdPeopleBatchesHomeAddress$outboundSchema:
  z.ZodMiniType<
    PostV1CompaniesCompanyIdPeopleBatchesHomeAddress$Outbound,
    PostV1CompaniesCompanyIdPeopleBatchesHomeAddress
  > = z.pipe(
    z.object({
      street1: z.string(),
      street2: z.optional(z.string()),
      city: z.string(),
      state: z.string(),
      zip: z.string(),
      country: z.optional(z.string()),
      workFromHome: z.optional(z.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        street1: "street_1",
        street2: "street_2",
        workFromHome: "work_from_home",
      });
    }),
  );

export function postV1CompaniesCompanyIdPeopleBatchesHomeAddressToJSON(
  postV1CompaniesCompanyIdPeopleBatchesHomeAddress:
    PostV1CompaniesCompanyIdPeopleBatchesHomeAddress,
): string {
  return JSON.stringify(
    PostV1CompaniesCompanyIdPeopleBatchesHomeAddress$outboundSchema.parse(
      postV1CompaniesCompanyIdPeopleBatchesHomeAddress,
    ),
  );
}

/** @internal */
export type PostV1CompaniesCompanyIdPeopleBatchesWorkAddress$Outbound = {
  location_uuid: string;
};

/** @internal */
export const PostV1CompaniesCompanyIdPeopleBatchesWorkAddress$outboundSchema:
  z.ZodMiniType<
    PostV1CompaniesCompanyIdPeopleBatchesWorkAddress$Outbound,
    PostV1CompaniesCompanyIdPeopleBatchesWorkAddress
  > = z.pipe(
    z.object({
      locationUuid: z.string(),
    }),
    z.transform((v) => {
      return remap$(v, {
        locationUuid: "location_uuid",
      });
    }),
  );

export function postV1CompaniesCompanyIdPeopleBatchesWorkAddressToJSON(
  postV1CompaniesCompanyIdPeopleBatchesWorkAddress:
    PostV1CompaniesCompanyIdPeopleBatchesWorkAddress,
): string {
  return JSON.stringify(
    PostV1CompaniesCompanyIdPeopleBatchesWorkAddress$outboundSchema.parse(
      postV1CompaniesCompanyIdPeopleBatchesWorkAddress,
    ),
  );
}

/** @internal */
export type PostV1CompaniesCompanyIdPeopleBatchesJob$Outbound = {
  title: string;
  hire_date: string;
  two_percent_shareholder?: boolean | undefined;
  state_wc_covered?: boolean | null | undefined;
  state_wc_class_code?: string | null | undefined;
};

/** @internal */
export const PostV1CompaniesCompanyIdPeopleBatchesJob$outboundSchema:
  z.ZodMiniType<
    PostV1CompaniesCompanyIdPeopleBatchesJob$Outbound,
    PostV1CompaniesCompanyIdPeopleBatchesJob
  > = z.pipe(
    z.object({
      title: z.string(),
      hireDate: z.pipe(
        z.date(),
        z.transform(v => v.toISOString().slice(0, "YYYY-MM-DD".length)),
      ),
      twoPercentShareholder: z.optional(z.boolean()),
      stateWcCovered: z.optional(z.nullable(z.boolean())),
      stateWcClassCode: z.optional(z.nullable(z.string())),
    }),
    z.transform((v) => {
      return remap$(v, {
        hireDate: "hire_date",
        twoPercentShareholder: "two_percent_shareholder",
        stateWcCovered: "state_wc_covered",
        stateWcClassCode: "state_wc_class_code",
      });
    }),
  );

export function postV1CompaniesCompanyIdPeopleBatchesJobToJSON(
  postV1CompaniesCompanyIdPeopleBatchesJob:
    PostV1CompaniesCompanyIdPeopleBatchesJob,
): string {
  return JSON.stringify(
    PostV1CompaniesCompanyIdPeopleBatchesJob$outboundSchema.parse(
      postV1CompaniesCompanyIdPeopleBatchesJob,
    ),
  );
}

/** @internal */
export type Department$Outbound = {
  department_uuid: string;
};

/** @internal */
export const Department$outboundSchema: z.ZodMiniType<
  Department$Outbound,
  Department
> = z.pipe(
  z.object({
    departmentUuid: z.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      departmentUuid: "department_uuid",
    });
  }),
);

export function departmentToJSON(department: Department): string {
  return JSON.stringify(Department$outboundSchema.parse(department));
}

/** @internal */
export const PostV1CompaniesCompanyIdPeopleBatchesPaymentUnit$outboundSchema:
  z.ZodMiniEnum<typeof PostV1CompaniesCompanyIdPeopleBatchesPaymentUnit> = z
    .enum(PostV1CompaniesCompanyIdPeopleBatchesPaymentUnit);

/** @internal */
export const FlsaStatus$outboundSchema: z.ZodMiniEnum<typeof FlsaStatus> = z
  .enum(FlsaStatus);

/** @internal */
export type Compensation$Outbound = {
  rate: string;
  payment_unit: string;
  effective_date?: string | undefined;
  flsa_status: string;
};

/** @internal */
export const Compensation$outboundSchema: z.ZodMiniType<
  Compensation$Outbound,
  Compensation
> = z.pipe(
  z.object({
    rate: z.string(),
    paymentUnit:
      PostV1CompaniesCompanyIdPeopleBatchesPaymentUnit$outboundSchema,
    effectiveDate: z.optional(z.pipe(
      z.date(),
      z.transform(v => v.toISOString().slice(0, "YYYY-MM-DD".length)),
    )),
    flsaStatus: FlsaStatus$outboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      paymentUnit: "payment_unit",
      effectiveDate: "effective_date",
      flsaStatus: "flsa_status",
    });
  }),
);

export function compensationToJSON(compensation: Compensation): string {
  return JSON.stringify(Compensation$outboundSchema.parse(compensation));
}

/** @internal */
export const PostV1CompaniesCompanyIdPeopleBatchesAccountType$outboundSchema:
  z.ZodMiniEnum<typeof PostV1CompaniesCompanyIdPeopleBatchesAccountType> = z
    .enum(PostV1CompaniesCompanyIdPeopleBatchesAccountType);

/** @internal */
export const PostV1CompaniesCompanyIdPeopleBatchesType$outboundSchema:
  z.ZodMiniEnum<typeof PostV1CompaniesCompanyIdPeopleBatchesType> = z.enum(
    PostV1CompaniesCompanyIdPeopleBatchesType,
  );

/** @internal */
export const PostV1CompaniesCompanyIdPeopleBatchesSplitBy$outboundSchema:
  z.ZodMiniEnum<typeof PostV1CompaniesCompanyIdPeopleBatchesSplitBy> = z.enum(
    PostV1CompaniesCompanyIdPeopleBatchesSplitBy,
  );

/** @internal */
export type BankAccount$Outbound = {
  name?: string | null | undefined;
  account_type: string;
  routing_number: string;
  account_number: string;
  type: string;
  split_by: string;
  split_amount?: string | null | undefined;
};

/** @internal */
export const BankAccount$outboundSchema: z.ZodMiniType<
  BankAccount$Outbound,
  BankAccount
> = z.pipe(
  z.object({
    name: z.optional(z.nullable(z.string())),
    accountType:
      PostV1CompaniesCompanyIdPeopleBatchesAccountType$outboundSchema,
    routingNumber: z.string(),
    accountNumber: z.string(),
    type: PostV1CompaniesCompanyIdPeopleBatchesType$outboundSchema,
    splitBy: PostV1CompaniesCompanyIdPeopleBatchesSplitBy$outboundSchema,
    splitAmount: z.optional(z.nullable(z.string())),
  }),
  z.transform((v) => {
    return remap$(v, {
      accountType: "account_type",
      routingNumber: "routing_number",
      accountNumber: "account_number",
      splitBy: "split_by",
      splitAmount: "split_amount",
    });
  }),
);

export function bankAccountToJSON(bankAccount: BankAccount): string {
  return JSON.stringify(BankAccount$outboundSchema.parse(bankAccount));
}

/** @internal */
export type Batch$Outbound = {
  entity_type: string;
  person: Person$Outbound;
  home_address?:
    | PostV1CompaniesCompanyIdPeopleBatchesHomeAddress$Outbound
    | undefined;
  work_address?:
    | PostV1CompaniesCompanyIdPeopleBatchesWorkAddress$Outbound
    | undefined;
  job?: PostV1CompaniesCompanyIdPeopleBatchesJob$Outbound | undefined;
  department?: Department$Outbound | undefined;
  compensation?: Compensation$Outbound | undefined;
  bank_accounts?: Array<BankAccount$Outbound> | undefined;
};

/** @internal */
export const Batch$outboundSchema: z.ZodMiniType<Batch$Outbound, Batch> = z
  .pipe(
    z.object({
      entityType: EntityType$outboundSchema,
      person: z.lazy(() => Person$outboundSchema),
      homeAddress: z.optional(z.lazy(() =>
        PostV1CompaniesCompanyIdPeopleBatchesHomeAddress$outboundSchema
      )),
      workAddress: z.optional(z.lazy(() =>
        PostV1CompaniesCompanyIdPeopleBatchesWorkAddress$outboundSchema
      )),
      job: z.optional(z.lazy(() =>
        PostV1CompaniesCompanyIdPeopleBatchesJob$outboundSchema
      )),
      department: z.optional(z.lazy(() =>
        Department$outboundSchema
      )),
      compensation: z.optional(z.lazy(() =>
        Compensation$outboundSchema
      )),
      bankAccounts: z.optional(
        z.array(z.lazy(() => BankAccount$outboundSchema)),
      ),
    }),
    z.transform((v) => {
      return remap$(v, {
        entityType: "entity_type",
        homeAddress: "home_address",
        workAddress: "work_address",
        bankAccounts: "bank_accounts",
      });
    }),
  );

export function batchToJSON(batch: Batch): string {
  return JSON.stringify(Batch$outboundSchema.parse(batch));
}

/** @internal */
export type PostV1CompaniesCompanyIdPeopleBatchesRequestBody$Outbound = {
  idempotency_key: string;
  batch_action: string;
  batch: Array<Batch$Outbound>;
};

/** @internal */
export const PostV1CompaniesCompanyIdPeopleBatchesRequestBody$outboundSchema:
  z.ZodMiniType<
    PostV1CompaniesCompanyIdPeopleBatchesRequestBody$Outbound,
    PostV1CompaniesCompanyIdPeopleBatchesRequestBody
  > = z.pipe(
    z.object({
      idempotencyKey: z.string(),
      batchAction: BatchAction$outboundSchema,
      batch: z.array(z.lazy(() => Batch$outboundSchema)),
    }),
    z.transform((v) => {
      return remap$(v, {
        idempotencyKey: "idempotency_key",
        batchAction: "batch_action",
      });
    }),
  );

export function postV1CompaniesCompanyIdPeopleBatchesRequestBodyToJSON(
  postV1CompaniesCompanyIdPeopleBatchesRequestBody:
    PostV1CompaniesCompanyIdPeopleBatchesRequestBody,
): string {
  return JSON.stringify(
    PostV1CompaniesCompanyIdPeopleBatchesRequestBody$outboundSchema.parse(
      postV1CompaniesCompanyIdPeopleBatchesRequestBody,
    ),
  );
}

/** @internal */
export type PostV1CompaniesCompanyIdPeopleBatchesRequest$Outbound = {
  company_id: string;
  "X-Gusto-API-Version": string;
  body: PostV1CompaniesCompanyIdPeopleBatchesRequestBody$Outbound;
};

/** @internal */
export const PostV1CompaniesCompanyIdPeopleBatchesRequest$outboundSchema:
  z.ZodMiniType<
    PostV1CompaniesCompanyIdPeopleBatchesRequest$Outbound,
    PostV1CompaniesCompanyIdPeopleBatchesRequest
  > = z.pipe(
    z.object({
      companyId: z.string(),
      xGustoAPIVersion: z._default(
        PostV1CompaniesCompanyIdPeopleBatchesXGustoAPIVersion$outboundSchema,
        "2025-06-15",
      ),
      body: z.lazy(() =>
        PostV1CompaniesCompanyIdPeopleBatchesRequestBody$outboundSchema
      ),
    }),
    z.transform((v) => {
      return remap$(v, {
        companyId: "company_id",
        xGustoAPIVersion: "X-Gusto-API-Version",
      });
    }),
  );

export function postV1CompaniesCompanyIdPeopleBatchesRequestToJSON(
  postV1CompaniesCompanyIdPeopleBatchesRequest:
    PostV1CompaniesCompanyIdPeopleBatchesRequest,
): string {
  return JSON.stringify(
    PostV1CompaniesCompanyIdPeopleBatchesRequest$outboundSchema.parse(
      postV1CompaniesCompanyIdPeopleBatchesRequest,
    ),
  );
}

/** @internal */
export const PostV1CompaniesCompanyIdPeopleBatchesMetadata$inboundSchema:
  z.ZodMiniType<PostV1CompaniesCompanyIdPeopleBatchesMetadata, unknown> = z
    .pipe(
      z.object({
        entity_uuid: types.optional(types.string()),
        entity_type: types.optional(types.string()),
      }),
      z.transform((v) => {
        return remap$(v, {
          "entity_uuid": "entityUuid",
          "entity_type": "entityType",
        });
      }),
    );

export function postV1CompaniesCompanyIdPeopleBatchesMetadataFromJSON(
  jsonString: string,
): SafeParseResult<
  PostV1CompaniesCompanyIdPeopleBatchesMetadata,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostV1CompaniesCompanyIdPeopleBatchesMetadata$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostV1CompaniesCompanyIdPeopleBatchesMetadata' from JSON`,
  );
}

/** @internal */
export const PostV1CompaniesCompanyIdPeopleBatchesError$inboundSchema:
  z.ZodMiniType<PostV1CompaniesCompanyIdPeopleBatchesError, unknown> = z.pipe(
    z.object({
      error_key: types.optional(types.string()),
      category: types.optional(types.string()),
      message: types.optional(types.string()),
      metadata: types.optional(z.lazy(() =>
        PostV1CompaniesCompanyIdPeopleBatchesMetadata$inboundSchema
      )),
    }),
    z.transform((v) => {
      return remap$(v, {
        "error_key": "errorKey",
      });
    }),
  );

export function postV1CompaniesCompanyIdPeopleBatchesErrorFromJSON(
  jsonString: string,
): SafeParseResult<
  PostV1CompaniesCompanyIdPeopleBatchesError,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostV1CompaniesCompanyIdPeopleBatchesError$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostV1CompaniesCompanyIdPeopleBatchesError' from JSON`,
  );
}

/** @internal */
export const PostV1CompaniesCompanyIdPeopleBatchesStatus$inboundSchema:
  z.ZodMiniType<PostV1CompaniesCompanyIdPeopleBatchesStatus, unknown> =
    openEnums.inboundSchema(PostV1CompaniesCompanyIdPeopleBatchesStatus);

/** @internal */
export const PostV1CompaniesCompanyIdPeopleBatchesResponse$inboundSchema:
  z.ZodMiniType<PostV1CompaniesCompanyIdPeopleBatchesResponse, unknown> = z
    .pipe(
      z.object({
        uuid: types.optional(types.string()),
        idempotency_key: types.optional(types.string()),
        status: types.optional(
          PostV1CompaniesCompanyIdPeopleBatchesStatus$inboundSchema,
        ),
        batch_action: types.optional(types.string()),
      }),
      z.transform((v) => {
        return remap$(v, {
          "idempotency_key": "idempotencyKey",
          "batch_action": "batchAction",
        });
      }),
    );

export function postV1CompaniesCompanyIdPeopleBatchesResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  PostV1CompaniesCompanyIdPeopleBatchesResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostV1CompaniesCompanyIdPeopleBatchesResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostV1CompaniesCompanyIdPeopleBatchesResponse' from JSON`,
  );
}

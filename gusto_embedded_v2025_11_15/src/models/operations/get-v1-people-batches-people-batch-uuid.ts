/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

/**
 * Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
 */
export const GetV1PeopleBatchesPeopleBatchUuidXGustoAPIVersion = {
  TwoThousandAndTwentyFiveMinus06Minus15: "2025-06-15",
} as const;
/**
 * Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
 */
export type GetV1PeopleBatchesPeopleBatchUuidXGustoAPIVersion = ClosedEnum<
  typeof GetV1PeopleBatchesPeopleBatchUuidXGustoAPIVersion
>;

export type GetV1PeopleBatchesPeopleBatchUuidRequest = {
  /**
   * The UUID of the people batch
   */
  peopleBatchUuid: string;
  /**
   * Determines the date-based API version associated with your API call. If none is provided, your application's [minimum API version](https://docs.gusto.com/embedded-payroll/docs/api-versioning#minimum-api-version) is used.
   */
  xGustoAPIVersion?:
    | GetV1PeopleBatchesPeopleBatchUuidXGustoAPIVersion
    | undefined;
};

export const GetV1PeopleBatchesPeopleBatchUuidStatus = {
  Pending: "pending",
  Processing: "processing",
  Completed: "completed",
  Failed: "failed",
  PartialSuccess: "partial_success",
} as const;
export type GetV1PeopleBatchesPeopleBatchUuidStatus = OpenEnum<
  typeof GetV1PeopleBatchesPeopleBatchUuidStatus
>;

/**
 * The type of person created
 */
export const Role = {
  Employee: "employee",
} as const;
/**
 * The type of person created
 */
export type Role = ClosedEnum<typeof Role>;

/**
 * The status of this batch item
 */
export const StatusEmployee = {
  Success: "success",
  PartialSuccess: "partial_success",
  Failed: "failed",
} as const;
/**
 * The status of this batch item
 */
export type StatusEmployee = OpenEnum<typeof StatusEmployee>;

export type GetV1PeopleBatchesPeopleBatchUuidError1 = {};

export type GetV1PeopleBatchesPeopleBatchUuidError2 = {
  /**
   * The key identifying the error source
   */
  errorKey?: string | undefined;
  /**
   * The error category
   */
  category?: string | undefined;
  /**
   * Human-readable error message
   */
  message?: string | null | undefined;
  /**
   * Nested errors for sub-operations
   */
  errors?: Array<GetV1PeopleBatchesPeopleBatchUuidError1> | null | undefined;
};

export type Result = {
  /**
   * The external ID provided in the batch request
   */
  externalId?: string | undefined;
  /**
   * The type of person created
   */
  role?: Role | undefined;
  /**
   * The status of this batch item
   */
  status?: StatusEmployee | undefined;
  /**
   * The index of this item in the original batch request
   */
  idx?: number | undefined;
  /**
   * The UUID of the created person
   */
  uuid?: string | undefined;
  /**
   * The UUID of the created employee (if role is employee)
   */
  employeeUuid?: string | undefined;
  /**
   * Errors encountered while processing this batch item
   */
  errors?: Array<GetV1PeopleBatchesPeopleBatchUuidError2> | null | undefined;
};

export type Exclusion = {
  /**
   * The external ID of the excluded item(s)
   */
  externalId?: string | undefined;
  /**
   * The reason code for exclusion
   */
  reasonCode?: string | undefined;
  /**
   * Human-readable explanation for exclusion
   */
  message?: string | undefined;
  /**
   * Number of items affected by this exclusion
   */
  itemCount?: number | undefined;
};

/**
 * successful
 */
export type GetV1PeopleBatchesPeopleBatchUuidResponse = {
  uuid?: string | undefined;
  idempotencyKey?: string | undefined;
  status?: GetV1PeopleBatchesPeopleBatchUuidStatus | undefined;
  submittedAt?: Date | undefined;
  completedAt?: Date | null | undefined;
  submittedItems?: number | null | undefined;
  processedItems?: number | undefined;
  excludedItems?: number | undefined;
  results?: Array<Result> | undefined;
  /**
   * Items excluded from processing due to validation errors
   */
  exclusions?: Array<Exclusion> | null | undefined;
};

/** @internal */
export const GetV1PeopleBatchesPeopleBatchUuidXGustoAPIVersion$outboundSchema:
  z.ZodMiniEnum<typeof GetV1PeopleBatchesPeopleBatchUuidXGustoAPIVersion> = z
    .enum(GetV1PeopleBatchesPeopleBatchUuidXGustoAPIVersion);

/** @internal */
export type GetV1PeopleBatchesPeopleBatchUuidRequest$Outbound = {
  people_batch_uuid: string;
  "X-Gusto-API-Version": string;
};

/** @internal */
export const GetV1PeopleBatchesPeopleBatchUuidRequest$outboundSchema:
  z.ZodMiniType<
    GetV1PeopleBatchesPeopleBatchUuidRequest$Outbound,
    GetV1PeopleBatchesPeopleBatchUuidRequest
  > = z.pipe(
    z.object({
      peopleBatchUuid: z.string(),
      xGustoAPIVersion: z._default(
        GetV1PeopleBatchesPeopleBatchUuidXGustoAPIVersion$outboundSchema,
        "2025-06-15",
      ),
    }),
    z.transform((v) => {
      return remap$(v, {
        peopleBatchUuid: "people_batch_uuid",
        xGustoAPIVersion: "X-Gusto-API-Version",
      });
    }),
  );

export function getV1PeopleBatchesPeopleBatchUuidRequestToJSON(
  getV1PeopleBatchesPeopleBatchUuidRequest:
    GetV1PeopleBatchesPeopleBatchUuidRequest,
): string {
  return JSON.stringify(
    GetV1PeopleBatchesPeopleBatchUuidRequest$outboundSchema.parse(
      getV1PeopleBatchesPeopleBatchUuidRequest,
    ),
  );
}

/** @internal */
export const GetV1PeopleBatchesPeopleBatchUuidStatus$inboundSchema:
  z.ZodMiniType<GetV1PeopleBatchesPeopleBatchUuidStatus, unknown> = openEnums
    .inboundSchema(GetV1PeopleBatchesPeopleBatchUuidStatus);

/** @internal */
export const Role$inboundSchema: z.ZodMiniEnum<typeof Role> = z.enum(Role);

/** @internal */
export const StatusEmployee$inboundSchema: z.ZodMiniType<
  StatusEmployee,
  unknown
> = openEnums.inboundSchema(StatusEmployee);

/** @internal */
export const GetV1PeopleBatchesPeopleBatchUuidError1$inboundSchema:
  z.ZodMiniType<GetV1PeopleBatchesPeopleBatchUuidError1, unknown> = z.object(
    {},
  );

export function getV1PeopleBatchesPeopleBatchUuidError1FromJSON(
  jsonString: string,
): SafeParseResult<
  GetV1PeopleBatchesPeopleBatchUuidError1,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetV1PeopleBatchesPeopleBatchUuidError1$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetV1PeopleBatchesPeopleBatchUuidError1' from JSON`,
  );
}

/** @internal */
export const GetV1PeopleBatchesPeopleBatchUuidError2$inboundSchema:
  z.ZodMiniType<GetV1PeopleBatchesPeopleBatchUuidError2, unknown> = z.pipe(
    z.object({
      error_key: types.optional(types.string()),
      category: types.optional(types.string()),
      message: z.optional(z.nullable(types.string())),
      errors: z.optional(z.nullable(z.array(z.lazy(() =>
        GetV1PeopleBatchesPeopleBatchUuidError1$inboundSchema
      )))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "error_key": "errorKey",
      });
    }),
  );

export function getV1PeopleBatchesPeopleBatchUuidError2FromJSON(
  jsonString: string,
): SafeParseResult<
  GetV1PeopleBatchesPeopleBatchUuidError2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetV1PeopleBatchesPeopleBatchUuidError2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetV1PeopleBatchesPeopleBatchUuidError2' from JSON`,
  );
}

/** @internal */
export const Result$inboundSchema: z.ZodMiniType<Result, unknown> = z.pipe(
  z.object({
    external_id: types.optional(types.string()),
    role: types.optional(Role$inboundSchema),
    status: types.optional(StatusEmployee$inboundSchema),
    idx: types.optional(types.number()),
    uuid: types.optional(types.string()),
    employee_uuid: types.optional(types.string()),
    errors: z.optional(z.nullable(z.array(z.lazy(() =>
      GetV1PeopleBatchesPeopleBatchUuidError2$inboundSchema
    )))),
  }),
  z.transform((v) => {
    return remap$(v, {
      "external_id": "externalId",
      "employee_uuid": "employeeUuid",
    });
  }),
);

export function resultFromJSON(
  jsonString: string,
): SafeParseResult<Result, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Result$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Result' from JSON`,
  );
}

/** @internal */
export const Exclusion$inboundSchema: z.ZodMiniType<Exclusion, unknown> = z
  .pipe(
    z.object({
      external_id: types.optional(types.string()),
      reason_code: types.optional(types.string()),
      message: types.optional(types.string()),
      item_count: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "external_id": "externalId",
        "reason_code": "reasonCode",
        "item_count": "itemCount",
      });
    }),
  );

export function exclusionFromJSON(
  jsonString: string,
): SafeParseResult<Exclusion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Exclusion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Exclusion' from JSON`,
  );
}

/** @internal */
export const GetV1PeopleBatchesPeopleBatchUuidResponse$inboundSchema:
  z.ZodMiniType<GetV1PeopleBatchesPeopleBatchUuidResponse, unknown> = z.pipe(
    z.object({
      uuid: types.optional(types.string()),
      idempotency_key: types.optional(types.string()),
      status: types.optional(
        GetV1PeopleBatchesPeopleBatchUuidStatus$inboundSchema,
      ),
      submitted_at: types.optional(types.date()),
      completed_at: z.optional(z.nullable(types.date())),
      submitted_items: z.optional(z.nullable(types.number())),
      processed_items: types.optional(types.number()),
      excluded_items: types.optional(types.number()),
      results: types.optional(z.array(z.lazy(() => Result$inboundSchema))),
      exclusions: z.optional(z.nullable(z.array(z.lazy(() =>
        Exclusion$inboundSchema
      )))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "idempotency_key": "idempotencyKey",
        "submitted_at": "submittedAt",
        "completed_at": "completedAt",
        "submitted_items": "submittedItems",
        "processed_items": "processedItems",
        "excluded_items": "excludedItems",
      });
    }),
  );

export function getV1PeopleBatchesPeopleBatchUuidResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  GetV1PeopleBatchesPeopleBatchUuidResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetV1PeopleBatchesPeopleBatchUuidResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetV1PeopleBatchesPeopleBatchUuidResponse' from JSON`,
  );
}

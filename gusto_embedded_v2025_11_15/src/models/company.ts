/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import {
  CompanyAddress,
  CompanyAddress$inboundSchema,
} from "./company-address.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";

/**
 * The tax payer type of the company.
 */
export const CompanyEntityType = {
  CCorporation: "C-Corporation",
  SCorporation: "S-Corporation",
  SoleProprietor: "Sole proprietor",
  Llc: "LLC",
  Llp: "LLP",
  LimitedPartnership: "Limited partnership",
  CoOwnership: "Co-ownership",
  Association: "Association",
  Trusteeship: "Trusteeship",
  GeneralPartnership: "General partnership",
  JointVenture: "Joint venture",
  NonProfit: "Non-Profit",
} as const;
/**
 * The tax payer type of the company.
 */
export type CompanyEntityType = OpenEnum<typeof CompanyEntityType>;

/**
 * The Gusto product tier of the company (not applicable to Embedded partner managed companies).
 */
export const TierEnum = {
  Simple: "simple",
  Plus: "plus",
  Premium: "premium",
  Core: "core",
  Complete: "complete",
  Concierge: "concierge",
  ContractorOnly: "contractor_only",
  Basic: "basic",
} as const;
/**
 * The Gusto product tier of the company (not applicable to Embedded partner managed companies).
 */
export type TierEnum = OpenEnum<typeof TierEnum>;

/**
 * The status of the company in Gusto. "Approved" companies are approved to run payroll from a risk and compliance perspective. However, an approved company may still need to resolve other [payroll blockers](https://docs.gusto.com/embedded-payroll/docs/payroll-blockers) to be able to run payroll. "Not Approved" companies may not yet run payroll with Gusto and may need to complete onboarding or contact support. "Suspended" companies may not run payroll with Gusto. In order to unsuspend their account, the company must contact support.
 */
export const CompanyStatus = {
  Approved: "Approved",
  NotApproved: "Not Approved",
  Suspended: "Suspended",
} as const;
/**
 * The status of the company in Gusto. "Approved" companies are approved to run payroll from a risk and compliance perspective. However, an approved company may still need to resolve other [payroll blockers](https://docs.gusto.com/embedded-payroll/docs/payroll-blockers) to be able to run payroll. "Not Approved" companies may not yet run payroll with Gusto and may need to complete onboarding or contact support. "Suspended" companies may not run payroll with Gusto. In order to unsuspend their account, the company must contact support.
 */
export type CompanyStatus = OpenEnum<typeof CompanyStatus>;

export const PayScheduleType = {
  Single: "single",
  HourlySalaried: "hourly_salaried",
  ByEmployee: "by_employee",
  ByDepartment: "by_department",
} as const;
export type PayScheduleType = OpenEnum<typeof PayScheduleType>;

/**
 * Company's default funding type
 */
export const FundingType = {
  Ach: "ach",
  ReverseWire: "reverse_wire",
  WireIn: "wire_in",
  Brex: "brex",
} as const;
/**
 * Company's default funding type
 */
export type FundingType = OpenEnum<typeof FundingType>;

export type Hourly = {
  /**
   * The name of the hourly compensation rate.
   */
  name?: string | undefined;
  /**
   * The amount multiplied by the base rate of a job to calculate compensation.
   */
  multiple?: number | undefined;
};

export type Fixed = {
  /**
   * The name of the fixed compensation.
   */
  name?: string | undefined;
};

export type CompanyPaidTimeOff = {
  /**
   * The name of the paid time off type.
   */
  name?: string | undefined;
};

/**
 * The available company-wide compensation rates for the company.
 */
export type Compensations = {
  /**
   * The available hourly compensation rates for the company.
   */
  hourly?: Array<Hourly> | undefined;
  /**
   * The available fixed compensation rates for the company.
   */
  fixed?: Array<Fixed> | undefined;
  /**
   * The available types of paid time off for the company.
   */
  paidTimeOff?: Array<CompanyPaidTimeOff> | undefined;
};

/**
 * The company's primary signatory's home address.
 */
export type CompanyHomeAddress = {
  street1?: string | undefined;
  street2?: string | null | undefined;
  city?: string | undefined;
  state?: string | undefined;
  zip?: string | undefined;
  country?: string | undefined;
};

/**
 * The primary signatory of the company.
 */
export type PrimarySignatory = {
  /**
   * The UUID of the company's primary signatory.
   */
  uuid?: string | undefined;
  /**
   * The company's primary signatory's first name.
   */
  firstName?: string | undefined;
  /**
   * The company's primary signatory's middle initial.
   */
  middleInitial?: string | null | undefined;
  /**
   * The company's primary signatory's last name.
   */
  lastName?: string | undefined;
  /**
   * The company's primary signatory's phone number.
   */
  phone?: string | undefined;
  /**
   * The company's primary signatory's email address.
   */
  email?: string | undefined;
  /**
   * The company's primary signatory's home address.
   */
  homeAddress?: CompanyHomeAddress | undefined;
};

/**
 * The primary payroll admin of the company.
 */
export type PrimaryPayrollAdmin = {
  /**
   * The company's primary payroll admin's first name.
   */
  firstName?: string | undefined;
  /**
   * The company's primary payroll admin's last name.
   */
  lastName?: string | undefined;
  /**
   * The company's primary payroll admin's phone number.
   */
  phone?: string | null | undefined;
  /**
   * The company's primary payroll admin's email address.
   */
  email?: string | undefined;
};

/**
 * The representation of a company in Gusto.
 */
export type Company = {
  /**
   * The Federal Employer Identification Number of the company.
   */
  ein?: string | undefined;
  /**
   * The tax payer type of the company.
   */
  entityType?: CompanyEntityType | null | undefined;
  /**
   * Whether the company only supports contractors.
   */
  contractorOnly?: boolean | undefined;
  /**
   * The Gusto product tier of the company (not applicable to Embedded partner managed companies).
   */
  tier?: TierEnum | null | undefined;
  /**
   * Whether or not the company is suspended in Gusto. Suspended companies may not run payroll.
   */
  isSuspended?: boolean | undefined;
  /**
   * The status of the company in Gusto. "Approved" companies are approved to run payroll from a risk and compliance perspective. However, an approved company may still need to resolve other [payroll blockers](https://docs.gusto.com/embedded-payroll/docs/payroll-blockers) to be able to run payroll. "Not Approved" companies may not yet run payroll with Gusto and may need to complete onboarding or contact support. "Suspended" companies may not run payroll with Gusto. In order to unsuspend their account, the company must contact support.
   */
  companyStatus?: CompanyStatus | undefined;
  /**
   * Whether or not Gusto has identified the company as representing a high fraud risk.
   */
  isHighRiskBusiness?: boolean | undefined;
  /**
   * Whether or not the company is a marijuana-related business.
   */
  isMarijuanaBusiness?: boolean | undefined;
  /**
   * A unique identifier of the company in Gusto.
   */
  uuid: string;
  /**
   * The name of the company.
   */
  name?: string | undefined;
  /**
   * The slug of the name of the company.
   */
  slug?: string | undefined;
  /**
   * The trade name of the company.
   */
  tradeName?: string | null | undefined;
  /**
   * Whether the company is fully managed by a partner via the API
   */
  isPartnerManaged?: boolean | undefined;
  /**
   * The pay schedule assignment type.
   */
  payScheduleType?: PayScheduleType | null | undefined;
  /**
   * Company's first invoiceable event date
   */
  joinDate?: string | null | undefined;
  /**
   * Company's default funding type
   */
  fundingType?: FundingType | null | undefined;
  /**
   * The locations of the company.
   */
  locations?: Array<CompanyAddress> | undefined;
  /**
   * The available company-wide compensation rates for the company.
   */
  compensations?: Compensations | undefined;
  /**
   * The primary signatory of the company.
   */
  primarySignatory?: PrimarySignatory | null | undefined;
  /**
   * The primary payroll admin of the company.
   */
  primaryPayrollAdmin?: PrimaryPayrollAdmin | undefined;
};

/** @internal */
export const CompanyEntityType$inboundSchema: z.ZodMiniType<
  CompanyEntityType,
  unknown
> = openEnums.inboundSchema(CompanyEntityType);

/** @internal */
export const TierEnum$inboundSchema: z.ZodMiniType<TierEnum, unknown> =
  openEnums.inboundSchema(TierEnum);

/** @internal */
export const CompanyStatus$inboundSchema: z.ZodMiniType<
  CompanyStatus,
  unknown
> = openEnums.inboundSchema(CompanyStatus);

/** @internal */
export const PayScheduleType$inboundSchema: z.ZodMiniType<
  PayScheduleType,
  unknown
> = openEnums.inboundSchema(PayScheduleType);

/** @internal */
export const FundingType$inboundSchema: z.ZodMiniType<FundingType, unknown> =
  openEnums.inboundSchema(FundingType);

/** @internal */
export const Hourly$inboundSchema: z.ZodMiniType<Hourly, unknown> = z.object({
  name: types.optional(types.string()),
  multiple: types.optional(types.number()),
});

export function hourlyFromJSON(
  jsonString: string,
): SafeParseResult<Hourly, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Hourly$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Hourly' from JSON`,
  );
}

/** @internal */
export const Fixed$inboundSchema: z.ZodMiniType<Fixed, unknown> = z.object({
  name: types.optional(types.string()),
});

export function fixedFromJSON(
  jsonString: string,
): SafeParseResult<Fixed, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Fixed$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Fixed' from JSON`,
  );
}

/** @internal */
export const CompanyPaidTimeOff$inboundSchema: z.ZodMiniType<
  CompanyPaidTimeOff,
  unknown
> = z.object({
  name: types.optional(types.string()),
});

export function companyPaidTimeOffFromJSON(
  jsonString: string,
): SafeParseResult<CompanyPaidTimeOff, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CompanyPaidTimeOff$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompanyPaidTimeOff' from JSON`,
  );
}

/** @internal */
export const Compensations$inboundSchema: z.ZodMiniType<
  Compensations,
  unknown
> = z.pipe(
  z.object({
    hourly: types.optional(z.array(z.lazy(() => Hourly$inboundSchema))),
    fixed: types.optional(z.array(z.lazy(() => Fixed$inboundSchema))),
    paid_time_off: types.optional(
      z.array(z.lazy(() => CompanyPaidTimeOff$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "paid_time_off": "paidTimeOff",
    });
  }),
);

export function compensationsFromJSON(
  jsonString: string,
): SafeParseResult<Compensations, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Compensations$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Compensations' from JSON`,
  );
}

/** @internal */
export const CompanyHomeAddress$inboundSchema: z.ZodMiniType<
  CompanyHomeAddress,
  unknown
> = z.pipe(
  z.object({
    street_1: types.optional(types.string()),
    street_2: z.optional(z.nullable(types.string())),
    city: types.optional(types.string()),
    state: types.optional(types.string()),
    zip: types.optional(types.string()),
    country: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "street_1": "street1",
      "street_2": "street2",
    });
  }),
);

export function companyHomeAddressFromJSON(
  jsonString: string,
): SafeParseResult<CompanyHomeAddress, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CompanyHomeAddress$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompanyHomeAddress' from JSON`,
  );
}

/** @internal */
export const PrimarySignatory$inboundSchema: z.ZodMiniType<
  PrimarySignatory,
  unknown
> = z.pipe(
  z.object({
    uuid: types.optional(types.string()),
    first_name: types.optional(types.string()),
    middle_initial: z.optional(z.nullable(types.string())),
    last_name: types.optional(types.string()),
    phone: types.optional(types.string()),
    email: types.optional(types.string()),
    home_address: types.optional(
      z.lazy(() => CompanyHomeAddress$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "first_name": "firstName",
      "middle_initial": "middleInitial",
      "last_name": "lastName",
      "home_address": "homeAddress",
    });
  }),
);

export function primarySignatoryFromJSON(
  jsonString: string,
): SafeParseResult<PrimarySignatory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrimarySignatory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrimarySignatory' from JSON`,
  );
}

/** @internal */
export const PrimaryPayrollAdmin$inboundSchema: z.ZodMiniType<
  PrimaryPayrollAdmin,
  unknown
> = z.pipe(
  z.object({
    first_name: types.optional(types.string()),
    last_name: types.optional(types.string()),
    phone: z.optional(z.nullable(types.string())),
    email: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "first_name": "firstName",
      "last_name": "lastName",
    });
  }),
);

export function primaryPayrollAdminFromJSON(
  jsonString: string,
): SafeParseResult<PrimaryPayrollAdmin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrimaryPayrollAdmin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrimaryPayrollAdmin' from JSON`,
  );
}

/** @internal */
export const Company$inboundSchema: z.ZodMiniType<Company, unknown> = z.pipe(
  z.object({
    ein: types.optional(types.string()),
    entity_type: z.optional(z.nullable(CompanyEntityType$inboundSchema)),
    contractor_only: types.optional(types.boolean()),
    tier: z.optional(z.nullable(TierEnum$inboundSchema)),
    is_suspended: types.optional(types.boolean()),
    company_status: types.optional(CompanyStatus$inboundSchema),
    is_high_risk_business: types.optional(types.boolean()),
    is_marijuana_business: types.optional(types.boolean()),
    uuid: types.string(),
    name: types.optional(types.string()),
    slug: types.optional(types.string()),
    trade_name: z.optional(z.nullable(types.string())),
    is_partner_managed: types.optional(types.boolean()),
    pay_schedule_type: z.optional(z.nullable(PayScheduleType$inboundSchema)),
    join_date: z.optional(z.nullable(types.string())),
    funding_type: z.optional(z.nullable(FundingType$inboundSchema)),
    locations: types.optional(z.array(CompanyAddress$inboundSchema)),
    compensations: types.optional(z.lazy(() => Compensations$inboundSchema)),
    primary_signatory: z.optional(z.nullable(z.lazy(() =>
      PrimarySignatory$inboundSchema
    ))),
    primary_payroll_admin: types.optional(z.lazy(() =>
      PrimaryPayrollAdmin$inboundSchema
    )),
  }),
  z.transform((v) => {
    return remap$(v, {
      "entity_type": "entityType",
      "contractor_only": "contractorOnly",
      "is_suspended": "isSuspended",
      "company_status": "companyStatus",
      "is_high_risk_business": "isHighRiskBusiness",
      "is_marijuana_business": "isMarijuanaBusiness",
      "trade_name": "tradeName",
      "is_partner_managed": "isPartnerManaged",
      "pay_schedule_type": "payScheduleType",
      "join_date": "joinDate",
      "funding_type": "fundingType",
      "primary_signatory": "primarySignatory",
      "primary_payroll_admin": "primaryPayrollAdmin",
    });
  }),
);

export function companyFromJSON(
  jsonString: string,
): SafeParseResult<Company, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Company$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Company' from JSON`,
  );
}
